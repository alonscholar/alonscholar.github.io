{"meta":{"title":"AlonScholar","subtitle":"","description":"","author":"Alon Scholar","url":"https://alonscholar.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-08-21T07:08:46.426Z","updated":"2021-08-21T07:03:58.223Z","comments":false,"path":"/404.html","permalink":"https://alonscholar.github.io/404.html","excerpt":"","text":""},{"title":"个人简历","date":"2021-09-22T13:02:50.584Z","updated":"2021-09-22T13:02:50.584Z","comments":false,"path":"about/index.html","permalink":"https://alonscholar.github.io/about/index.html","excerpt":"","text":"基本信息： 赵鑫 / 男 / 22 / 党员 现 在 地： 山东泰安 手 机 号： 15288923500 Q Q： 2530394412 邮 箱： 2530394412@qq.com 工作经验： 一年 证 书： 计算机二级、蓝桥杯省二、英语四级 GitHub： https://github.com/alonscholar 个人网站： https://alonscholar.github.io/ 求职意向 期望职位： JAVA开发工程师 期望薪资： 7000-11000 教育背景 山东科技大学泰山科技学院 2018.09-2022.06 计算机科学与技术 实习经历 公司： 山东鑫超网络科技有限公司 职位： JAVA开发工程师 时间： 2021.01-2021.02 个人作品 名称： 在线教学系统 简介： 本项目使用了Vue+SpringCloud搭建，并使用阿里云Oss存储以及视频点播服务，另外还实现了手机号验证码注册和登录等功能，线上地址：http://www.zyczx.top/ 名称： 大数据疫情实时观测 简介： 本项目实现了展示新冠疫情的各地区的新增人数，累计确诊、累计治愈、累计死亡等情况。并使用了现代科技化的界面设计，以及echarts图标数据展示，线上地址：http://yq.zyczx.top/ 名称： 个人网站 简介： 本项目是基于Hexo框架实现的个人网站，其中包括了个人所记录的学习笔记以及前沿技术知识。其中还包括自己的GitHub所发布的项目，https://alonscholar.github.io/ 技能清单 以下均为我熟练使用的技能： 编程语言：Java、Js、Vue、Python、C/C++ 前端开发：熟悉element-ui设计、Bootstrap使用、vue的基本框架vue-admin-template、nuxt等。熟练Html+Css+Js的网页设计，了解微信小程序，会使用NodeJs以及Echarts图表，Ajax以及axios传递请求等等。 后端开发：熟悉并掌握了SpringBoot、SpringCloud、MyBatis-plus等Java框架，了解SpringSecurity、Shiro安全框架，会使用SpringMVC基本框架以及Servlet,Jsp相关技术。并会使用Redis进行缓存处理，EasyPoi实现表格上传与导出… 其他：数据库熟练使用Mysql，了解SqlServer，会使用基本的Linux命令，以及Nginx配置反向代理与负载均衡，学习过Docker，Nacos配置服务中心，懂得一些算法设计知识，会使用Git版本控制工具。 以下是我接触并了解的技能： GoLang（学习中）、Netty、Kubernetes、RabbitMQ等等 自我评价 &emsp;&emsp;我是一个热爱技术热爱编程的人，大学四年自学编程，做过很多小项目（黄金矿工、坦克大战、超级玛丽游戏等等），上架了3个网站，其中在线教学是开发给老师与学生使用，并获得了一些好评。同时我也是一个热爱分享技术的人，在CSDN也发布过很多文章，同时拥有自己的个人网站：https://alonscholar.github.io/，在我的个人网站中，我会分享很多自己学过的技术知识等等。 &emsp;&emsp;我希望在以后的工作中，深度上能学习掌握更多关于JAVA开发的高级知识及数据结构算法；广度上能扩宽自己的技术栈，如前端、后端、混合开发以及其他比较新潮有趣的技术等；高度上希望经过未来几年的职业生涯发展，能成为架构师级的技术专家。"},{"title":"推荐书籍","date":"2021-08-21T15:38:24.017Z","updated":"2021-08-21T15:38:24.017Z","comments":false,"path":"books/index.html","permalink":"https://alonscholar.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-08-21T07:09:04.359Z","updated":"2021-08-21T07:03:58.225Z","comments":false,"path":"categories/index.html","permalink":"https://alonscholar.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-21T15:35:41.282Z","updated":"2021-08-21T15:35:41.282Z","comments":false,"path":"links/index.html","permalink":"https://alonscholar.github.io/links/index.html","excerpt":"","text":""},{"title":"GitHub仓库","date":"2021-08-21T15:45:56.821Z","updated":"2021-08-21T15:45:56.821Z","comments":false,"path":"repository/index.html","permalink":"https://alonscholar.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-21T07:09:12.025Z","updated":"2021-08-21T07:03:58.227Z","comments":false,"path":"tags/index.html","permalink":"https://alonscholar.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"跟Alon学数据结构(入门)-第8章 排序","slug":"跟Alon学数据结构(入门)-第8章 排序","date":"2021-10-05T13:04:35.000Z","updated":"2021-10-05T08:20:47.628Z","comments":true,"path":"2021/10/05/跟Alon学数据结构(入门)-第8章 排序/","link":"","permalink":"https://alonscholar.github.io/2021/10/05/%E8%B7%9FAlon%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%85%A5%E9%97%A8)-%E7%AC%AC8%E7%AB%A0%20%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序 排序是计算机程序设计中的一种重要操作， 在很多领域中都有广泛的应用。排序的一个主要目的是便于查找， 从第7章的讨论中容易看出，有序的顺序表可以采用查找效率较高的折半查找法，又如创建树表（无论是二叉排序树还是B树）的过程本身就是一个排序的过程。本章仅讨论几种典型的、常用的排序方法。 基本概念和排序方法概述 排序的基本概念 内部排序方法的分类 待排序记录的存储方式 排序算法效率的评价指标 插入排序 直接插入排序 折半插入排序 希尔排序 交换排序 冒泡排序 快速排序 选择排序 简单选择排序 树形选择排序 堆排序 归并排序 基数排序 多关键字的排序 链式基数排序 外部排序 外部排序的基本方法 多路平衡归并的实现 置换—选择排序 最佳归并树","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"跟Alon学数据结构(入门)-第7章 查找","slug":"跟Alon学数据结构(入门)-第7章 查找","date":"2021-10-01T02:04:35.000Z","updated":"2021-10-05T08:26:23.753Z","comments":true,"path":"2021/10/01/跟Alon学数据结构(入门)-第7章 查找/","link":"","permalink":"https://alonscholar.github.io/2021/10/01/%E8%B7%9FAlon%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%85%A5%E9%97%A8)-%E7%AC%AC7%E7%AB%A0%20%E6%9F%A5%E6%89%BE/","excerpt":"","text":"查找 在实际应用中，查找运算是非常常见的。面向一些数据量很大的实时系统，如订票系统、互联网上的信息检索系统等，查找效率尤其重要。本章将针对查找运算，讨论应该采用何种数据结构，使用什么样的方法，并通过对它们的效率进行分析来比较各种查找算法在不同情况下的优劣。 查找的基本概念 为了便于后面各节对各种查找算法的比较，首先介绍查找的概念和术语。 查找表 查找表是由同一类型的数据元素（或记录）构成的集合。由于 “集合” 中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构，可以利用其他的数据结构来实现，比如本章将要介绍的线性表、树表及散列表等。 关键字 关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。若此关键字 可以唯一地标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为次关键字。当数据元素只有一个数据项时，其关键字即为该数据元素的值。 查找 查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找成功，此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个 “空” 记录或 “空” 指针。 动态查找表和静态查找表 若在查找的同时对表做修改操作（如插入和删除），则相应的表称之为动态查找表，否则称之为静态查找表。换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回；否则插入关键字等于给定值的记录。 平均查找长度 为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度（Average Search Length，ASL）。 对于含有n个记录的表，查找成功时的平均查找长度为 ASL=∑i=1nPiCiASL=\\sum\\limits_{i=1}^nP_iC_iASL=i=1∑n​Pi​Ci​ 其中，PiP_iPi​为查找表中第 i 个记录的概率，且 ∑i=1nPi=1\\sum\\limits_{i=1}^nP_i=1i=1∑n​Pi​=1； CiC_iCi​为找到表中其关键字与给定值相等的第 i 个记录时，和给定值已进行过比较的关键字个数。显然，CiC_iCi​随查找过程不同而不同。 由于查找算法的基本运算是关键字之间的比较操作，所以可用平均查找长度来衡量查找算法的性能。 线性表的查找 顺序查找 顺序查找（Sequential Search）的查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。 一般线性表的顺序查找 顺序查找方法既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构。下面介绍以线性表的推广数组作为存储结构时实现的顺序查找算法。对于一般的线性表，其思想类似。 顺序查找的算法描述如下： 123456789//在数组arr中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0//假设数组0号单元不存储元素，从下标1开始存储。int Search_Seq(int arr[],int length,int key)&#123; for(int i=length;i&gt;=1;i--)&#123; //从后往前找 if(arr[i]==key) return i; //返回元素的位序 &#125; return 0; //查找失败，返回0&#125; 在上述算法的查找过程中每步都要检测整个表是否查找完毕，即每步都要有循环变量是否满足条件i &gt;=1的检测。改进这个程序，可以免去这个检测过程。改进方法是查找之前先对arr[0]的关键字赋值key，在此，arr[0]起到了监视哨的作用，如下算法所示。 12345678//在数组arr中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0//假设数组0号单元不存储元素，从下标1开始存储。int Search_Seq(int arr[],int length,int key)&#123; int i; arr[0]=key; //&quot;哨兵&quot; for(i=length;arr[i]!=key;i--); //从后往前找 return i; //查找成功返回元素位序。查找失败，返回0&#125; 在上述算法中，将arr[0]称为“哨兵”。引入它的目的是使得Search_Seq内的循环不必判断数组是否会越界，因为满足i==0时，循环一定会跳出。需要说明的是，在程序中引入“哨兵”并不是这个算法独有的。引入“哨兵”可以避免很多不必要的判断语句，从而提高程序效率。 同顺序表的按值查找一样，在第2章中已给出分析，即 ASL=1n∑i=1ni=n+12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^ni = \\frac{n+1}{2}ASL=n1​i=1∑n​i=2n+1​，时间复杂度为 O(n)。 顺序查找的优点是：算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。其缺点是：平均查找长度较大，查找效率较低，所以当n很大时， 不宜采用顺序查找。 有序表的顺序查找 若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。 可以用如下图所示的判定树来描述有序顺序表的查找过程。树中的圆形结点表示有序顺序表中存在的元素；树中的矩形结点称为失败结点（若有n个结点，则相应地有n+1个查找失败结点），它描述的是那些不在表中的数据值的集合。若查找到失败结点，则说明查找不成功。 算法实现步骤如下： 从前往后顺序查找线性表，若第 i 个元素等于查找值key，返回 i。 若第 i 个元素大于查找值key，说明线性表中没有该元素，返回 0。 若遍历完线性表，即 i &gt; length，说明线性表中的元素都小于给定值key，查找失败，返回0。 12345678910111213141516//在数组arr中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0//假设数组0号单元不存储元素，从下标1开始存储。int Search_Seq(int arr[],int length,int key)&#123; int i; for(i=1;i&lt;=length;i++)&#123; if(arr[i]==key) break; if(arr[i]&gt;key)&#123; i=0; break; &#125; &#125; if(i&gt;length) i=0; return i;&#125; 在有序表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，因为不需要到达最后一个元素便可确定查找失败，所以效率比一般的顺序查找算法好一些。 注意，有序表的顺序查找和后面的折半查找的思想是不一样的，且有序表的顺序查找中的线性表可以是链式存储结构。 折半查找 折半查找（Binary Search）也称二分查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。在下面及后续的讨论中，均假设有序表是递增有序的。 折半查找的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。 折半查找每一次查找比较都使查找范围缩小一半，与顺序查找相比，很显然会提高查找效率。 为了标记查找过程中每一次的查找区间，下面分别用low和high来表示当前查找区间的下界和上界，mid为区间的中间位置。 折半查找的算法实现步骤如下： 置查找区间初值，low为0，high为表长-1。 当low小于等于high时，循环执行以下操作： mid取值为low和high的中间值； 将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid； 若不相等则利用中间位置记录将表对分成前、后两个子表。如果key比中间位置记录的关键字小，则 high取为mid-1，否则low取为mid+1。 循环结束，说明查找区间为空，则查找失败，返回-1。 1234567891011121314//二分查找，数组存在关键字key，返回其下标。不存在返回-1int Search_Bin(int arr[], int length, int key)&#123; int low = 0, high = length-1 ,mid; while (low &lt;= high)&#123; mid = (low + high) / 2; if (arr[mid] == key) //找到待查元素 return mid; else if (arr[mid] &lt; key) //继续在后一子表进行查找 low = mid + 1; else //继续在前一子表进行查找 high = mid - 1; &#125; return -1;&#125; 本算法很容易理解，唯一需要注意的是，循环执行的条件是low&lt;=high，而不是low&lt;high，因为low=high时，查找区间还有最后一个结点，还要进一步比较。 将二分查找改造成为递归实现代码如下： 1234567891011int Search_Bin(int arr[],int low,int high,int key)&#123; if(low&gt;high) //查找失败 return -1; int mid = (low + high) / 2; if(arr[mid]==key) //找到待查元素 return mid; else if(arr[mid]&gt;key) //继续在前一子表进行查找 return Search_Bin(arr,low,mid-1,key); else //继续在后一子表进行查找 return Search_Bin(arr,mid+1,high,key);&#125; 折半查找的算法分析 例如，已知11个元素的有序表{7,10,13,16,19,29,32,33,37,41,43}\\{7,10,13,16,19,29,32,33,37,41,43\\}{7,10,13,16,19,29,32,33,37,41,43}，要查找值为11和32的元素，指针low和high分别指向表的下界和上界，mid则指向表的中间位置⌊(low+high)/2⌋\\lfloor(low+high)/2\\rfloor⌊(low+high)/2⌋。以下说明查找11的过程（查找32的过程请读者自行分析）： 第一次查找，将中间位置元素与key值比较。因为11&lt;29，说明待查元素若存在，则必在范围[low，mid-1]内，令指针high指向位置mid-1，high=mid-1=4，重新求得mid=(0+4)/2=2，第二次的查找范围为[0，4]。 第二次查找，同样将中间位置元素与key值比较。因为11&lt;13，说明待查元素若存在，则必在范围[low ，mid-1]内，令指针high指向位置mid-1，high=mid-1=1，重新求得mid=(0+1)/2=0，第三次的查找范围为[0，1]。 第三次查找，将中间位置元素与key值比较。因为11&gt;7，说明待查元素若存在，则必在范围[mid+1，high]内。令low=mid+1=1，mid=(1+1)/2=1，第四次的查找范围为[1，1]。 第四次查找，此时子表只含有一个元素，且10≠11，故表中不存在待查元素。 折半查找的过程可用下图所示的二叉树来描述，称为判定树。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找失败时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数；每个结点值均大于其左子结点值，且均小于其右子结点值。若有序序列有n个元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点。显然，判定树是一棵平衡二叉树。因此，折半查找在查找失败时和给定值进行比较的关键字个数最多也不超过⌊log2n⌋+1\\lfloor log_2n\\rfloor+1⌊log2​n⌋+1。 借助于判定树，很容易求得折半查找的平均查找长度。如下式所示： ASL=1n∑i=1nli=1n(1×1+2×2+...+h×2h−1)=n+1nlog⁡2(n+1)−1≈log⁡2(n+1)−1ASL = \\frac{1}{n}\\sum\\limits_{i=1}^nl_i=\\frac{1}{n}(1×1+2×2+...+h×2^{h-1})=\\frac{n+1}{n}\\log_2 (n+1)-1≈\\log_2 (n+1)-1ASL=n1​i=1∑n​li​=n1​(1×1+2×2+...+h×2h−1)=nn+1​log2​(n+1)−1≈log2​(n+1)−1 式中，h是树的高度，并且元素个数为n时，树高h=⌊log2n⌋+1h=\\lfloor log_2n\\rfloor+1h=⌊log2​n⌋+1。所以，折半查找的时间复杂度为 O(log2n)O(log_2n)O(log2​n)，平均情况下比顺序查找的效率高。但折半查找只适用于有序表，且限于顺序存储结构。 折半查找的优点是：比较次数少，查找效率高。其缺点是：对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。 分块查找 分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。 分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中对每个子表（或称块）建立一个索引项，其中包括两项内容：关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）。索引表按关键字有序。如下图所示： 因此，分块查找过程需分两步进行。在索引表中先确定待查记录所在的块（子表），然后在块中顺序查找。 注：由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的，则在块中只能是顺序查找。 假设给定值38，则先将key依次和索引表中各最大关键字进行比较，因为24&lt;38&lt;54，则38若存在，必在第二个子表中。由于第二个子表中的第一个记录是表中的第7个记录，则自第7个记录起进行顺序查找，若在第二个子表中找到，则返回其元素下标，否则查找失败。 分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的平均查找长度分别为LIL_ILI​，LSL_SLS​，则分块查找的平均查找长度为：ASL=LI+LSASL=L_I+L_SASL=LI​+LS​。 将长度为 n 的查找表均匀地分为b块，每块有s个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为：ASL=LI+LS=b+12+s+12=s2+2s+n2sASL = L_I+L_S = \\frac{b+1}{2}+ \\frac{s+1}{2}= \\frac{s^2 +2s+n}{2s}ASL=LI​+LS​=2b+1​+2s+1​=2ss2+2s+n​ 此时，若s=ns = \\sqrt {n}s=n​，则平均查找长度取最小值n+1\\sqrt{n}+1n​+1；若对索引表采用折半查找时，则平均查找长度为：ASL=LI+LS=⌈log2(b+1)⌉+s+12ASL = L_I+L_S = \\lceil log_2(b+1) \\rceil +\\frac{s+1}{2}ASL=LI​+LS​=⌈log2​(b+1)⌉+2s+1​ 分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。其缺点是：要增加一个索引表的存储空间并对初始索引表进行排序运算。 树表的查找 由于折半查找要求表中记录按关键字有序排列，且不能用链表做存储结构，因此，当表的插入或删除操作频繁时，为维护表的有序性，需要移动表中很多记录。这种由移动记录引起的额外时间开销，就会抵消折半查找的优点。所以，线性表的查找更适用于静态查找表，若要对动态查找表进行高效率的查找，可采用几种特殊的二叉树作为查找表的组织形式，在此将它们统称为树表。 二叉排序树 二叉排序树（Binary Sort Tree）又称二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。在第五章 树和二叉树(二叉排序树)中，已经详细介绍过，此处不再赘述。 平衡二叉树 二叉排序树查找算法的性能取决于二叉树的结构，而二叉排序树的形状则取决于其数据集。如果数据呈有序排列，则二叉排序树是线性的，查找的时间复杂度为O(n)；反之，如果二叉排序树的结构合理，则查找速度较快，查找的时间复杂度为O(log2n)O(log_2n)O(log2​n)。事实上，树的高度越小，查找速度越快。因此，希望二叉树的高度尽可能小。所以我们提出了平衡二叉树的概念，因为是由前苏联数学家Adelson-Velskii和Landis提出，所以又称AVL树。 在第五章 树和二叉树(平衡二叉树)中，也详细介绍过，此处不再赘述。 B树 前面介绍的查找方法均适用于存储在计算机内存中较小的文件，统称为内查找法。若文件很大且存放于外存进行查找时，这些查找方法就不适用了。内查找法都以结点为单位进行查找，这样需要反复地进行内、外存的交换，是很费时的。1970年，R.Bayer和E.Mccreight提出了一种适用于外查找的平衡多叉树—B树，磁盘管理系统中的目录管理，以及数据库系统中的索引组织多数都采用B树这种数据结构。 B树的定义 B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树： 树中每个结点至多有m棵子树，即至多含有m-1个关键字； 若根结点不是叶子结点，则至少有两棵子树； 除根结点外的所有非叶结点至少有⌈m/2⌉\\lceil m/2 \\rceil⌈m/2⌉棵子树，即至少含有⌈m/2⌉−1\\lceil m/2 \\rceil -1⌈m/2⌉−1个关键字； 所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点（失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析B树的查找性能）； 所有的非终端结点最多有m-1个关键字，结点的结构如下图所示。 其中，Ki(i=1,2,…,n)K_i(i= 1,2,…, n)Ki​(i=1,2,…,n)为结点的关键字，且满足K1&lt;K2&lt;…&lt;Kn；Pi(i=0,1,…,n)K_1&lt;K_2&lt;…&lt;K_n；P_i(i=0,1,…,n)K1​&lt;K2​&lt;…&lt;Kn​；Pi​(i=0,1,…,n)为指向子树根结点的指针，且指针Pi−1P_{i-1}Pi−1​所指子树中所有结点的关键字均小于KiK_iKi​，PiP_iPi​所指子树中所有结点的关键字均大于KiK_iKi​，n(⌈m/2⌉−1≤n≤m−1)n (\\lceil m/2 \\rceil-1≤n≤m-1)n(⌈m/2⌉−1≤n≤m−1)为结点中关键字的个数。 从上述定义可以看出，对任一关键字KiK_iKi​而言，Pi−1P_{i-1}Pi−1​相当于指向其 “左子树&quot;，PiP_iPi​相当于指向其 “右子树”。 B树具有平衡、有序、多路的特点，B树是所有结点的平衡因子均等于0的多路平衡查找树。下图所示的B树中所有结点的最大孩子数m=5，因此它是一棵5阶B树，在m阶B树中结点最多可以有m个孩子。可以借助该实例来分析上述性质： 结点的孩子个数等于该结点中关键字个数加1。 如果根结点没有关键字就没有子树，此时B树为空；如果根结点有关键字，则其子树必然大于等于两棵，因为子树个数等于关键字个数加1。 除根结点外的所有非终端结点至少有⌈m/2⌉=⌈5/2⌉=3\\lceil m/2 \\rceil= \\lceil5/2 \\rceil=3⌈m/2⌉=⌈5/2⌉=3棵子树（即至少有⌈m/2⌉−1=⌈5/2⌉−1=2\\lceil m/2 \\rceil -1= \\lceil5/2 \\rceil -1=2⌈m/2⌉−1=⌈5/2⌉−1=2个关键字），至多有5棵子树（即至多有4个关键字）。 结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字。或者看成下层结点关键字总是落在由上层结点关键字所划分的区间内，如第二层最左结点的关键字划分成了3个区间：（-∞，5），（5，11），（11，+∞），该结点3个指针所指子树的关键字均落在这3个区间内。 所有叶结点均在第4层，代表查找失败的位置。 在具体实现时，为记录其双亲结点，B树结点的存储结构通常增加一个parent指针，指向其双亲结点，存储结构示意图如下图所示。 B树的查找 由B树的定义可知，在B树上进行查找的过程和二叉排序树的查找类似。只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。 在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找（例如，在上图7.4中查找关键字42，首先从根结点开始，根结点只有一个关键字，且42&gt;22，若存在，必在关键字22的右边子树上，右孩子结点有两个关键字，而36&lt;42&lt;45，则若存在，必在36和45中间的子树上，在该子结点中查到关键字42，查找成功）。查找到叶结点时（对应指针为空指针)，则说明树中没有对应的关键字，查找失败。 由于B树主要用做文件的索引，因此它的查找涉及外存的存取，在此略去外存的读写，只做示意性的描述。假设结点类型定义如下： 12345678910111213#define m 5 //B树的阶，暂设为5typedef int KeyType; //KeyType为关键字类型typedef struct BTNode&#123; int keynum; //结点中关键字的个数，即结点的大小 struct BTNode *parent; //指向双亲结点 KeyType key[m+1]; //关键字向量，0号单元未用 struct BTNode *ptr[m+1]; //子树指针向量&#125;BTNode,*BTree;typedef struct&#123; BTNode *pt; //指向找到的结点 int i; //1...m 在结点中的关键字序号 int tag; //1:查找成功，0:查找失败&#125;Result; //B树的查找结果类型 在B树中查找的算法实现步骤如下： 将给定值key与根结点的各个关键字K1,K2,...,Kj(1≤j≤m−1)K_1,K_2,...,K_j(1≤j≤m-1)K1​,K2​,...,Kj​(1≤j≤m−1)进行比较，由于该关键字序列是有序的，所以查找时可采用顺序查找，也可以采用折半查找。查找时： 若key=Ki(1≤i≤j)key=K_i(1≤i≤j)key=Ki​(1≤i≤j)，则查找成功； 若key&lt;K1key&lt;K_1key&lt;K1​，则顺着指针P0P_0P0​所指向的子树继续向下查找； 若Ki&lt;key&lt;Ki+1(1≤i≤j−1)K_i&lt;key&lt;K_{i+1}(1≤i≤j-1)Ki​&lt;key&lt;Ki+1​(1≤i≤j−1)，则顺着指针PiP_iPi​所指向的子树继续向下查找； 若key&gt;Kjkey&gt;K_jkey&gt;Kj​，则顺着指针PjP_jPj​所指向的子树继续向下查找。 如果在自上而下的查找过程中，找到了值为key的关键字，则查找成功；如果直到叶子结点也未找到，则查找失败。 1234567891011121314151617181920212223242526272829//在结点p的关键字向量中进行查找，使得p-&gt;key[i]&lt;=key&lt;p-&gt;key[i+1]int Search(BTNode *p,KeyType key)&#123; int i=1; while (i&lt;p-&gt;keynum &amp;&amp; p-&gt;key[i]&lt;=key)&#123; i++; &#125;//循环结束，i最终指向大于key的第一个位置 return i-1;&#125;Result SearchBTree(BTree T,KeyType key)&#123; BTNode *p = T; //初始化，p指向根结点 BTNode *q = NULL; //q 指向 p 的双亲 bool found = false; //标记是否成功找到 int i = 0; Result r; //设定返回的查找结果 while (p&amp;&amp;!found)&#123; i = Search(p,key); if(i&gt;0&amp;&amp;p-&gt;key[i]==key) found = true; //找到待查关键字 else&#123; q = p; p = p-&gt;ptr[i]; &#125; &#125; if(found)&#123; r.pt = p; r.i = i; r.tag = 1; //查找成功 &#125;else&#123; r.pt = q; r.i = i; r.tag = 0; //查找不成功，返回K的插入位置信息 &#125; return r;&#125; 从上述算法中可见，B树的查找包含两个基本操作：（1）在B树中找结点；（2）在结点内找关键字。 由于B树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的（算法中没有体现），而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法查询等于key的关键字。显然，在磁盘上进行一次查找比在内存中进行一次查找耗费时间多出很多，因此，在磁盘上进行查找的次数，即待查关键字所在结点在B树上的层次数，是决定B树查找效率的首要因素。 知道了决定B树查找效率的主要因素，下面我们来分析B树的最大以及最小深度。 B树的深度（磁盘存取次数） 若n≥1，则对任意一棵包含n个关键字、深度为h、阶数为m的B树我们有如下分析： B树的最小深度分析 因为B树中每个结点最多有m棵子树，m-1个关键字，所以在一棵深度为h的m阶B树中关键字的个数应满足n≤(m−1)(1+m+m2+…+mh−1)=mh−1n≤(m-1)(1 + m+ m^2+…+ m^{h-1})=m^h-1n≤(m−1)(1+m+m2+…+mh−1)=mh−1，因此有h≥logm(n+1)h≥log_m(n+1)h≥logm​(n+1)。 B树的最大深度分析 若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的深度达到最大。由B树的定义：第一层至少有1个结点；第二层至少有2个结点；除根结点外的每个非终端结点至少有⌈m/2⌉\\lceil m/2 \\rceil⌈m/2⌉棵子树，则第三层至少有2⌈m/2⌉2 \\lceil m/2 \\rceil2⌈m/2⌉个结点……第h+1层至少有2(⌈m/2⌉)h−12 (\\lceil m/2 \\rceil)^{h-1}2(⌈m/2⌉)h−1个结点，注意到第h+1层是不包含任何信息的叶结点。对于关键字个数为n的B树，叶结点即查找不成功的结点为n+1，由此有n+1≥2(⌈m/2⌉)h−1n+1≥2(\\lceil m/2\\rceil)^{h-1}n+1≥2(⌈m/2⌉)h−1，即h≤log⌈m/2⌉((n+1)/2)+1h≤log_{\\lceil m/2\\rceil}((n+1)/2)+1h≤log⌈m/2⌉​((n+1)/2)+1。 通过以上分析，我们得知，一棵包含n个关键字，阶数为m的B树，其深度的取值范围是：logm(n+1)≤h≤log⌈m/2⌉((n+1)/2)+1log_m(n+1)≤h≤log_{\\lceil m/2\\rceil}((n+1)/2)+1logm​(n+1)≤h≤log⌈m/2⌉​((n+1)/2)+1。 B树的插入 在B树中找到插入的位置后，并不能简单地将其添加到终端结点中，因为此时可能会导致整棵树不再满足B树定义中的要求。将关键字key插入B树的过程如下： 定位：利用前述的B树查找算法，找出插入该关键字的最低层中的某个非叶结点（在B树中查找key时，会找到表示查找失败的叶结点，这样就确定了最底层非叶结点的插入位置。注意：插入位置一定是最低层中的某个非叶结点)。 插入：在B树中，每个非失败结点的关键字个数都在区间[⌈m/2⌉−1,m−1][\\lceil m/2\\rceil-1, m-1][⌈m/2⌉−1,m−1]内。在最低层的某个非终端结点中添加一个关键字，若该结点的关键字个数不超过m-1，则插入完成，否则表明结点已满，要产生结点的 “分裂&quot;，将此结点在同一层分成两个结点。一般情况下，结点分裂方法是：以中间关键字为界把结点一分为二，成为两个结点，并把中间关键字向上插入到双亲结点上，若双亲结点已满，则采用同样的方法继续分解。最坏的情况下，一直分解到树根结点，这时B树高度增加1。 例如，如下图所示为3阶的B树（图中略去F结点（即叶子结点）），假设需依次插入关键字30、26、85和7。我们分别用动画进行演示插入的操作。 插入元素 动画演示 30 26 85 7 通过上述插入元素动画的演示，每当我们需要分裂的时候，遵循从中间位置分隔，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中。 B树插入元素的算法步骤如下： 在B树中查找给定关键字的记录，若查找成功，则插入操作失败；否则将新记录作为空指针p插入到查找失败的叶子结点的上一层结点（由q指向）中。 若插入新记录和空指针后，q指向的结点的关键字个数未超过m-1，则插入操作成功，否则转入步骤3。 以该结点的第⌈m/2⌉\\lceil m/2 \\rceil⌈m/2⌉个关键字K⌈m/2⌉K_{\\lceil m/2 \\rceil}K⌈m/2⌉​为拆分点，将该结点分成3个部分：K⌈m/2⌉K_{\\lceil m/2 \\rceil}K⌈m/2⌉​左边部分、K⌈m/2⌉K_{\\lceil m/2 \\rceil}K⌈m/2⌉​、K⌈m/2⌉K_{\\lceil m/2 \\rceil}K⌈m/2⌉​右边部分。K⌈m/2⌉K_{\\lceil m/2 \\rceil}K⌈m/2⌉​左边部分仍然保留在原结点中；K⌈m/2⌉K_{\\lceil m/2 \\rceil}K⌈m/2⌉​右边部分存放在一个新创建的结点（由p指向）中；关键字值为K⌈m/2⌉K_{\\lceil m/2 \\rceil}K⌈m/2⌉​的记录和指针p插入到q的双亲结点中。因q的双亲结点增加一个新的记录，所以必须对q的双亲结点重复步骤2和步骤3的操作，依次类推，直至由q指向的结点是根结点，转入步骤4。 由于根结点无双亲，则由其分裂产生的两个结点的指针p和q，以及关键字为K⌈m/2⌉K_{\\lceil m/2 \\rceil}K⌈m/2⌉​的记录构成一个新的根结点。此时，B树的高度增加1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//关键字k和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中void Insert(BTNode *&amp;p,int i,KeyType K,BTNode *q)&#123; for(int j=p-&gt;keynum;j&gt;i;j--)&#123; p-&gt;key[i+1] = p-&gt;key[i]; p-&gt;ptr[i+1] = p-&gt;ptr[i]; &#125; p-&gt;key[i+1] = K; p-&gt;ptr[i+1] = q; if(q) q-&gt;parent=p; p-&gt;keynum++;&#125;//将结点p分裂成两个结点,前一半保留,后一半移入结点qvoid SplitBTNode(BTNode *&amp;p,BTNode *&amp;q)&#123; int i; int s=(m+1)/2; q=new BTNode; //给结点q分配空间 q-&gt;ptr[0]=p-&gt;ptr[s]; //后一半移入结点q for(i=s+1;i&lt;=m;i++)&#123; q-&gt;key[i-s]=p-&gt;key[i]; q-&gt;ptr[i-s]=p-&gt;ptr[i]; &#125; q-&gt;keynum=p-&gt;keynum-s; q-&gt;parent=p-&gt;parent; for(i=0;i&lt;=p-&gt;keynum-s;i++) //修改双亲指针 if(q-&gt;ptr[i]!=NULL) q-&gt;ptr[i]-&gt;parent=q; p-&gt;keynum=s-1; //结点p的前一半保留,修改结点p的keynum&#125;void NewRoot(BTNode *&amp;T,KeyType K,BTNode *&amp;p,BTNode *&amp;q)&#123; T=new BTNode; //分配空间 T-&gt;keynum=1; T-&gt;ptr[0]=p; T-&gt;ptr[1]=q; T-&gt;key[1]=K; if(p!=NULL) //调整结点p和q的双亲指针 p-&gt;parent=T; if(q!=NULL) q-&gt;parent=T; T-&gt;parent=NULL;&#125;bool InsertBTree(BTree &amp;T,KeyType K)&#123; Result r = SearchBTree(T,K); //根据关键字查找B树 if(r.tag) return false; //若查找成功，则插入操作失败 BTNode *q = r.pt; //q指向要插入的结点 BTNode *ap = NULL; bool finished = false; int s; while (q&amp;&amp;!finished)&#123; Insert(q,r.i,K,ap); if(q-&gt;keynum&lt;m) finished = true; //关键字个数未超过m-1，则插入操作成功 else&#123; //进行结点的分裂操作 s = (m+1)/2; SplitBTNode(q,ap); K = q-&gt;key[s]; q = q-&gt;parent; if(q) r = SearchBTree(q,K); &#125; &#125; if(!finished) //T是空树（参数q初值为NULL)或者根结点已分裂为结点*q和*ap NewRoot(T,K,q,ap); return true;&#125; B树的删除 B树中的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个数范围为[⌈m/2⌉−1,m−1][\\lceil m/2\\rceil-1, m-1][⌈m/2⌉−1,m−1]，因此将涉及结点的 “合并” 问题。 除了删除记录，还要删除该记录邻近的指针。若该结点为最下层的非终端结点，由于其指针均为空，删除后不会影响其他结点，可直接删除；若该结点不是最下层的非终端结点，邻近的指针则指向一棵子树，不可直接删除。此时可做如下处理： 将要删除记录用其右（左）边邻近指针指向的子树中关键字最小（大）的记录（该记录必定在最下层的非终端结点中）替换。采取这种方法进行处理，无论要删除的记录所在的结点是否为最下层的非终端结点，都可归结为在最下层的非终端结点中删除记录的情况。 例如，在下图中所示的B树上删去45，可用45的右边邻近指针上关键字的最小值50来代替45，然后删去50（也可用左邻近指针的最大值37来代替45，然后删去37）。因此，下面可以只讨论删除最下层非终端结点中的关键字的情形。有以下3种可能。 直接删除关键字：被删关键字所在结点中的关键字数目不小于⌈m/2⌉\\lceil m/2\\rceil⌈m/2⌉，则只需从该结点中删去该关键字KiK_iKi​和相应指针PiP_iPi​，树的其他部分不变。如下图所示，为例图所示B树中删除关键字12的操作。 兄弟够借：被删关键字所在结点中的关键字数目等于⌈m/2⌉−1\\lceil m/2\\rceil-1⌈m/2⌉−1，而与该结点相邻的右兄弟（或左兄弟）结点中的关键字数目大于⌈m/2⌉−1\\lceil m/2\\rceil-1⌈m/2⌉−1，则需将其兄弟结点中的最小（或最大）的关键字上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移关键字的关键字下移至被删关键字所在结点中。如在删除12的基础上再次删除50的操作如下图所示。 兄弟不够借：被删关键字所在结点和其相邻的兄弟结点中的关键字数目均等于⌈m/2⌉−1\\lceil m/2\\rceil-1⌈m/2⌉−1。假设该结点有右兄弟，且其右兄弟结点地址由双亲结点中的指针PiP_iPi​所指，则在删去关键字之后，它所在结点中剩余的关键字和指针，加上双亲结点中的关键字KiK_iKi​一起，合并到PiP_iPi​所指兄弟结点中（若没有右兄弟，则合并至左兄弟结点中）。例如，再次删除53，需要执行以下操作。 如果因为删除使双亲结点中关键字个数小于了⌈m/2⌉−1\\lceil m/2\\rceil-1⌈m/2⌉−1，则依次类推做相应处理。例如再次删除关键字37之后，B树的变化如下所示。 B+树 B+ 树是一种B树的变形树，更适合用于文件索引系统。 B+树和B树的差异 一棵m阶的B+树和m阶的B树的差异在于： 有n棵子树的结点中含有n个关键字，即每个关键字对应一棵子树； 所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接； 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。 下图所示为一棵4阶B+树。可以看出，分支结点的某个关键字是其子树中最大关键字的副本。通常在B+树中有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点。因此，可以对B+树进行两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根结点开始的多路查找。 B+树的查找、插入和删除 在B+树上进行随机查找、插入和删除的过程基本上与B树类似。 查找：若非终端结点上的关键字等于给定值，并不终止，而是继续向下直到叶子结点。因此，在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。B+树查找的分析类似于B树。 B+树不仅能够有效地查找单个关键字，而且更适合查找某个范围内的所有关键字。例如，在B+树上找出范围在[a,b]之间的所有关键字值。处理方法如下：通过一次查找找出关键字a，不管它是否存在，都可以到达可能出现 a 的叶子结点，然后在叶子结点中查找关键字值等于 a 或大于 a 的那些关键字，对于所找到的每个关键字都有一个指针指向相应的记录，这些记录的关键字在所需要的范围。如果在当前结点中没有发现大于b的关键字，就可以使用当前叶子结点的最后一个指针找到下一个叶子结点，并继续进行同样的处理，直至在某个叶子结点中找到大于b的关键字，才停止查找。 插入：仅在叶子结点上进行插入，当结点中的关键字个数大于m时要分裂成两个结点，它们所含关键字的个数分别为⌊m+12⌋\\lfloor \\frac{m+1}{2} \\rfloor⌊2m+1​⌋和⌈m+12⌉\\lceil \\frac{m+1}{2} \\rceil⌈2m+1​⌉；并且，它们的双亲结点中应同时包含这两个结点中的最大关键字。 删除：B+树的删除也仅在叶子结点进行，当叶子结点中最大关键字被删除时，其在非终端结点中的值可以作为一个 “分界关键字” 存在。若因删除而使结点中关键字的个数少于⌈m/2⌉\\lceil m/2 \\rceil⌈m/2⌉时，其和兄弟结点的合并过程和B树类似。 散列表的查找 散列表的基本概念 前面讨论了基于线性表、树表结构的查找方法，这类查找方法都是以关键字的比较为基础的。记录在存储结构中的位置与其关键字之间不存在确定关系，其查找时间与表的长度有关，特别是当结点个数很多时，查找时要大量地与无效结点的关键字进行比较，致使查找速度很慢。 如果能在元素的存储位置和其关键字之间建立某种直接关系，那么在进行查找时，就无需做比较或做很少次的比较，按照这种关系直接由关键字找到相应的记录。这就是散列查找法（HashSearch）的思想，它通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，散列查找法又叫杂凑法或散列法。 下面给出散列法中常用的几个术语。 名词 解释 散列函数和散列地址 在记录的存储位置p和其关键字key之间建立一个确定的对应关系H，使p=H(key)，称这个对应关系H为散列函数，p为散列地址。 散列表 一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常散列比的存储空间是一个一维数组，散列地址是数组的下标。 冲突和同义词 对不同的关键字可能得到同一散列地址，即key1≠key2，而H(key1)=H(key2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，key1和key2互称为同义词。 例如，对C语言某些关键字集合建立一个散列表，关键字集合为S1={main,int,float,while,return,break,switch,case,do}S_1=\\{main,int,float,while,return,break,switch,case,do\\}S1​={main,int,float,while,return,break,switch,case,do} 设定一个长度为26的散列表应该足够，散列表可定义为char HT[26][8]; 假设散列函数的值取为关键字key中第一个字母在字母表 a ~ z 的序号（序号范围为0~25），即H(key)=key[0]−′a′H(key)=key[0]-&#x27;a&#x27;H(key)=key[0]−′a′ 其中，key的类型是长度为8的字符数组，根据此散列函数构造的散列表如下表所示。 假设关键字集合需要进行扩充：S2=S1+{short,default,double,static,for,struct}S_2=S_1+\\{short,default,double,static,for,struct\\}S2​=S1​+{short,default,double,static,for,struct} 如果散列函数不变，新加入的六个关键字经过计算得到：H(short)=H(static)=H(struct)=18，H(default)=H(double)=3，H(for)=5，而18，3，5这几个位置均已存放相应的关键字，这就发生了冲突现象，其中，switch、short、static和struct称为同义词；float和for称为同义词；do、default和double称为同义词。 在实际应用中，理想化的、不产生冲突的散列函数极少存在，这是因为通常散列表中关键字的取值集合远远大于表空间的地址集。散列函数是一个多对一的映射，所以冲突是不可避免的，只能通过选择一个 “好” 的散列函数使得在一定程度上减少冲突。而一旦发生冲突，就必须采取相应措施及时予以解决。 综上所述，散列查找法主要研究两方面的问题：(1) 如何构造散列函数；(2) 如何处理冲突。 散列函数的构造方法 构造散列函数的方法很多，一般来说，应根据具体问题选用不同的散列函数，通常要考虑以下因素： 散列表的长度； 关键字的长度； 关键字的分布情况； 计算散列函数所需的时间； 记录的查找频率。 构造一个 “好” 的散列函数应遵循以下两条原则： 函数计算要简单，每一关键字只能有一个散列地址与之对应； 函数的值域需在表长的范围内，计算出的散列地址的分布应均匀，尽可能减少冲突。 下面介绍构造散列函数的几种常用方法。 数字分析法 如果事先知道关键字集合，且每个关键字的位数比散列表的地址码位数多，每个关键字由n位数组成，如k1k2...knk_1k_2...k_nk1​k2​...kn​，则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。 例如，有80个记录，其关键字为8位十进制数。假设散列表的表长为100，则可取两位十进制数组成散列地址，选取的原则是分析这80个关键字，使得到的散列地址尽量避免产生冲突。假设这80个关键字中的一部分如下所列： 对关键字全体的分析可以发现：第1，2位都是8和1，第3位只可能是3或4，第8位只能取2，5或7，因此这4位都不可取。由于第4、5、6和7位可看成是近乎随机的，因此可取其中任意两位，或取其中两位与另外两位的叠加求和后舍去进位作为散列地址。 数字分析法的适用情况：事先必须明确知道所有的关键字每一位上各种数字的分布情况。 平方取中法 通常在选定散列函数时不一定能知道关键字的全部情况，取其中哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，如果取关键字平方后的中间几位或其组合作为散列地址，则使随机分布的关键字得到的散列地址也是随机的，具体所取的位数由表长决定。平方取中法是一种较常用的构造散列函数的方法。 例如，为源程序中的标识符建立一个散列表，假设标识符为字母开头的字母数字串。约定内部编码规则如下： 把字母在字母表中的位置序号作为该字母的内部编码，如A为01，D为04，I为09。 数字直接用其自身作为内部编码，如1为01，2为02。 根据以上编码规则，可知 “IDA1” 的内部编码为 09040101，同理可得到其他标识符的内部编码。之后分别对内部编码进行平方运算，再取出第 7 位到第 9 位作为其相应标识符的散列地址，如下表所示。 标识符 内部编码 内部编码的平方 散列地址 IDA1 09040101 081723426090201 426 IDB2 09040202 081725252200804 252 XID3 24090403 580347516702409 516 YID4 25090404 629528372883216 372 平方取中法的适用情况：不能事先了解关键字的所有情况，或难于直接从关键字中找到取值较分散的几位。 折叠法 将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址，这种方法称为折叠法。 根据数位叠加的方式，可以把折叠法分为移位叠加和边界叠加两种。 移位叠加是将分割后每一部分的最低位对齐，然后相加； 边界叠加是将两个相邻的部分沿边界来回折叠，然后对齐相加。 例如，当散列表长为1000时，关键字key = 45387765213，从左到右按3位数一段分割，可以得到4个部分：453、877、652、13。分别采用移位叠加和边界叠加，求得散列地址为 995 和 914，如下图所示。 折叠法的适用情况：适合于散列地址的位数较少，而关键字的位数较多，且难于直接从关键字中找到取值较分散的几位。 除留余数法 假设散列表表长为m，选择一个不大于m的数p，用p去除关键字，除后所得余数为散列地址，即H(key)=key%p。 这个方法的关键是选取适当的p，一般情况下，可以选p为小于表长的最大质数。例如，表长m=100，可取p=97。 除留余数法计算简单，适用范围非常广，是最常用的构造散列函数的方法。它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模，这样能够保证散列地址一定落在散列表的地址空间中。 处理冲突的方法 选择一个 “好” 的散列函数可以在一定程度上减少冲突，但在实际应用中，很难完全避免发生冲突，所以选择一个有效的处理冲突的方法是散列法的另一个关键问题。创建散列表和查找散列表都会遇到冲突，两种情况下处理冲突的方法应该一致。下面以创建散列表为例，来说明处理冲突的方法。 处理冲突的方法与散列表本身的组织形式有关。按组织形式的不同，通常分两大类：开放地址法和链地址法。 开放地址法 开放地址法的基本思想是：把记录都存储在散列表数组中，当某一记录关键字key的初始散列地址H0=H(key)H_0=H(key)H0​=H(key)发生冲突时，以H0H_0H0​为基础，采取合适方法计算得到另一个地址H1H_1H1​，如果H1H_1H1​仍然发生冲突，以H1H_1H1​为基础再求下一个地址H2H_2H2​，若H2H_2H2​仍然冲突，再求得H3H_3H3​。依次类推，直至HkH_kHk​不发生冲突为止，则HkH_kHk​为该记录在表中的散列地址。 这种方法在寻找 “下一个” 空的散列地址时，原来的数组空间对所有的元素都是开放的，所以称为开放地址法。通常把寻找 “下一个” 空位的过程称为探测，上述方法可用如下公式表示： Hi=(H(key)+di)%m，其中i=1,2,...,k(k≤m−1)H_i=(H(key)+d_i)\\%m，其中i=1,2,...,k(k≤m-1)Hi​=(H(key)+di​)%m，其中i=1,2,...,k(k≤m−1)。 其中，H(key)为散列函数，m为散列表表长，did_idi​为增量序列。根据did_idi​取值的不同，可以分为以下3种探测方法。 线性探测法 当di=1,2,…,m−1d_i=1,2,…, m - 1di​=1,2,…,m−1时，称为线性探测法。这种探测方法可以将散列表假想成一个循环表，发生冲突时，从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找，直到找到一个空位，就把此元素放入此空位中。如果找不到空位，则说明散列表已满，需要进行溢出处理。 二次探测法 当di=12,−12,22,−22,…,k2,−k2d_i=1^2,-1^2,2^2,-2^2,…, k^2,-k^2di​=12,−12,22,−22,…,k2,−k2时，称为二次探测法，其中 k≤m/2，散列表长度m必须是一个可以表示成4k+3的素数，又称平方探测法。 平方探测法是一种较好的处理冲突的方法，可以避免出现 “堆积” 问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。 伪随机探测法 当di=d_i=di​=伪随机数序列时，称为伪随机探测法。 例如，散列表的长度为11，散列函数H(key)=key%11，假设表中已填有关键字分别为17、60、29的记录，如下图(a)所示。现有第四个记录，其关键字为38，由散列函数得到散列地址为 5，产生冲突。 若用线性探测法处理时，得到下一个地址6，仍冲突；再求下一个地址7，仍冲突；直到散列地址为8的位置为空时为止，处理冲突的过程结束，38填入散列表中序号为8的位置，如下图 (b) 所示。 注：从上述线性探测法处理的过程中可以看到一个现象：当表中i，i+1，i+2位置上已填有记录时，下一个散列位置为i、i+1、i+2和i+3的记录都将填入i+3的位置，这种在处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象称作 “二次聚集”（或称作 “堆积”），即在处理同义词的冲突过程中又添加了非同义词的冲突。 若用二次探测法，散列地址5冲突后，得到下一个地址6，仍冲突；再求得下一个地址4，无冲突，38填入序号为4的位置，如下图( c )所示。 若用伪随机探测法，假设产生的伪随机数为9，则计算下一个散列地址为(5+9)%11 = 3，所以38填入序号为3的位置，如下图(d) 所示。 可以看出，上述三种处理方法各有优缺点。线性探测法的优点是：只要散列表未填满，总能找到一个不发生冲突的地址。缺点是：会产生 “二次聚集” 现象。而二次探测法和伪随机探测法的优点是：可以避免 “二次聚集” 现象。缺点也很显然：不能保证一定找到不发生冲突的地址。 链地址法 链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有m个散列地址就有m个单链表，同时用数组 HT[0…m-1] 存放各个链表的头指针，凡是散列地址为 i 的记录都以结点方式插入到以 HT[i] 为头结点的单链表中。链地址法适用于经常进行插入和删除的情况。 例如，关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79}，散列函数H(key)=key%13，用链地址法处理冲突，建立的表如下图所示。 这种构造方法在具体实现时，依次计算各个关键字的散列地址，然后根据散列地址将关键字插入到相应的链表中。 散列表的查找 在散列表上进行查找的过程和创建散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下： 给定待查找的关键字key，根据造表时设定的散列函数计算H0=H(key)H_0=H(key)H0​=H(key)。 若单元H0H_0H0​为空，则所查元素不存在。 若单元H0H_0H0​中元素的关键字为key，则查找成功。 否则重复下述解决冲突的过程： 按处理冲突的方法，计算下一个散列地址HiH_iHi​； 若单元HiH_iHi​为空，则所查元素不存在； 若单元HiH_iHi​中元素的关键字为key，则查找成功。 例如，关键字序列{19,14,23,01,68,20,84,27,55,11,10,79}按散列函数 H(key)=key%13 和线性探测处理冲突构造所得的散列表L如下图所示。 给定值84的查找过程为：首先求得散列地址H(84)=6，因L[6]不空且L[6]≠84，则找第一次冲突处理后的地址H1=(6+1)%16=7H_1=(6+1)\\%16=7H1​=(6+1)%16=7，而L[7]不空且L[7]≠84，则找第二次冲突处理后的地址H2=(6+2)%16=8H_2=(6+2)\\%16=8H2​=(6+2)%16=8，L[ 8]不空且L[ 8]=84，查找成功，返回记录在表中的序号8。 给定值38的查找过程为：先求散列地址H(38)=12，L[12]不空且L[12]≠38，则找下一地址H1=(12+1)%16=13H_1=(12+1)\\%16=13H1​=(12+1)%16=13，由于L[13]是空记录，故表中不存在关键字为38的记录。 查找各关键字的比较次数如下图所示。平均查找长度为：ASL=(1×6+2+3×3+4+9)/12=2.5ASL= (1×6+2+3×3+4+9)/12=2.5ASL=(1×6+2+3×3+4+9)/12=2.5 对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同。 从散列表的查找过程可见： 虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需要以平均查找长度作为衡量散列表的查找效率的度量。 散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。散列表的装填因子一般记为α，定义为一个表的装满程度，即α=表中记录数n散列表长度mα = \\frac{表中记录数n}{散列表长度m}α=散列表长度m表中记录数n​ 散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观地看，α越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"跟Alon学数据结构(入门)-第6章 图","slug":"跟Alon学数据结构(入门)-第6章 图","date":"2021-09-06T10:43:35.000Z","updated":"2021-10-05T07:58:23.726Z","comments":true,"path":"2021/09/06/跟Alon学数据结构(入门)-第6章 图/","link":"","permalink":"https://alonscholar.github.io/2021/09/06/%E8%B7%9FAlon%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%85%A5%E9%97%A8)-%E7%AC%AC6%E7%AB%A0%20%E5%9B%BE/","excerpt":"","text":"图 图是一种比线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层中的多个元素（即其孩子结点）相关，但只能和上一层中一个元素（即其双亲结点）相关； 而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。 图的定义和基本术语 图的定义 图(Graph) G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。 类型 解释 图像表示 有向图 E(G)是有向边(也称弧)的有限集合，顶点对&lt;x,y&gt;有序，表示从顶点x到顶点y的弧。x称为弧尾，y称为弧头。 无向图 E(G)是无向边(简称边)的有限集合，顶点对(x,y)无序，称为与顶点x和顶点y相关联的一条边。 有向图G1=(V1,E1G_1=(V_1,E_1G1​=(V1​,E1​)；V1={v1,v2,v3,v4}V_1=\\{v1,v2,v3,v4\\}V1​={v1,v2,v3,v4}；E1={&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}E_1=\\{&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;\\}E1​={&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}。 无向图G2=(V2,E2)G_2=(V_2,E_2)G2​=(V2​,E2​)；V2={v1,v2,v3,v4,v5}V_2=\\{v1,v2,v3,v4,v5\\}V2​={v1,v2,v3,v4,v5}；E2={(v1,v2),(v1,v4),(v2,v3),(v2,v5),(v3,v4),(v3,v5)}E_2=\\{(v1,v2),(v1,v4),(v2,v3),(v2,v5),(v3,v4),(v3,v5)\\}E2​={(v1,v2),(v1,v4),(v2,v3),(v2,v5),(v3,v4),(v3,v5)}。 图的基本术语 用n表示图中顶点数目，用e表示边的数目， 下面介绍图结构中的一些基本术语。 名词 解释 子图 假设有两个图 G = (V,E) 和 G’ = (V’,E’), 如果V′⊆VV&#x27;\\subseteq VV′⊆V且 E′⊆EE&#x27;\\subseteq EE′⊆E, 则称 G’ 为 G 的子图。 无向完全图和有向完全图 对于无向图，若具有 n( n - 1)/2 条边，则称为无向完全图。 对于有向图，若具有n(n-1)条弧，则称为有向完全图。在完全图中任意两个顶点之间都存在边。 稀疏图和稠密图 有很少条边或弧（如e&lt;nlog2ne&lt;nlog_2ne&lt;nlog2​n) 的图称为稀疏图， 反之称为稠密图。 权和网 每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。 邻接点 对于无向图 G，如果图的边(v, v’)∈E，则称顶点 v 和 v’ 互为邻接点， 即 v 和 v’ 相邻接。边(v, v’)依附于顶点 v 和 v’，或者说边 (v, v’)与顶点 v 和 v’ 相关联。 度、入度和出度 顶点 v 的度是指和 v 相关联的边的数目，记为 TD(v)。对于有向图，顶点 v 的度分为入度和出度。入度是以顶点 v 为头的弧的数目，记为ID(v)；出度是以顶点 v 为尾的弧的数目，记为OD(v)。顶点 v 的度为 TD(v) = ID(v) + OD(v)。一般地，如果顶点viv_ivi​的度记为 TD(vi)TD(v_i)TD(vi​)，那么一个有n个顶点，e条边的图，满足：e=12∑i=1nTD(vi)e=\\frac{1}{2}\\sum\\limits_{i=1}^nTD(v_i)e=21​i=1∑n​TD(vi​)。 路径和路径长度 从顶点vpv_pvp​到顶点vqv_qvq​的路径是一个顶点序列(vp,vi1,vi2,…,vim,vq)(v_p,v_{i_1},v_{i_2},…,v_{i_m} , v_q)(vp​,vi1​​,vi2​​,…,vim​​,vq​)，当然关联的边也可以理解为路径的构成要素。有向图的路径是有向的。路径长度是一条路径上经过的边或弧的数目。 回路或环 第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有n个顶点，并且有大于n-1条边，则此图一定有环。 简单路径、 简单回路或简单环 在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路或简单环。 连通、连通图和连通分量 在无向图 G 中，如果从顶点 v 到顶点 v’ 有路径，则称 v 和 v’ 是连通的。若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量。 强连通图和强连通分量 在有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量。 连通图的生成树 连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。 有向树和生成森林 一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。 图的类型定义 图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。抽象数据类型图的定义如下： 1234567891011121314151617181920ADT Graph&#123; 数据对象：V是具有相同特性的数据元素的集合，称为顶点集。 数据关系：R=&#123;VR&#125; VR=&#123;&lt;v,w&gt;|v,w∈V且P(v,w)&lt;v,w&gt;表示从v到w的弧, 谓词P(v,w)定义了弧&lt;v,w&gt;的意义或信息&#125; 基本操作： CreateGraph(&amp;G,V,VR); //按V和VR的定义构造图G。 DestroyGraph(&amp;G); //销毁图G。 LocateVex(G,u); //若G中存在顶点u,则返回该顶点在图中的位置；否则返回其他信息。 GetVex(G,v); //返回v的值。 PutVex(&amp;G,v,value); //对v赋值value。 FirstAdjVex(G,v); //返回v的第一个邻接顶点。若v在G中没有邻接顶点，则返回“空” 。 NextAdjVex(G,v,w); //返回v的(相对于w的)下一个邻接顶点。若w是v的最后一个邻接点，则返回 “空”。 InsertVex(&amp;G,v); //在图G中增添新顶点v。 DeleteVex(&amp;G,v); //删除G中顶点v及其相关的弧。 InsertArc(&amp;G,v,w); //在G中增添弧&lt;v,w&gt;, 若G是无向图，则还增添对称弧&lt;w,v&gt;。 DeleteArc(&amp;G,v,w); //在G中删除弧&lt;v,w&gt;, 若G是无向图，则还删除对称弧&lt;w,v&gt;。 DFSTraverse(G); //对图进行深度优先遍历，在遍历过程中对每个顶点访问一次。 BFSTraverse(G); //对图进行广度优先遍历，在遍历过程中对每个顶点访问一次。&#125;ADT Graph 图的存储结构 由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有邻接表、十字链表和邻接多重表，应根据实际需要的不同选择不同的存储结构。 邻接矩阵 邻接矩阵表示法 所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系)，存储顶点之间邻接关系的二维数组称为邻接矩阵(Adjacency Matrix)。 设G=(V,E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵。 A[i][j]={1,若&lt;vi,vj&gt;或(vi,vj)∈E0,反之A[i][j]=\\begin{cases}1,&amp;\\text{若&lt;$v_i,v_j$&gt;或($v_i,v_j$)∈E}\\\\0,&amp;\\text{反之}\\end{cases} A[i][j]={1,0,​若&lt;vi​,vj​&gt;或(vi​,vj​)∈E反之​ 例如，无向图与有向图的邻接矩阵表示法如下图所示。 若G是网（带权图）， 则邻接矩阵可以定义为： A[i][j]={wi,j,若&lt;vi,vj&gt;或(vi,vj)∈E∞,反之A[i][j]=\\begin{cases}w_{i,j},&amp;\\text{若&lt;$v_i,v_j$&gt;或($v_i,v_j$)∈E}\\\\∞,&amp;\\text{反之}\\end{cases} A[i][j]={wi,j​,∞,​若&lt;vi​,vj​&gt;或(vi​,vj​)∈E反之​ 其中，wi,jw_{i,j}wi,j​表示边上的权值；∞可以用计算机中最大的数来进行表示。例如，无向网和有向网的邻接矩阵表示法如下图所示。 有时，在网中也将到达自己的路径设置为0，即邻接矩阵对角线上的元素都为0，这样会方便进行某些算法的操作，如下图所示。 用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外， 还需要用一个一维数组来存储顶点信息。 其形式说明如下： 1234567891011//-----图的邻接矩阵存储表示－－－－－//int占4个字节，表示范围为-2^31 到 2^31-1#define MaxInt 99999999 //表示极大值，即∞#define MaxVertexNum 100 //顶点数目的最大值typedef char VertexType; //顶点的数据类型typedef int ArcType; //边上权值的数据类型typedef struct&#123; VertexType vexs[MaxVertexNum]; //顶点表 ArcType arcs[MaxVertexNum][MaxVertexNum]; //邻接矩阵 int vexnum,arcnum; //图的当前点数和边数&#125;AMGraph; 采用邻接矩阵表示法创建无向网 已知一个图的点和边，使用邻接矩阵表示法来创建此图的方法比较简单，下面以一个无向网为例来说明创建图的算法。 输入总顶点数和总边数。 依次输入点的信息存入顶点表中。 初始化邻接矩阵，使每个权值初始化为极大值。 构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。 12345678910111213141516//邻接矩阵创建无向网void CreateUDN(AMGraph &amp;G)&#123; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; //输入总顶点数，总边数 for(int i=0;i&lt;G.vexnum;i++) //依次输入点的信息 cin&gt;&gt;G.vexs[i]; for(int i=0;i&lt;G.vexnum;i++) //初始化邻接矩阵，边的权值均置为极大值MaxInt，对角线为0 for(int j=0;j&lt;G.vexnum;j++) i==j?G.arcs[i][j] = 0:G.arcs[i][j] = MaxInt; int v1,v2,weight; //定义依附于边的两个顶点和权值 for(int i=0;i&lt;G.arcnum;i++)&#123; //构造邻接矩阵 cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;weight; //输人一条边依附的顶点及权值 G.arcs[v1][v2]=weight; //将(v1,v2)的权值置为weight G.arcs[v2][v1]=weight; //因为是无向网，所以两个方向都要设置 &#125;&#125; 该算法的时间复杂度是O(n2)O(n^2)O(n2)。 知道无向网的创建后，对于无向图的创建无非就是在初始化邻接矩阵时，将边的权值均初始化为0；再就是构造邻接矩阵时，将weight改为常量值1即可。同样的，对于有向图以及有向网只需要在无向图以及无向网的基础上稍加修改即可，主要就是修改在构造邻接矩阵时，不需要两个方向都赋值，仅需要一个方向赋值即可。 邻接矩阵表示法的优缺点 (1) 优点 便于判断两个顶点之间是否有边， 即根据A[i][j]A[i][j]A[i][j]是否为0或∞来判断。 便于计算各个顶点的度。对于无向图，邻接矩阵第 i 行值为1的元素之和就是顶点 i 的度；对于有向图，第 i 行值为1的元素之和就是顶点 i 的出度，第 i 列值为1的元素之和就是顶点 i 的入度。 (2) 缺点 不便于增加和删除顶点。 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n2)O(n^2)O(n2)。 空间复杂度高。如果是有向图，n个顶点需要n2n^2n2个单元存储边。如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要n(n-1)/2个单元即可。但无论以何种方式存储，邻接矩阵表示法的空间复杂度均为O(n2)O(n^2)O(n2)，这对于稀疏图而言尤其浪费空间。 邻接表 邻接表表示法 邻接表(Adjacency List) 是图的一种链式存储结构。在邻接表中，对图中每个顶点viv_ivi​建立一个单链表，把与viv_ivi​相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息， 把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：表头结点表和边表。 表头结点表 边表 由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。表头结点包括数据域(data)和链域(firstarc)两部分。数据域用于存储顶点viv_ivi​的名称或其他有关信息；链域用于指向链表中第一个结点。 由表示图中顶点间关系的2n个边链表组成。边链表中边结点包括邻接点域(adjvex)、数据域(info)和链域(nextarc)三部分。邻接点域指示与顶点viv_ivi​邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点viv_ivi​邻接的下一条边的结点。 下面我们给出有向图G1和无向图G2的邻接表表示。 在无向图的邻接表中，顶点viv_ivi​的度恰为第 i 个链表中的结点数；而在有向图中，第 i 个链表中的结点个数只是顶点viv_ivi​的出度，为求入度，必须遍历整个邻接表。在所有链表中，其邻接点域的值为 i 的结点的个数是顶点viv_ivi​的入度。有时，为了便于确定顶点的入度，可以建立一个有向图的逆邻接表，即对每个顶点viv_ivi​建立一个链接所有进入viv_ivi​的边的表，如上图中( c )所示。 根据上述讨论，要定义一个邻接表，需要先定义其存放顶点的头结点和表示边的边结点。图的邻接表存储结构说明如下： 1234567891011121314151617181920//-----图的邻接表存储表示－－－－－#define MaxVertexNum 100 //最大顶点数typedef char VertexType; //顶点的数据类型typedef int OtherInfo; //边结点的其他信息类型typedef struct ArcNode&#123; //边结点 int adjvex; //该边所指向的顶点的位置 struct ArcNode *nextarc; //指向下一条边的指针 OtherInfo info; //和边相关的信息,这里定义为int类型，表示权值&#125;ArcNode;typedef struct VNode&#123; //顶点信息 VertexType data; struct ArcNode *firstarc; //指向第一条依附该顶点的边的指针&#125;VNode,AdjList[MaxVertexNum];typedef struct&#123; AdjList vertices; int vexnum,arcnum; //图中的当前顶点数和边数&#125;ALGraph; 采用邻接表表示法创建无向图 基于上述的邻接表表示法， 要创建一个图则需要创建其相应的顶点表和边表。下面以一个无向图为例来说明采用邻接表表示法创建无向图的算法。 输入总顶点数和总边数。 依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。 创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号 i 和 j 之后， 将此边结点分别插入 viv_ivi​ 和 vjv_jvj​ 对应的两个边链表的头部。 1234567891011121314151617181920212223//邻接表创建无向图void CreateUDG(ALGraph &amp;G)&#123; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; //输入总顶点数、总边数 for(int i=0;i&lt;G.vexnum;i++)&#123; //输入各点,构造表头结点表 cin&gt;&gt;G.vertices[i].data; //输入顶点值 G.vertices[i].firstarc=NULL; //初始化表头结点的指针域为NULL &#125; int v1,v2; ArcNode *p1,*p2; for(int i=0;i&lt;G.arcnum;i++)&#123; //输入各边,构造邻接表 cin&gt;&gt;v1&gt;&gt;v2; //输入两个顶点的序号 p1 = new ArcNode; //生成一个新的边结点*p1 p1-&gt;adjvex = v2; //邻接点序号为v2 p1-&gt;nextarc = G.vertices[v1].firstarc; //头插法到v1序号的链表中 G.vertices[v1].firstarc = p1; //对于有向图，不需要下面的操作。 p2 = new ArcNode; //生成另一个对称的新的边结点*p2 p2-&gt;adjvex = v1; //邻接点序号为v1 p2-&gt;nextarc = G.vertices[v2].firstarc; //头插法到v2序号的链表中 G.vertices[v2].firstarc = p2; &#125;&#125; 该算法的时间复杂度是O(n+e)O(n + e)O(n+e)。 建立有向图的邻接表与此类似， 只是更加简单， 每读入一个顶点对序号&lt;i,j&gt;仅需生成一个邻接点序号为 j 的边表结点， 并将其插入到 viv_ivi​ 的边链表头部即可。若要创建网的邻接表， 可以将边的权值存储在 info域中。 邻接表表示法的优缺点 (1) 优点 便于增加和删除顶点。 便于统计边的数目， 按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n+e)O(n+e)O(n+e)。 空间效率高。对于一个具有n个顶点e条边的图 G，若 G 是无向图，则在其邻接表表示中有 n 个顶点表结点和 2e 个边表结点；若 G 是有向图，则在它的邻接表表示或逆邻接表表示中均有 n 个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为 O(n+e)O(n + e)O(n+e)，适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。 (2) 缺点 不便于判断顶点之间是否有边，要判定 viv_ivi​ 和 vjv_jvj​ 之间是否有边，就需扫描第 i 个边表，最坏情况下要耗费 O(n)O(n)O(n) 时间。 不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点 viv_ivi​ 的度是第 i 个边表中的结点个数。 在有向图的邻接表中，第 i 个边表上的结点个数是顶点 viv_ivi​ 的出度，但求 viv_ivi​ 的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。 十字链表 十字链表表示法 十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构如下图所示。 结点名称 各个域的功能解释 弧结点 尾域(tailvex)和头域(headvex)分别指示弧尾和弧头这两个顶点在图中的位置；链域 hlink 指向弧头相同的下一条弧；链域 tlink 指向弧尾相同的下一条弧；info域指向该弧的相关信息。这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上。 顶点结点 data域存放顶点相关的数据信息，如顶点名称; firstin和firstout两个域分别指向以该顶点为弧头或弧尾的第一个弧结点。 下图为有向图的十字链表表示法。注意，顶点结点之间是顺序存储的。从十字链表的数据结构来看，每一个顶点对应两个链表：以该顶点为弧尾的弧结点所组成的链表以及以该顶点为弧头的弧结点所组成的链表。 注：在上图中，以序号为0的A结点说明： 黄色(firstin) 指向的是以A为弧头的链表中的第一条弧，而顺着这条链表可以找到所有以A为弧头的弧结点，也就是说可以找到A顶点所有入度结点。绿色(firstout) 指向的是以A为弧尾的链表中的第一条弧，顺着这条链表可以找到所有以A为弧尾的弧结点，即顶点A的所有出度结点。 有向图的十字链表存储表示的形式说明如下所示： 1234567891011121314151617181920//----- 有向图的十字链表存储表示 -----#define MAX_VERTEX_NUM 20 //最大顶点数typedef char VertexType; //顶点的数据类型typedef int InfoType;typedef struct ArcBox&#123; //弧结点定义 int tailvex,headvex; //该弧的尾和头顶点的位置 struct ArcBox *hlink,*tlink; //分别为弧头相同和弧尾相同的弧的链域 InfoType info; //该弧相关信息，这里我们保存权值&#125;ArcBox;typedef struct VexNode&#123; //顶点结点定义 VertexType data; ArcBox *firstin,*firstout; //分别指向该顶点第一条入弧和出弧&#125;VexNode;typedef struct&#123; VexNode xlist[MAX_VERTEX_NUM]; //表头向量 int vexnum,arcnum; //有向图的当前顶点数和弧数&#125;OLGraph; 采用十字链表表示法创建有向网 对于十字链表表示法的创建，对于每一个边结点需要隶属于两个链表，分别是弧头相同所组成的链表以及弧尾相同所组成的链表。 输入总顶点数和总边数。 依次输入点的信息存入顶点表中，使每个入弧表头结点的指针域为NULL，以及出弧表头结点的指针域为NULL。 创建十字链表。依次输入每条边依附的两个顶点v1，v2以及他们的权值，赋予新结点p。 将新结点p头插入到以v1为弧尾的链表。 将新结点p头插入到以v2为弧头的链表。 1234567891011121314151617181920212223242526//十字链表创建有向网void CreateDN(OLGraph &amp;G)&#123; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; //输入总顶点数、总边数 for(int i=0;i&lt;G.vexnum;i++)&#123; //输入各点,构造表头结点表 cin&gt;&gt;G.xlist[i].data; //输入顶点值 G.xlist[i].firstin=NULL; //初始化入弧表头结点的指针域为NULL G.xlist[i].firstout=NULL; //初始化出弧表头结点的指针域为NULL &#125; int v1,v2,weight; //初始化定义两个顶点序号和权值,v1-&gt;v2 ArcBox *p; //初始化定义一个边结点 for(int i=0;i&lt;G.arcnum;i++)&#123; //输入各边,构造十字链表 cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;weight; //输入两个顶点的序号和权值 p = new ArcBox; p-&gt;headvex = v2; //弧头顶点为v2 p-&gt;tailvex = v1; //弧尾顶点为v1 p-&gt;info = weight; //弧的权值 //将边结点p头插到以v1为弧尾的链表中 p-&gt;tlink = G.xlist[v1].firstout; G.xlist[v1].firstout = p; //将边结点p头插到以v2为弧头的链表中 p-&gt;hlink = G.xlist[v2].firstin; G.xlist[v2].firstin = p; &#125;&#125; 该算法的时间复杂度是O(n+e)O(n + e)O(n+e)。 建立有向图不需要info域来存储权值。 在十字链表中，通过顶点的firstout链域找到第一条出弧边结点，在顺着tlink寻找即可找到该顶点的所有的出度边结点。通过顶点的firstin链域找到第一条入弧边结点，在顺着hlink寻找即可找到该顶点的所有入度边结点。 邻接多重表 邻接多重表表示法 邻接多重表(Adjacency Multilist)是无向图的另一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。因此，在进行这一类操作的无向图的问题中采用邻接多重表作存储结构更为适宜。 与十字链表类似，在邻接多重表中，每条边，顶点用一个结点表示，其结构如下所示。 在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。 下图为无向图的邻接多重表表示法。邻接多重表的各种基本操作的实现和邻接表类似。 邻接多重表的类型说明如下： 1234567891011121314151617181920//----- 无向图的邻接多重表存储表示 -----#define MAX_VERTEX_NUM 20 //最大顶点数typedef char VertexType; //顶点的数据类型typedef int InfoType;typedef struct EBox&#123; int i,j; //该边依附的两个顶点的位置 struct EBox *iLink,*jLink; //分别指向依附这两个顶点的下一条边 InfoType info; //该边其他信息&#125;EBox;typedef struct VexBox&#123; VertexType data; struct EBox *firstedge; //指向第一条依附该顶点的边&#125;VexBox;typedef struct&#123; VexBox adjmulist[MAX_VERTEX_NUM]; int vexnum,edgenum; //无向图的当前顶点数和边数&#125;AMLGraph; 采用邻接多重表表示法创建无向图 邻接多重表与十字链表的思想类似，只不过在此使用iLink存储以i为顶点的链域，jLink存储以j为顶点的链域。 输入总顶点数和总边数。 依次输入点的信息存入顶点表中，使每个顶点的firstedge初始为NULL。 创建邻接多重表，初始化新的边，依次输入每个边的顶点。 边中若带有顶点 i，则将顶点 i 放入对应的 iLink 链域。 边中若带有顶点 j，则将顶点 j 放入对应的 jLink 链域。 12345678910111213141516171819202122//邻接多重表创建无向图void CreateUDG(AMLGraph &amp;G)&#123; cin&gt;&gt;G.vexnum&gt;&gt;G.edgenum; //输入总顶点数、总边数 for(int i=0;i&lt;G.vexnum;i++)&#123; //输入各点,构造表头结点表 cin&gt;&gt;G.adjmulist[i].data; //输入顶点值 G.adjmulist[i].firstedge=NULL; //初始化表头结点的指针域为NULL &#125; int v1,v2; //初始化定义两个顶点序号 EBox *p; //初始化一条边 for(int i=0;i&lt;G.edgenum;i++)&#123; cin&gt;&gt;v1&gt;&gt;v2; //输入两个顶点的序号 p = new EBox; //开辟一个边的空间 p-&gt;i = v1; p-&gt;j = v2; //将连接边的顶点赋值 p-&gt;iLink = G.adjmulist[v1].firstedge; //将v1顶点放到以i链域中(头插法) G.adjmulist[v1].firstedge = p; p-&gt;jLink = G.adjmulist[v2].firstedge; //将v2顶点放到j链域中(头插法) G.adjmulist[v2].firstedge = p; &#125;&#125; 该算法的时间复杂度是O(n+e)O(n + e)O(n+e)。存储无向网，只需要加入权值即可。对于邻接多重表，也可以加入mark标志域，用于标记该条边是否已经被搜索过。 四种存储方式的比较 图的遍历 图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。 图的遍历比树的遍历要复杂得多，因为图的任一顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点上。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组 visited[ ]来标记顶点是否被访问过。图的遍历算法主要有两种：深度优先搜索和广度优先搜索。 深度优先搜索 深度优先搜索遍历的过程 深度优先搜索(Depth First Search, DFS)遍历类似于树的先序遍历，是树的先序遍历的推广。对于一个连通图，深度优先搜索遍历的过程如下。 从图中某个顶点v出发，访问v。 找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。 返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。 重复步骤(2)和(3)，直至图中所有顶点都被访问过，搜索结束。 以下图(a)中所示的无向图G4为例，深度优先搜索遍历图的过程如图(b)所示。 从顶点 v1v_1v1​ 出发，访问 v1v_1v1​ 。 在访问了顶点 v1v_1v1​ 之后，选择第一个未被访问的邻接点 v2v_2v2​ ，访问 v2v_2v2​ 。 以 v2v_2v2​ 为新顶点，重复此步，访问 v4v_4v4​ ， v8v_8v8​ ， v5v_5v5​ 。在访问了 v5v_5v5​ 之后， 由于 v5v_5v5​ 的邻接点都已被访问，此步结束。 搜索从 v5v_5v5​ 回到 v8v_8v8​ ，由于同样的理由，搜索继续回到 v4v_4v4​ ， v2v_2v2​ 直至 v1v_1v1​ ，此时由于 v1v_1v1​ 的另一个邻接点未被访问，则搜索又从 v1v_1v1​ 到 v3v_3v3​ ，再继续进行下去。 由此，得到的顶点访问序列为： v1−&gt;v2−&gt;v4−&gt;v8−&gt;v5−&gt;v3−&gt;v6−&gt;v7v_1-&gt;v_2-&gt;v_4-&gt;v_8-&gt;v_5-&gt;v_3-&gt;v_6-&gt;v_7v1​−&gt;v2​−&gt;v4​−&gt;v8​−&gt;v5​−&gt;v3​−&gt;v6​−&gt;v7​ 在深度优先搜索遍历的过程中会产生一个深度优先生成树，如下图所示。 深度优先搜索遍历的算法实现 显然，深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组 visited[n]，其初值为 “false”，一旦某个顶点被访问，则其相应的分量置为 “true”。 算法实现：深度优先搜索遍历连通图 从图中某个顶点 v 出发，访问 v，并置 visited[v]的值为 true。 依次检查 v 的所有邻接点w，如果 visited[w]的值为 false，再从 w 出发进行递归遍历，直到图中所有顶点都被访问过。 123456789101112bool visited[MaxVertexNum]; //访问标记数组,初始值都为falsevoid DFS(Graph G,int v)&#123; //从顶点v出发，深度优先遍历图G cout &lt;&lt; v &lt;&lt; &quot; &quot;; //访问顶点v visited[v] = true; //设已访问标记 //依次检查 v 的所有邻接点 w , FirstAdjVex (G, v)表示 v 的第一个邻接点 //NextAdjVex(G,v,w)表示 v 相对于 w 的下一个邻接点， w≥0 表示存在邻接点 for (w=FirstAdjVex(G,v);w&gt;=0;w=NextAdjVex(G,v,w))&#123; if (!visited[w])&#123; DFS(G,w); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS &#125; &#125;&#125; 对于查找邻接点的操作FirstAdjVex(G,v)及NextAdjVex(G,v,w)并没有具体展开。如果图的存储结构不同，这两个操作的实现方法不同，时间耗费也不同。在下面的邻接矩阵和邻接表的算法实现DFS中会具体说明，此处只看个思路即可。 若是非连通图，上述遍历过程执行之后，图中一定还有顶点未被访问，需要从图中另选一个未被访问的顶点作为起始点，重复上述深度优先搜索过程，直到图中所有顶点均被访问过为止。这样，要实现对非连通图的遍历，需要循环调用上述算法，具体实现如下面算法所示。 算法实现：深度优先搜索遍历非连通图 1234567void DFSTraverse(Graph G)&#123;//对于非连通图G做深度优先遍历 for(int v=0;v&lt;G.vexnum;v++) visited[v] = false; //访问标志数组初始化 for(int v=0;v&lt;G.vexnum;v++)&#123; if(!visited[v]) DFS(G,v); //对尚未访问的顶点调用DFS &#125;&#125; 对于此算法，每调用一次DFS()函数，将遍历一个连通分量，有多少次调用，就说明图中有多少个连通分量。 算法实现：采用邻接矩阵表示图的深度优先搜索遍历 我们下面以下图来说明如何使用邻接矩阵实现图的深度优先遍历。 假设从顶点2出发，深度优先遍历的过程分析如下： 首先访问2，并置2访问标记； 然后访问与2相邻且未被访问的顶点1(因为从邻接矩阵的角度，数组2的第一个值不为0的元素是1)，置1为访问标记； 然后访问与1相邻且未被访问的顶点5(此时会先经过2，但是visited[2]=true，所以跳过2)，置5访问标记； 此时5已没有未被访问过的邻接点，故返回上一个访问过的顶点1,与1也没有未被访问过的邻接点，故返回上一个访问过的顶点2，2继续往后循环找到顶点6继续6的操作… 12345678910bool visited[MaxVertexNum]; //访问标记数组,初始值都为falsevoid DFS_AM(AMGraph G,int v)&#123; //从顶点v出发，深度优先遍历图G cout &lt;&lt; v &lt;&lt; &quot; &quot;; //访问顶点v visited[v] = true; //设已访问标记 for (int w=0;w&lt;G.vexnum;w++)&#123; //遍历顶点v的所有邻接点w if (G.arcs[v][w]!=0 &amp;&amp; G.arcs[v][w]!=MaxInt &amp;&amp; !visited[w])&#123; DFS_AM(G,w); //对 v 的尚未访问的邻接顶点 w 递归调用 DFS_AM &#125; &#125;&#125; 算法实现：采用邻接表表示图的深度优先搜索遍历 邻接表的实现过程与邻接矩阵的思想类似，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。 1234567891011bool visited[MaxVertexNum]; //访问标记数组,初始值都为falsevoid DFS_AL(ALGraph G,int v)&#123; cout&lt;&lt;v&lt;&lt;&quot; &quot;; //访问第v个顶点 visited[v]=true; //置访问标志数组相应分量值为true ArcNode *p = G.vertices[v].firstarc; //p指向v的边链表的第一个边结点 while (p)&#123; if(!visited[p-&gt;adjvex]) //对 v 的尚未访问的邻接顶点递归调用 DFS_AL DFS_AL(G,p-&gt;adjvex); p = p-&gt;nextarc; &#125;&#125; 深度优先搜索遍历的算法分析 DFS算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为O(∣V∣)O(|V|)O(∣V∣)。 遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所用的存储结构。以邻接矩阵表示时，查找每个顶点的邻接点所需的时间为O(∣V∣)O(|V|)O(∣V∣)，故总的时间复杂度为O(∣V∣2)O(|V|^2)O(∣V∣2)。以邻接表表示时，查找所有顶点的邻接点所需的时间为O(∣E∣)O(|E|)O(∣E∣)，访问顶点所需的时间为O(∣V∣)O(|V|)O(∣V∣)，此时，总的时间复杂度为O(∣V∣+∣E∣)O(|V|+|E|)O(∣V∣+∣E∣)。 广度优先搜索 广度优先搜索遍历的过程 广度优先搜索(Breadth First Search，BFS)遍历类似于树的按层次遍历的过程。广度优先搜索遍历的过程如下。 从图中某个顶点v出发，访问v。 依次访问 v 的各个未曾访问过的邻接点。 分别从这些邻接点出发依次访问它们的邻接点，并使 “先被访问的顶点的邻接点“ 先于 ”后被访问的顶点的邻接点” 被访问。重复步骤(3)，直至图中所有已被访问的顶点的邻接点都被访问到。 例如，对图G4 进行广度优先搜索遍历的过程如下图 ( c ) 所示，具体过程如下。 从顶点 v1v_1v1​ 出发，访问 v1v_1v1​ 。 依次访问 v1v_1v1​ 的各个未曾访问过的邻接点 v2v_2v2​ 和 v3v_3v3​ 。 依次访问 v2v_2v2​ 的邻接点 v4v_4v4​ 和 v5v_5v5​，以及 v3v_3v3​ 的邻接点 v6v_6v6​ 和 v7v_7v7​，最后访问 v4v_4v4​ 的邻接点 v8v_8v8​。由于这些顶点的邻接点均已被访问， 并且图中所有顶点都被访问，由此完成了图的遍历。得到的顶点访问序列为： v1−&gt;v2−&gt;v3−&gt;v4−&gt;v5−&gt;v6−&gt;v7−&gt;v8v_1-&gt;v_2-&gt;v_3-&gt;v_4-&gt;v_5-&gt;v_6-&gt;v_7-&gt;v_8v1​−&gt;v2​−&gt;v3​−&gt;v4​−&gt;v5​−&gt;v6​−&gt;v7​−&gt;v8​ 图G4G_4G4​在广度优先搜索遍历的过程中会产生一个广度优先生成树，如下图所示。 注意：当使用邻接表存储时，因为表示方式不唯一，故得到的广度优先生成树也是不唯一的。对于非连通图的广度优先遍历会对应成一个森林。 广度优先搜索遍历的算法实现 可以看出，广度优先搜索遍历的特点是：尽可能先对横向进行搜索。设 x 和 y 是两个相继被访问过的顶点，若当前是以 x 为出发点进行搜索，则在访问 x 的所有未曾被访问过的邻接点之后，紧接着是以 y 为出发点进行横向搜索，并对搜索到的 y 的邻接点中尚未被访问的顶点进行访问。也就是说，先访问的顶点其邻接点亦先被访问。为此，算法实现时需引进队列保存已被访问过的顶点。 算法实现：广度优先搜索遍历连通图 从图中某个顶点 v 出发，访问 v，并置 visited[v] 的值为 true，然后将 v 进队。 只要队列不空，则重复下述操作： 队头顶点 u 出队； 依次检查 u 的所有邻接点 w，如果 visited[w] 的值为 false，则访问 w，并置 visited[w] 的值为 true，然后将 w 进队。 12345678910111213141516171819bool visited[MaxVertexNum]; //访问标记数组,初始值都为falsevoid BFS(Graph G,int v)&#123;//按广度优先非递归遍历连通图G cout&lt;&lt;v&lt;&lt;&quot; &quot;; //访问初始顶点v visited[v]=true; //置访问标志数组相应分址值为true InitQueue(Q); //辅助队列Q初始化， 置空 EnQueue(Q,v); //顶点v入队列Q while (!QueueEmpty(Q))&#123; //队列非空 DeQueue(Q, u); //队头元素出队并置为u //FirstAdjVex(G,u)表示u的第一个邻接点 //NextAdjVex(G,u,w)表示u相对于w的下一个邻接点，w≥0表示存在邻接点 for(w=FirstAdjVex(G,u);w&gt;=O;w=NextAdjVex(G,u,w))&#123; //检测顶点u的所有邻接点 if(!visited[w])&#123; //w为u的尚未访问的邻接顶点 cout&lt;&lt;w; //访问w visited[w]=true; //对w做已访问标记 EnQueue(Q,w); //顶点w入队列 &#125; &#125; &#125;&#125; 若是非连通图，上述遍历过程执行之后，图中一定还有顶点未被访问，需要从图中另选一个未被访问的顶点作为起始点，重复上述广度优先搜索过程，直到图中所有顶点均被访问过为止。 算法实现：广度优先搜索遍历非连通图 1234567void BFSTraverse(Graph G)&#123;//对于非连通图G做广度优先遍历 for(int v=0;v&lt;G.vexnum;v++) visited[v] = false; //访问标志数组初始化 for(int v=0;v&lt;G.vexnum;v++)&#123; //从0号开始遍历 if(!visited[v]) BFS(G,v); //对尚未访问的顶点调用BFS &#125;&#125; 对于此算法，每调用一次BFS()函数，将遍历一个连通分量，有多少次调用，就说明图中有多少个连通分量。 算法实现：采用邻接矩阵表示图的广度优先搜索遍历 1234567891011121314151617bool visited[MaxVertexNum]; //访问标记数组,初始值都为falsevoid BFS_AM(AMGraph G,int v)&#123;//按广度优先非递归遍历连通图G cout&lt;&lt;v&lt;&lt;&quot; &quot;; //访问初始顶点v visited[v]=true; //置访问标志数组相应分址值为true queue&lt;int&gt; Q; //辅助队列Q初始化， 置空 Q.push(v); //顶点v入队列Q while (!Q.empty())&#123; //队列非空 int u = Q.front(); Q.pop(); //队头元素出队并置为u for(int w=0;w&lt;G.vexnum;w++)&#123; //检测顶点u的所有邻接点 if(G.arcs[u][w]!=0 &amp;&amp; G.arcs[u][w]!=MaxInt &amp;&amp; !visited[w])&#123; //w为u的尚未访问的邻接顶点 cout&lt;&lt;w&lt;&lt;&quot; &quot;; //访问w visited[w]=true; //对w做已访问标记 Q.push(w); //顶点w入队列 &#125; &#125; &#125;&#125; 算法实现：采用邻接表表示图的广度优先搜索遍历 1234567891011121314151617181920bool visited[MaxVertexNum]; //访问标记数组,初始值都为falsevoid BFS_AL(ALGraph G,int v)&#123;//按广度优先非递归遍历连通图G cout&lt;&lt;v&lt;&lt;&quot; &quot;; //访问初始顶点v visited[v]=true; //置访问标志数组相应分址值为true queue&lt;int&gt; Q; //辅助队列Q初始化， 置空 Q.push(v); //顶点v入队列Q while (!Q.empty())&#123; //队列非空 int u = Q.front(); Q.pop(); //队头元素出队并置为u ArcNode *p = G.vertices[u].firstarc; while (p)&#123; int w = p-&gt;adjvex; if(!visited[w])&#123; cout&lt;&lt;w&lt;&lt;&quot; &quot;; //访问w visited[w]=true; //对w做已访问标记 Q.push(w); //顶点w入队列 &#125; p = p-&gt;nextarc; &#125; &#125;&#125; 广度优先搜索遍历的算法分析 无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点均需入队一次，在最坏的情况下，空间复杂度为O(∣V∣)O(|V|)O(∣V∣)。 采用邻接表存储方式时，每个顶点均需搜索一次(或入队一次)，故时间复杂度为O(∣V∣)O(|V|)O(∣V∣)，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为O(∣E∣)O(|E|)O(∣E∣)，算法总的时间复杂度为O(∣V∣+∣E∣)O(|V|+|E|)O(∣V∣+∣E∣)。采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为O(∣V∣)O(|V|)O(∣V∣)，故算法总的时间复杂度为O(∣V∣2)O(|V|^2)O(∣V∣2)。 图的应用 现实生活中的许多问题都可以转化为图来解决。例如， 如何以最小成本构建一个通信网络，如何计算地图中两地之间的最短路径，如何为复杂活动中各子任务的完成寻找一个较优的顺序等。 最小生成树 假设要在 n 个城市之间建立通信联络网，则连通 n 个城市只需要 n-1 条线路。这时，自然会考虑这样一个问题，如何在最节省经费的前提下建立这个通信网。在每两个城市之间都可设置一条线路，相应地都要付出一定的经济代价。n个城市之间，最多可能设置 n(n - 1)/2 条线路，那么，如何在这些可能的线路中选择 n-1 条，以使总的耗费最少呢？ 可以用连通网来表示n个城市，以及n个城市间可能设置的通信线路，其中网的顶点表示城市，边表示两城市之间的线路，赋予边的权值表示相应的代价。对于 n 个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。 最合理的通信网应该是代价之和最小的生成树。在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的最小代价生成树 (Minimum Cost Spanning Tree), 简称为最小生成树。 构造最小生成树有多种算法，其中多数算法利用了最小生成树的下列一种简称为 MST 的性质：假设 N= (V，E) 是一个连通网，U是顶点集 V 的一个非空子集。若(u，v)是一条具有最小权值（代价）的边，其中u∈Uu∈Uu∈U，v∈V−Uv∈V-Uv∈V−U，则必存在一棵包含边 (u，v) 的最小生成树。 普里姆 (Prim) 算法和克鲁斯卡尔 (Kruskal) 算法是两个利用 MST 性质构造最小生成树的算法。下面先介绍普里姆算法。 普里姆 (Prim) 算法 (1) 普里姆算法的构造过程 假设 N=(V,E) 是连通网， TE 是 N上最小生成树中边的集合。 U={u0}(u0∈V)，TE={}U=\\{u_0\\}(u_0∈V)，TE=\\{\\}U={u0​}(u0​∈V)，TE={}。 在所有 u∈Uu∈Uu∈U，v∈V−Uv∈V-Uv∈V−U 的边 (u,v)∈E(u,v)∈E(u,v)∈E 中找一条权值最小的边 (u0,v0)(u_0,v_0)(u0​,v0​) 并入集合 TE，同时v0v_0v0​并入U。 重复(2)，直至U=V为止。 此时 TE 中必有 n-1 条边， 则 T= (V, TE) 为 N 的最小生成树。 下图所示为一个连通网从 V1 开始构造最小生成树的例子。可以看出，普里姆算法逐步增加 U 中的顶点，可称为 “加点法”。 每次选择最小边时，可能存在多条同样权值的边可选，此时任选其一即可。 (2) 普里姆算法的实现 定义两个数组（isJoin[]用于存储已经加入的顶点，lowCost[] 用于存储加入顶点后更新的最短边路径）。 定义一个加入结点后更新最短路径的方法，即更新lowCost数组，每当加入一个结点后，就相当于开辟了一块新大陆，将开辟的新的大陆若有还未被访问而且权值小于原来的路径的结点更新。 初始化将初始顶点u加入最小生成树，然后将lowCost的值对应的更新为初始u加入的情况，随后循环n-1次，每次寻找未加入的顶点的最小的边，并更新lowCost数组。 123456789101112131415161718192021222324252627282930313233343536373839404142bool isJoin[MaxVertexNum]; //记录MST的顶点加入情况int lowCost[MaxVertexNum]; //记录当前最小边//返回最小未加入的边的下标int Min(AMGraph G)&#123; int index = 0; int min = MaxInt; for(int i=0;i&lt;G.vexnum;i++)&#123; if(!isJoin[i] &amp;&amp; lowCost[i]&lt;min)&#123; min = lowCost[i]; index = i; &#125; &#125; return index;&#125;//根据新加入的结点刷新最短边lowCost数组void FlushlowCostArr(AMGraph G,int v)&#123; for(int i=0;i&lt;G.vexnum;i++)&#123; int val = G.arcs[v][i]; if(!isJoin[i] &amp;&amp; val!=0 &amp;&amp; val!=MaxInt &amp;&amp; val&lt;lowCost[i])&#123; lowCost[i] = G.arcs[v][i]; &#125; &#125;&#125;void MiniSpanTree_Prim(AMGraph G,int u)&#123; for(int j=0;j&lt;G.vexnum;j++)&#123; isJoin[j] = false; //初始化顶点都未加入 lowCost[j] = G.arcs[u][j]; //最短边的情况，初始都为顶点u到各边的距离 &#125; isJoin[u] = true; //将初始顶点u加入集合 cout&lt;&lt;u&lt;&lt;&quot; &quot;; int k; //记录目前最小边的下标 for(int i=1;i&lt;G.vexnum;i++)&#123; //选择其余 n-1 个顶点，生成 n-1 条边(n=G.vexnum) k = Min(G); cout&lt;&lt;k&lt;&lt;&quot; &quot;; isJoin[k] = true; FlushlowCostArr(G,k); //新加入顶点k，刷新最短路径lowCost数组 &#125;&#125; (3) 普里姆算法分析 Prim算法的时间复杂度为O∣V2∣O|V^2|O∣V2∣，因为我们需要访问V个顶点，然后每次访问一个顶点时，需要两个for循环，一次更新数组，另一次找到最短的权值路径。所以O(V)∗O(2V)=O(V)∗O(V)=O(∣V2∣)O(V)*O(2V) = O(V) * O(V) = O(|V^2|)O(V)∗O(2V)=O(V)∗O(V)=O(∣V2∣)。与网中的边数无关，因此适用于求稠密网的最小生成树。 如上图6.15 构造最小生成树的执行过程中的 isJoin 数组和 lowCost 数组变化情况如下表所示。2147483647表示无穷，即没有路径。 序号 isJoin lowCost 第1趟 1 0 0 0 0 0 0 6 1 5 ∞ ∞ 第2趟 1 0 1 0 0 0 0 5 1 5 6 4 第3趟 1 0 1 0 0 1 0 5 1 2 6 4 第4趟 1 0 1 1 0 1 0 5 1 2 6 4 第5趟 1 1 1 1 0 1 0 5 1 2 3 4 第6趟 1 1 1 1 1 1 0 5 1 2 3 4 克鲁斯卡尔(Kruskal)算法 (1) 克鲁斯卡尔算法的构造过程 假设连通网N=(V,E)N=(V,E)N=(V,E), 将NNN中的边按权值从小到大的顺序排列。 初始状态为只有n个顶点而无边的非连通图 T=(V,{})T= (V, \\{\\})T=(V,{}), 图中每个顶点自成一个连通分量。 在EEE中选择权值最小的边， 若该边依附的顶点落在TTT中不同的连通分量上 （即不形成回路），则将此边加入到TTT中，否则舍去此边而选择下一条权值最小的边。 重复②，直至TTT中所有顶点都在同一连通分量上为止。 下图为Kruskal算法构造最小生成树的步骤，可以看出，克鲁斯卡尔算法逐步增加生成树的边，与普里姆算法相比，可称为“加边法”。与普里姆算法一样， 每次选择最小边时， 可能有多条同样权值的边可选， 可以任选其一。 (2) 克鲁斯卡尔算法的实现 在克鲁斯卡尔算法中，邻接表以及邻接矩阵都不适合用作存储，因为我们时刻需要知道哪一条是最短边。并且我们主要的问题分为两个：一是边的排序问题，二是如何判断被考察的两个顶点是否位于两个连通分量(是否有回路)？ 算法实现要引入的数据结构分析。 因为Kruskal算法是依次对图中的边进行操作，因此考虑用边集数组存储图中的边，为提高查找速度，将边集数组按边上的权排序。 123456789101112131415//-----图的边集数组存储表示－－－－－#define MaxVertexNum 100 //顶点数目的最大值#define MaxEdgeNum 100 //最大边数typedef char VertexType; //顶点的数据类型typedef struct&#123; int from,to; int weight;&#125;Edge;typedef struct&#123; VertexType vexs[MaxVertexNum]; //顶点表 Edge edges[MaxEdgeNum]; //存放边的数组 int vexnum,edgenum; //图的当前点数和边数&#125;EdgeGraph; 连通分量。Kruskal算法实质上是使生成树以一种随意的方式生长，初始时每个顶点构成一棵生成树，然后每生长一次就将两棵树合并，到最后合并成一棵树。因此，可以设置一个parent[n]，元素parent[i]表示顶点 i 的双亲结点，初始时，parent[i]=-1，表示顶点 i 没有双亲，即该结点是所在生成树的根结点；对于边（u,v）设vex1和vex2分别表示两个顶点所在树的根结点，如果vex1≠vex2，则顶点 u 和 v 必位于不同的连通分量，令parent[vex2]=vex1，实现将两棵树合并。 算法步骤如下： 将数组Edge中的元素按权值从小到大排序。 依次查看数组Edge中的边，循环执行以下操作： 依次从排好序的数组Edge中选出一条边(v1,v2)(v_1,v_2)(v1​,v2​)； 在parent[n]中分别查找顶点 v1v_1v1​ 和 v2v_2v2​ 的所在树的根结点表示为vex1和vex2，进行判断： 如果vex1≠vex2，表示所选的两个顶点分属不同的连通分量，输出此边，使parent[vex2]=vex1，将两个连通分量合并； 如果vex1=vex2，表示所选的两个顶点在一个连通分量中，舍去此边而选择下一条权值最小的边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//-----图的边集数组存储表示－－－－－#define MaxVertexNum 100 //顶点数目的最大值#define MaxEdgeNum 100 //最大边数typedef char VertexType; //顶点的数据类型typedef struct Edge&#123; int from,to; int weight; bool operator&lt;(const Edge &amp;edge)&#123;//重写小于运算符，用于排序 return this-&gt;weight &lt; edge.weight; &#125;&#125;Edge;typedef struct&#123; VertexType vexs[MaxVertexNum]; //顶点表 Edge edges[MaxEdgeNum]; //存放边的数组 int vexnum,edgenum; //图的当前点数和边数&#125;EdgeGraph;void CreateGraph(EdgeGraph &amp;G)&#123;//创建边集图 cin&gt;&gt;G.vexnum&gt;&gt;G.edgenum; for(int i=0;i&lt;G.vexnum;i++) cin&gt;&gt;G.vexs[i]; for(int i=0;i&lt;G.edgenum;i++) cin&gt;&gt;G.edges[i].from&gt;&gt;G.edges[i].to&gt;&gt;G.edges[i].weight;&#125;int FindRoot(int *parent,int f)&#123; while (parent[f]!=-1)&#123;//找到顶点f的根结点并返回 f = parent[f]; &#125; return f;&#125;void MiniSpanTree_Kruskal(EdgeGraph G)&#123; int parent[MaxVertexNum]; //用于存放最小生成树的顶点 for(int i=0;i&lt;G.vexnum;i++) parent[i] = -1; sort(G.edges,G.edges+G.edgenum); //内置的排序函数(重写比较运算符)，将数组Edge中的元素按权值从小到大排序 int v1,v2,vex1,vex2; for(int i=0;i&lt;G.edgenum;i++)&#123;//循环遍历边集合 //分别查找顶点 v1 和 v2 的所在树的根结点表示为vex1和vex2 v1 = G.edges[i].from; v2 = G.edges[i].to; vex1 = FindRoot(parent,v1); vex2 = FindRoot(parent,v2); if(vex1!=vex2)&#123;//两个顶点的根结点不同，表示在不同的连通分量中 cout&lt;&lt;G.edges[i].from&lt;&lt;&quot;--&quot;&lt;&lt;G.edges[i].to&lt;&lt;&quot;\\t&quot;&lt;&lt;G.edges[i].weight&lt;&lt;endl; parent[vex2] = vex1; //将两个连通分量合并 &#125; &#125;&#125; (3) 克鲁斯卡尔算法分析 假若以＂堆＂来存放网中的边进行堆排序，对于包含e条边的网，上述算法排序时间是O(elog2e)O(elog_2e)O(elog2​e)。在for循环中最耗时的操作是合并两个不同的连通分量，只要采取合适的数据结构，可以证明其执行时间为O(log2e)O(log_2e)O(log2​e)，因此整个for循环的执行时间是O(elog2e)O(elog_2e)O(elog2​e)，由此，克鲁斯卡尔算法的时间复杂度为O(elog2e)O(elog_2e)O(elog2​e)，与网中的边数有关，与普里姆算法相比，克鲁斯卡尔算法更适合于求稀疏网的最小生成树。 最短路径 当图是带权图时，把从一个顶点 v0v_0v0​ 到图中其余任意一个顶点 viv_ivi​ 的一条路径(可能不止一条）所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径称为最短路径。 求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的 Dijikstra（迪杰斯特拉）算法求解；二是求每对顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解。 Dijkstra算法求单源最短路径问题 迪杰斯特拉(Dijkstra)提出了一个按路径长度递增的次序产生最短路径的算法，称为迪杰斯特拉算法。 (1) 迪杰斯特拉算法的求解过程 对于网 N=(V,E), 将 N 中的顶点分成两组： 第一组 S: 已求出的最短路径的终点集合（初始时只包含源点v0v_0v0​)。 第二组 V-S: 尚未求出的最短路径的顶点集合（初始时为 V−{v0}V-\\{v_0\\}V−{v0​})。 算法将按各顶点与v0v_0v0​间最短路径长度递增的次序，逐个将集合 V−SV-SV−S 中的顶点加入到集合S中去。在这个过程中，总保持从v0v_0v0​到集合S中各顶点的路径长度始终不大于到集合 V−SV-SV−S 中各顶点的路径长度。 例如，下图所示的带权有向图G6G_6G6​中，展示了从v0v_0v0​到其余各顶点之间的最短路径。 (2) 迪杰斯特拉算法的实现 假设使用带权的邻接矩阵arcs来表示带权有向网G，算法的实现要引入以下辅助的数据结构。 数组名称 解释 final[] 标记各顶点是否已找到最短路径，true表示确定，false表示尚未确定。 dist[] 最短路径长度，其初值：如果从v0v_0v0​到viv_ivi​有弧，则dist[i]为弧上的权值；否则为∞。 path[] 最短路径上viv_ivi​的直接前驱顶点序号。其初值为：如果从v0v_0v0​到viv_ivi​有弧，则path[i]为v0v_0v0​；否则为-1。 求得顶点vkv_kvk​的最短路径后，将其加入到第一组顶点集S中。每当加入一个新的顶点到顶点集S，对第二组剩余的各个顶点而言，多了一个&quot;中转&quot;顶点，从而多了一个&quot;中转&quot;路径，所以要对第二组剩余的各个顶点的最短路径长度进行更新。 原来 v0v_0v0​ 到 viv_ivi​ 的最短路径长度为dist[i]，加进 vkv_kvk​ 之后，以 vkv_kvk​ 作为中间顶点的&quot;中转&quot;路径长度为：dist[k]+G.arcs[k][i]dist[k]+G.arcs[k][i]dist[k]+G.arcs[k][i]，若dist[k]+G.arcs[k][i]&lt;dist[i]dist[k]+G.arcs[k][i]&lt;dist[i]dist[k]+G.arcs[k][i]&lt;dist[i]，则用dist[k]+G.arcs[k][i]dist[k]+G.arcs[k][i]dist[k]+G.arcs[k][i]取代dist[i]。 更新后，再选择数组dist中值最小的顶点加入到第一组顶点集S中，如此进行下去，直到图中所有顶点都加入到第一组顶点集S中为止。 算法实现步骤如下： 初始化： 将源点v0v_0v0​加到final中，即final[0]=truefinal[0]=truefinal[0]=true； 将v0v_0v0​到各个终点的最短路径长度初始化为权值，即dist[i]=G.arcs[0][i]dist[i]=G.arcs[0][i]dist[i]=G.arcs[0][i]； 如果v0v_0v0​和顶点viv_ivi​之间有弧，则将viv_ivi​的前驱置为v0v_0v0​，即path[i]=0path[i]=0path[i]=0，否则path[i]=−1path[i]=-1path[i]=−1。 循环n-1次，执行以下操作： 选择下一条最短路径的终点vkv_kvk​，使得：dist[k]=Min{dist[i]∣vi∈V−S}dist[k]=Min\\{dist[i]|v_i∈V-S\\}dist[k]=Min{dist[i]∣vi​∈V−S}； 将vkv_kvk​加入到final中，即final[k]=truefinal[k]=truefinal[k]=true； 根据条件更新从v0v_0v0​出发到集合V-S上任一顶点的最短路径的长度，若条件dist[k]+G.arcs[k][i]&lt;dist[i]dist[k]+G.arcs[k][i]&lt;dist[i]dist[k]+G.arcs[k][i]&lt;dist[i]成立，则更新dist[i]=dist[k]+G.arcs[k][i]dist[i]=dist[k]+G.arcs[k][i]dist[i]=dist[k]+G.arcs[k][i]，同时更改viv_ivi​的前驱为vkv_kvk​；path[i]=k。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool final[MaxVertexNum]; //标记各顶点是否已找到最短路径int dist[MaxVertexNum]; //最短路径长度int path[MaxVertexNum]; //最短路径上vi的直接前驱顶点序号int FindMin(AMGraph G)&#123; //在dist中选择一条最短的且未确定最短路径的顶点的下标 int j = -1; int min = MaxInt; for(int i=0;i&lt;G.vexnum;i++)&#123; if(!final[i]&amp;&amp;dist[i]&lt;=min)&#123; // 用 = 保证至少有一个下标返回 min = dist[i]; j = i; &#125; &#125; return j;&#125;//根据新加入的结点刷新最短路径dist数组void FlushDist(AMGraph G,int k)&#123; for(int i=0;i&lt;G.vexnum;i++)&#123; //若vi未被加入S，并且经过vk到vi的路径小于原来dist[i]就进行更新 if(!final[i] &amp;&amp; dist[k] + G.arcs[k][i] &lt; dist[i])&#123; dist[i] = dist[k] + G.arcs[k][i]; path[i] = k; &#125; &#125;&#125;//用Dijkstra算法求网G的v0顶点到其余顶点的最短路径void ShortestPath_DIJ(AMGraph G,int v0)&#123; for(int i=0;i&lt;G.vexnum;i++)&#123; //初始化 final[i]=false; //S初始为空集 dist[i] = G.arcs[v0][i]; //将v0到各个终点的最短路径长度初始化为权值 if(G.arcs[v0][i]!=0 &amp;&amp; G.arcs[v0][i]!=MaxInt)&#123; //v0和vi有路径设置path[vi]=v0,否则设path[vi]=-1 path[i] = v0; &#125;else&#123; path[i] = -1; &#125; &#125; final[v0]=true; //初始化将v0加入到final中，表示到顶点v0已经找到最短路径 int k = 0; for(int i=1;i&lt;G.vexnum;i++)&#123; //循环n-1次，将剩下n-1各顶点确定最短路径 k = FindMin(G); //选择下一条最短路径的终点vk final[k] = true; //将vk加入到final中 FlushDist(G,k); //根据新加入的vk，刷新最短路径信息 &#125;&#125; (3) 迪杰斯特拉算法分析 利用上述算法，对有向网G6G_6G6​求解最短路径，给出算法中各参量的初始化结果和求解中的变化情况。 其中，有向网G6G_6G6​的邻接矩阵如下图所示。 对图中6个顶点依次初始化，得到结果如下表所示。 v=0 v=1 v=2 v=3 v=4 v=5 final 1 0 0 0 0 0 dist 0 ∞ 10 ∞ 30 100 path -1 -1 0 -1 0 0 求解过程中，各参量的变化如下表所示。 终点 i=1 i=2 i=3 i=4 i=5 v1 ∞ ∞ ∞ ∞ ∞ v2 10(v0,v2) 10(v0,v2) 10(v0,v2) 10(v0,v2) 10(v0,v2) v3 60(v0,v2,v3) 50(v0,v4,v3) 50(v0,v4,v3) 50(v0,v4,v3) 50(v0,v4,v3) v4 30(v0,v4) 30(v0,v4) 30(v0,v4) 30(v0,v4) 30(v0,v4) v5 100(v0,v5) 90(v0,v4,v5) 60(v0,v4,v3,v5) 60(v0,v4,v3,v5) 60(v0,v4,v3,v5) path path[3]=2 path[3]=4path[5]=4 path[5]=3 final final[2]=true {v0,v2} final[4]=true{v0,v2,v4} final[3]=true{v0,v2,v4,v3} final[5]=true{v0,v2,v4,v3,v5} final[1]=true{v0,v2,v4,v3,v5,v1} 显然，Dijkstra算法也是基于贪心策略的。使用邻接矩阵表示时，时间复杂度为O(∣V∣2)O(|V|^2)O(∣V∣2)。使用带权的邻接表表示时，虽然修改dist[]的时间可以减少，但由于在dist[ ]中选择最小分量的时间不变，时间复杂度仍为O(∣V∣2)O(|V|^2)O(∣V∣2)。 值得注意的是，边上带有负权值时，Dijkstra算法并不适用。若允许边上带有负权值，则在与S(已求得最短路径的顶点集，归入S内的结点的最短路径不再变更）内某点(记为a）以负边相连的点（记为b）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于a原先确定的最短路径长度，而此时a在 Dijkstra算法下是无法更新的。例如，对于下图所示的带权有向图，利用Dijkstra算法不一定能得到正确的结果。 Floyd 算法求各顶点之间最短路径问题 求解每一对顶点之间的最短路径有两种方法：其一是分别以图中的每个顶点为源点共调用n次迪杰斯特拉算法；其二是采用下面介绍的弗洛伊德(Floyd)算法。 两种算法的时间复杂度均为O(n3)O(n^3)O(n3)，但后者形式上较简单。 弗洛伊德算法仍然使用带权的邻接矩阵 arcs 来表示有向网G，求从顶点 viv_ivi​ 到 vjv_jvj​ 的最短路径。 (1) 弗鲁伊德算法的核心思想 Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点 i 到点 j 的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）。 从任意结点 i 到任意结点 j 的最短路径不外乎两种可能，一是直接从 i 到 j，二是从 i 经过若干个结点 k 到 j。所以，我们假设Dist(i,j)为结点 i 到结点 j 的最短路径的距离，对于每一个结点k，我们检查Dist(i,k) + Dist(k,j) &lt; Dist(i,j)是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，我们便设置Dist(i,j) = Dist(i,k) + Dist(k,j)，这样一来，当我们遍历完所有结点k，Dist(i,j)中记录的便是 i 到 j 的最短路径的距离。 换句话说，弗鲁伊德就是将N个顶点分别作为中转顶点进行更新的算法。 (2) 弗鲁伊德算法的实现 算法的实现要引入以下辅助的数据结构。 二维数组 解释 Path[i][j]Path[i][j]Path[i][j] 表示顶点 i 到顶点 j 经过了path[i][j]path[i][j]path[i][j]这个顶点。 D[i][j]D[i][j]D[i][j] 表示顶点 i (第i个顶点)到顶点 j (第j个顶点)的最短距离。 算法实现步骤如下。 假设图G中顶点个数为N，则需要对矩阵D和矩阵Path进行N次更新。初始时，矩阵D[i][j]D[i][j]D[i][j]记录的为顶点 i 到顶点 j 的权值(复制一份邻接矩阵即可)；如果 i 和 j 不相邻，则D[i][j]=∞D[i][j]=∞D[i][j]=∞，矩阵Path的值若i到j之间有弧，则将j的前驱置为i，否则为 -1。 接下来开始，对矩阵D进行N次更新。第1次更新时，如果D[i][j]D[i][j]D[i][j] &gt; D[i][0]D[i][0]D[i][0]+D[0][j]D[0][j]D[0][j] (D[i][0]D[i][0]D[i][0]+D[0][j]D[0][j]D[0][j]表示 i 与 j 之间经过v0v_0v0​顶点的距离)，则更新D[i][j]D[i][j]D[i][j]为D[i][0]D[i][0]D[i][0]+D[0][j]D[0][j]D[0][j]，更新Path[i][j]=0Path[i][j]=0Path[i][j]=0（表示从顶点i 到顶点 j 需要经过v0v_0v0​中转）。同理，第k次更新时，如果D[i][j]&gt;D[i][k]+D[k][j]D[i][j] &gt; D[i][k]+D[k][j]D[i][j]&gt;D[i][k]+D[k][j]，则更新D[i][j]D[i][j]D[i][j]为D[i][k]+D[k][j]D[i][k]+D[k][j]D[i][k]+D[k][j]，Path[i][j]=kPath[i][j]=kPath[i][j]=k。更新N次之后，即完成所有顶点的最短路径的更新。 12345678910111213141516171819202122232425int Path[MaxVertexNum][MaxVertexNum]; //表示顶点 i 到顶点 j 经过了path[i][j]这个顶点。int D[MaxVertexNum][MaxVertexNum]; //记录各个顶点的最短距离//用Floyd算法求有向网G中各对顶点i和j之间的最短路径void ShortestPath_Floyd(AMGraph G)&#123; for(int i=0;i&lt;G.vexnum;i++)&#123;//初始化 for(int j=0;j&lt;G.vexnum;j++)&#123; D[i][j] = G.arcs[i][j]; //如果 i 和 j 之间有弧，则将j的前驱置为i if(D[i][j]&lt;MaxInt &amp;&amp; D[i][j]!=0) Path[i][j]=i; else Path[i][j] = -1; &#125; &#125; for(int k=0;k&lt;G.vexnum;k++)&#123; //n个顶点分别作为中转结点进行更新 for(int i=0;i&lt;G.vexnum;i++)&#123; for(int j=0;j&lt;G.vexnum;j++)&#123; if(D[i][k]+D[k][j]&lt;D[i][j])&#123; D[i][j] = D[i][k]+D[k][j]; //更新D[i] [j] Path[i][j] = Path[k][j]; //更改j的前驱为K &#125; &#125; &#125; &#125;&#125; (3) 弗鲁伊德算法分析 利用上述算法，对下图所示的有向网G7G_7G7​求解最短路径，给出每一对顶点之间的最短路径及其路径长度在求解过程中的变化。 每一对顶点 i 和 j 之间的最短路径 Path[i][j]Path[i][j]Path[i][j] 以及其路径长度 D[i][j]D[i][j]D[i][j] 在求解过程中的变化如下表所示。 以Path(3)为例，对最短路径的读法加以说明。从D(3)知，顶点1到顶点2的最短路径长度为 D[1][2]=8D[1][2]=8D[1][2]=8，其最短路径看Path[1][2]=3Path[1][2] = 3Path[1][2]=3, 表明顶点2的前驱是顶点3；再看Path[1][3]=1Path[1][3]= 1Path[1][3]=1，表明顶点3的前驱是顶点1。所以从顶点1到顶点2的最短路径为&lt;1,3&gt;,&lt;3,2&gt;&lt;1,3&gt;,&lt;3,2&gt;&lt;1,3&gt;,&lt;3,2&gt;。 Floyd算法的时间复杂度为O(∣V∣3)O(|V|^3)O(∣V∣3)。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。 Floyd算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。 有向无环图 有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。 有向无环图是描述含有公共子式的表达式的有效工具。例如表达式((a+b)∗(b∗(c+d))+(c+d)∗e)∗((c+d)∗e)((a+b)*(b*(c+d))+(c+d)*e)*((c+d)*e)((a+b)∗(b∗(c+d))+(c+d)∗e)∗((c+d)∗e)。 可以用二叉树来表示，如下图6.20所示。仔细观察该表达式，可发现有一些相同的子表达式(c+d)(c+d)(c+d)和(c+d)∗e(c +d)*e(c+d)∗e，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间，下图6.21所示为该表达式的有向无环图表示。 拓扑排序 AOV-网 AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边&lt;Vi，Vj&gt;&lt;V_i，V_j&gt;&lt;Vi​，Vj​&gt;表示活动 ViV_iVi​ 必须先于活动VjV_jVj​ 进行的这样一种关系，则将这种有向图称为顶点表示活动的网（Activity On Vertex Network），记为 AOV网。在AOV网中，活动 ViV_iVi​ 是活动 VjV_jVj​ 的直接前驱，活动 VjV_jVj​ 是活动 ViV_iVi​ 的直接后继，这种前驱和后继关系具有传递性，且任何活动 ViV_iVi​ 不能以它自己作为自己的前驱或后继。 在AOV-网中，不应该出现有向环，因为存在环意味着某项活动应以自己为先决条件。显然，这是荒谬的。若设计出这样的流程图，工程便无法进行。而对程序的数据流图来说，则表明存在一个死循环。因此，对给定的 AOV-网应首先判定网中是否存在环。检测的办法是对有向图的顶点进行拓扑排序，若网中所有顶点都在它的拓扑有序序列中，则该AOV-网中必定不存在环。 所谓拓扑排序就是将AOV-网中所有顶点排成一个线性序列，该序列满足：若在AOV-网中由顶点 viv_ivi​ 到顶点 vjv_jvj​ 有一条路径，则在该线性序列中的顶点 viv_ivi​ 必定在顶点 vjv_jvj​ 之前。 例如，我们以学生所学课程进行举例。 以上的课程中，有一些课程必须在学完作为其基础的先修课程才能开始，所以我们可以使用有向无环图DAG进行如下表示。 对于上面的有向图，有如下两个拓扑有序序列（当然，对此图也可构造出其他的拓扑有序序列）： C1,C2,C3,C4,C5,C7,C9,C10,C11,C6,C12,C8C_1,C_2,C_3,C_4,C_5,C_7,C_9,C_{10},C_{11},C_6,C_{12},C_8C1​,C2​,C3​,C4​,C5​,C7​,C9​,C10​,C11​,C6​,C12​,C8​ 和 C9,C10,C11,C6,C1,C12,C4,C2,C3,C5,C7,C8C_9,C_{10},C_{11},C_6,C_1,C_{12},C_4,C_2,C_3,C_5,C_7,C_8C9​,C10​,C11​,C6​,C1​,C12​,C4​,C2​,C3​,C5​,C7​,C8​ 学生必须按照拓扑有序的顺序来安排学习计划，这样才能保证学习任一门课程时其先修课程已经学过。那么如何进行拓扑排序呢？ 拓扑排序的过程 在有向图中选一个无前驱的顶点且输出它。 从图中删除该顶点和所有以它为尾的弧。 重复①和②直到不存在无前驱的顶点为止。 若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环， 否则输出的顶点序列即为一个拓扑序列。 下图所示为拓扑排序过程的示例。每一轮选择一个入度为0的顶点并输出，然后删除该顶点和所有以它为起点的有向边，最后得到拓扑排序的结果为{1,2,4,3,5}。 拓扑排序的实现 针对上述的拓扑排序过程，可采用邻接表做有向图的存储结构。 算法的实现要引入以下辅助的数据结构。 引入的数据结构 解释 一维数组 indegree[i] 存放各顶点入度，没有前驱的顶点就是入度为零的顶点。删除顶点及以它为尾的弧的操作，可不必真正对图的存储结构进行改变，可用弧头顶点的入度减1的办法来实现。 栈 S 暂存所有入度为零的顶点，这样可以避免重复扫描数组indegree检测入度为0的顶点，提高算法的效率。 一维数组 topo[i] 记录拓扑序列的顶点序号。 算法实现步骤如下。 求出各顶点的入度存入数组 indegree[i] 中， 并将入度为 0 的顶点入栈。 只要栈不空， 则重复以下操作： 将栈顶顶点 viv_ivi​ 出栈并保存在拓扑序列数组 topo 中； 对顶点 viv_ivi​ 的每个邻接点 vkv_kvk​ 的入度减1，如果 vkv_kvk​ 的入度变为0，则将 vkv_kvk​ 入栈。 如果输出顶点个数少于AOV-网的顶点个数，则网中存在有向环，无法进行拓扑排序， 否则拓扑排序成功。 123456789101112131415161718192021222324252627282930313233int indegree[MaxVertexNum]; //记录各顶点入度stack&lt;int&gt; S; //暂存所有入度为零的顶点void FindInDegree(ALGraph G)&#123; //求出各顶点的入度存入数组 indegree中 for(int i=0;i&lt;G.vexnum;i++)&#123; ArcNode *p = G.vertices[i].firstarc; while (p)&#123; indegree[p-&gt;adjvex]++; //遍历到的边，使弧头结点入度加1 p=p-&gt;nextarc; &#125; &#125;&#125;bool TopologicalSort(ALGraph G,int topo[])&#123; FindInDegree(G); //求出各顶点的入度存入数组 indegree[i] 中 for(int i=0;i&lt;G.vexnum;i++) if(!indegree[i]) S.push(i); //将入度为 0 的顶点入栈 int m = 0; //记录输出顶点个数 while (!S.empty())&#123; int v = S.top(); S.pop(); //将栈顶顶点v出栈 topo[m++] = v; //将顶点v保存在拓扑序列数组topo中，并对输出顶点计数 ArcNode *p = G.vertices[v].firstarc; //p指向v的第一个邻接点 while (p)&#123; indegree[p-&gt;adjvex]--; //v的每个邻接点的入度减1 if(!indegree[p-&gt;adjvex]) S.push(p-&gt;adjvex); //若入度减为0, 则入栈 p = p-&gt;nextarc; //p指向顶点v下一个邻接结点 &#125; &#125; if(m&lt;G.vexnum) return false; //该有向图有回路 else return true;&#125; 对有 n 个顶点和 e 条边的有向图而言，建立求各顶点入度的时间复杂度为 O(e)；建立零入度顶点栈的时间复杂度为O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减1的操作在循环中总共执行 e 次，所以，总的时间复杂度为O(n + e)。 此外，当有向图中无环的时候，还可以利用深度优先搜索遍历的方法进行拓扑排序。在下面的逆拓扑排序中会详细说明。 逆拓扑排序 若AOV网中考察各顶点的出度并以下列步骤进行排序，则将这种排序称为逆拓扑排序，输出的结果称为逆拓扑有序序列。 从AOV网中选择一个没有后继（出度为0）的顶点并输出。 从网中删除该顶点和所有以它为终点的有向边。 重复①和②直到当前的AOV网为空。 我们可以使用深度优先搜索遍历的方法进行逆拓扑排序，由于DAG图中无环，当由图中某顶点出发进行深度优先搜索遍历时，最先退出算法的顶点即为出度为0的顶点，它是拓扑有序序列中的最后一个顶点。因此，按照DFS算法的先后次序记录下的顶点序列即为逆向的拓扑有序序列。 算法实现步骤如下。 只要某结点还有未访问的邻接结点，就会继续向下递归进行DFS，不断填充递归栈。 没有未访问的邻接结点时，退栈，只要退栈时将结点输出即可。 利用一个flag数组记录系统栈中各个结点的情况，若一个邻接点在本轮递归中没有被访问，说明没有出现环路，继续执行代码。若邻接点被访问过了，且该邻接点还在系统栈中，说明存在环路，则退出程序。 123456789101112131415161718192021222324252627bool visited[MaxVertexNum]; //访问标记数组,初始值都为falsebool flag[MaxVertexNum]; //记录各顶点是否还在递归系统栈中void InverseTopo(AMGraph G,int v)&#123; //从顶点v出发，深度优先遍历图G visited[v] = true; //设已访问标记 flag[v]=true; //标记顶点v进入系统栈 for (int w=0;w&lt;G.vexnum;w++)&#123; //遍历顶点v的所有邻接点w if (G.arcs[v][w]!=0 &amp;&amp; G.arcs[v][w]!=MaxInt &amp;&amp; !visited[w])&#123; InverseTopo(G,w); //对 v 的尚未访问的邻接顶点 w 递归调用 InverseTopo &#125;else if(G.arcs[v][w]!=0 &amp;&amp; G.arcs[v][w]!=MaxInt &amp;&amp; visited[w])&#123; //若顶点v的邻接点w已经被访问过，并且仍在递归工作栈中，表示存在环路 if(flag[w])&#123; cout&lt;&lt;&quot;Presence loop&quot;; exit(0); //退出程序 &#125; &#125; &#125; cout &lt;&lt; v &lt;&lt; &quot; &quot;; //访问顶点v，将出度为0的顶点输出，实现逆拓扑排序 flag[v]=false; //标记顶点v退出系统栈&#125;void DFSTraverse(AMGraph G)&#123;//对于非连通图G做深度优先遍历 for(int v=0;v&lt;G.vexnum;v++) visited[v] = false; //访问标志数组初始化 for(int v=0;v&lt;G.vexnum;v++)&#123; if(!visited[v]) InverseTopo(G,v); //对尚未访问的顶点调用DFS &#125;&#125; 由以上算法我们可以看出，在DFS算法的基础上，若不考虑判断回路的代码，实际上我们只修改了一行代码的位置便将DFS算法转换为了逆拓扑排序算法。将逆拓扑有序序列倒序进行输出便为拓扑排序的结果。 关键路径 AOE-网 与AOV-网相对应的是AOE-网 (Activity On Edge)，即以边表示活动的网。AOE-网是一个带权的有向无环图，其中，顶点表示事件，弧表示活动，权表示活动持续的时间。通常，AOE-网可用来估算工程的完成时间。 例如，下图所示为一个有11项活动的AOE-网。其中有9个事件 v0,v1,...,v8v_0,v_1,...,v_8v0​,v1​,...,v8​，每个事件表示在它之前的活动已经完成，在它之后的活动可以开始。例如，v0v_0v0​表示整个工程开始，v8v_8v8​表示整个工程结束，v4v_4v4​表示 a4a_4a4​ 和 a5a_5a5​ 已经完成， a7a_7a7​ 和 a8a_8a8​ 可以开始了。与每个活动相联系的数是执行该活动所需的时间，比如，活动 a1a_1a1​ 需要6天，a2a_2a2​ 需要4天等。 由于整个工程只有一个开始点和一个完成点，故在正常的情况（无环）下，网中只有一个入度为零的点，称作源点，也只有一个出度为零的点，称作汇点。在AOE-网中，一条路径各弧上的权值之和称为该路径的带权路径长度（后面简称路径长度）。要估算整项工程完成的最短时间，就是要找一条从源点到 汇点的带权路径长度最长的路径， 称为关键路径（Critical Path）。关键路径上的活动叫做关键活动，这些活动是影响工程进度的关键，它们的提前或拖延将使整个工程提前或拖延。 例如，在上图6.28中，v0v_0v0​ 是源点，v8v_8v8​ 是汇点，关键路径有两条：(v0,v1,v4,v6,v8)(v_0,v_1,v_4,v_6,v_8)(v0​,v1​,v4​,v6​,v8​)或(v0,v1,v4,v7,v8)(v_0,v_1,v_4,v_7,v_8)(v0​,v1​,v4​,v7​,v8​)，长度均为18。关键活动为(a1,a4,a7,a10)(a_1,a_4,a_7,a_{10})(a1​,a4​,a7​,a10​)或(a1,a4,a8,a11)(a_1,a_4,a_8,a_{11})(a1​,a4​,a8​,a11​)。比如，关键活动 a1a_1a1​ 需要6天完成，如果 a1a_1a1​ 提前1天，整个工程也可以提前1天完成。所以不论是估算工期，还是研究如何加快工程进度，主要问题就在于要找到 AOE-网的关键路径。 如何确定关键路径，首先我们需要了解4个描述量。 描述量 解释 事件 viv_ivi​ 的最早发生时间 ve(i) 进入事件 viv_ivi​ 的每一活动都结束，viv_ivi​才可发生，所以ve(i)是从源点到viv_ivi​的最长路径长度。求ve(i)的值，可根据拓扑顺序从源点开始向汇点递推。通常将工程的开始顶点事件 v0v_0v0​ 的最早发生时间定义为0，即ve(0)=0。ve(i)=Max{ve(k)+wk,i}ve(i)=Max\\{ve(k)+w_{k,i}\\}ve(i)=Max{ve(k)+wk,i​}。其中wk,iw_{k,i}wk,i​是弧&lt;vk,vi&gt;&lt;v_k,v_i&gt;&lt;vk​,vi​&gt;的权值，即对应活动&lt;vk,vi&gt;&lt;v_k,v_i&gt;&lt;vk​,vi​&gt;的持续时间。 事件 viv_ivi​ 的最迟发生时间 vl(i) 事件 viv_ivi​ 的发生不得延误 viv_ivi​ 的每一后继事件的最迟发生时间。为了不拖延工期，viv_ivi​ 的最迟发生时间不得迟于其后继事件 vkv_kvk​ 的最迟发生时间减去活动&lt;vi,vk&gt;&lt;v_i,v_k&gt;&lt;vi​,vk​&gt;的持续时间。求出ve(i)后，可根据逆拓扑顺序从汇点开始向源点递推，求出vl(i)。先让vl(汇点)=ve(汇点)vl(汇点)=ve(汇点)vl(汇点)=ve(汇点)，随后vl(i)=Min{vl(k)−wi,k}vl(i)=Min\\{vl(k)-w_{i,k}\\}vl(i)=Min{vl(k)−wi,k​}。其中wi,kw_{i,k}wi,k​是弧&lt;vi,vk&gt;&lt;v_i,v_k&gt;&lt;vi​,vk​&gt;的权值。 活动 ai=&lt;vj,vk&gt;a_i=&lt;v_j,v_k&gt;ai​=&lt;vj​,vk​&gt; 的最早开始时间 e(i) 只有事件 vjv_jvj​ 发生了，活动 aia_iai​ 才能开始。所以，活动 aia_iai​ 的最早开始时间等于事件 vjv_jvj​ 的最早发生时间 ve(j)，即 e(i)=ve(j)。 活动 ai=&lt;vj,vk&gt;a_i=&lt;v_j,v_k&gt;ai​=&lt;vj​,vk​&gt; 的最晚开始时间 l(i) 活动 aia_iai​ 的开始时间需保证不延误事件 vkv_kvk​ 的最迟发生时间。所以活动 aia_iai​ 的最晚开始时间 l(i) 等于事件 vkv_kvk​ 的最迟发生时间vl(k)减去活动 aia_iai​ 的持续时间 wj,kw_{j,k}wj,k​，即：l(i)=vl(k)−wj,kl(i)=vl(k)-w_{j,k}l(i)=vl(k)−wj,k​ 对于关键活动而言，e(i)=l(i)。对于非关键活动，l(i)-e(i)的值是该工程的期限余量，在此范围内的适度延误不会影响整个工程的工期。 一个活动 aia_iai​ 的最迟开始时间 l(i) 和其最早开始时间 e(i) 的差值 l(i)-e(i) 是该活动完成的时间余量。它是在不增加完成整个工程所需的总时间的情况下，活动 aia_iai​ 可以拖延的时间。当一活动的时间余量为零时，说明该活动必须如期完成，否则就会拖延整个工程的进度。所以称 l(i) - e(i) = 0，即 l(i)=e(i) 时的活动 aia_iai​ 是关键活动。 关键路径求解的过程 对图中顶点进行排序，在排序过程中按拓扑序列求出每个事件的最早发生时间ve(i)。 按逆拓扑序列求出每个事件的最迟发生时间vl(i)。 求出每个活动 aia_iai​ 的最早开始时间 e(i)。 求出每个活动 aia_iai​ 的最晚开始时间 l(i)。 找出 e(i)=l(i) 的活动 aia_iai​，即为关键活动。由关键活动形成的由源点到汇点的每一条路径就是关键路径，关键路径有可能不止一条。 例如，我们以上图6.28所示的AOE-网，给出计算关键路径的过程。 求解过程 具体步骤 计算各顶点事件 viv_ivi​ 的最早发生时间 ve(i) ve(0)=0ve(0)=0ve(0)=0 ve(1)=Max{ve(0)+w0,1}=6ve(1)=Max\\{ve(0)+w_{0,1}\\}=6ve(1)=Max{ve(0)+w0,1​}=6 ve(2)=Max{ve(0)+w0,2}=4ve(2)=Max\\{ve(0)+w_{0,2}\\}=4ve(2)=Max{ve(0)+w0,2​}=4 ve(3)=Max{ve(0)+w0,3}=5ve(3)=Max\\{ve(0)+w_{0,3}\\}=5ve(3)=Max{ve(0)+w0,3​}=5 ve(4)=Max{ve(1)+w1,4,ve(2)+w2,4}=7ve(4)=Max\\{ve(1)+w_{1,4},ve(2)+w_{2,4}\\}=7ve(4)=Max{ve(1)+w1,4​,ve(2)+w2,4​}=7 ve(5)=Max{ve(3)+w3,5}=7ve(5)=Max\\{ve(3)+w_{3,5}\\}=7ve(5)=Max{ve(3)+w3,5​}=7 ve(6)=Max{ve(4)+w4,6}=16ve(6)=Max\\{ve(4)+w_{4,6}\\}=16ve(6)=Max{ve(4)+w4,6​}=16 ve(7)=Max{ve(4)+w4,7,ve(5)+w5,7}=14ve(7)=Max\\{ve(4)+w_{4,7},ve(5)+w_{5,7}\\}=14ve(7)=Max{ve(4)+w4,7​,ve(5)+w5,7​}=14 ve(8)=Max{ve(6)+w6,8,ve(7)+w7,8}=18ve(8)=Max\\{ve(6)+w_{6,8},ve(7)+w_{7,8}\\}=18ve(8)=Max{ve(6)+w6,8​,ve(7)+w7,8​}=18 计算各顶点事件 viv_ivi​ 的最迟发生时间 vl(i) vl(8)=ve(8)=18vl(8)=ve(8)=18vl(8)=ve(8)=18vl(7)=Min{vl(8)−w7,8}=14vl(7)=Min\\{vl(8)-w_{7,8}\\}=14vl(7)=Min{vl(8)−w7,8​}=14vl(6)=Min{vl(8)−w6,8}=16vl(6)=Min\\{vl(8)-w_{6,8}\\}=16vl(6)=Min{vl(8)−w6,8​}=16vl(5)=Min{vl(7)−w5,7}=10vl(5)=Min\\{vl(7)-w_{5,7}\\}=10vl(5)=Min{vl(7)−w5,7​}=10vl(4)=Min{vl(6)−w4,6,vl(7)−w4,7}=7vl(4)=Min\\{vl(6)-w_{4,6},vl(7)-w_{4,7}\\}=7vl(4)=Min{vl(6)−w4,6​,vl(7)−w4,7​}=7vl(3)=Min{vl(5)−w3,5}=8vl(3)=Min\\{vl(5)-w_{3,5}\\}=8vl(3)=Min{vl(5)−w3,5​}=8vl(2)=Min{vl(4)−w2,4}=6vl(2)=Min\\{vl(4)-w_{2,4}\\}=6vl(2)=Min{vl(4)−w2,4​}=6vl(1)=Min{vl(4)−w1,4}=6vl(1)=Min\\{vl(4)-w_{1,4}\\}=6vl(1)=Min{vl(4)−w1,4​}=6vl(0)=Min{vl(1)−w0,1,vl(2)−w0,2,vl(3)−w0,3}=0vl(0)=Min\\{vl(1)-w_{0,1},vl(2)-w_{0,2},vl(3)-w_{0,3}\\}=0vl(0)=Min{vl(1)−w0,1​,vl(2)−w0,2​,vl(3)−w0,3​}=0 计算各活动 aia_iai​ 的最早开始时间 e(i) e(a1)=ve(0)=0e(a_1)=ve(0)=0e(a1​)=ve(0)=0e(a2)=ve(0)=0e(a_2)=ve(0)=0e(a2​)=ve(0)=0e(a3)=ve(0)=0e(a_3)=ve(0)=0e(a3​)=ve(0)=0e(a4)=ve(1)=6e(a_4)=ve(1)=6e(a4​)=ve(1)=6e(a5)=ve(2)=4e(a_5)=ve(2)=4e(a5​)=ve(2)=4e(a6)=ve(3)=5e(a_6)=ve(3)=5e(a6​)=ve(3)=5e(a7)=ve(4)=7e(a_7)=ve(4)=7e(a7​)=ve(4)=7e(a8)=ve(4)=7e(a_8)=ve(4)=7e(a8​)=ve(4)=7e(a9)=ve(5)=7e(a_9)=ve(5)=7e(a9​)=ve(5)=7e(a10)=ve(6)=16e(a_{10})=ve(6)=16e(a10​)=ve(6)=16e(a11)=ve(7)=14e(a_{11})=ve(7)=14e(a11​)=ve(7)=14 计算各活动 aia_iai​ 的最迟开始时间 l(i) l(a11)=vl(8)−w7,8=14l(a_{11})=vl(8)-w_{7,8}=14l(a11​)=vl(8)−w7,8​=14l(a10)=vl(8)−w6,8=16l(a_{10})=vl(8)-w_{6,8}=16l(a10​)=vl(8)−w6,8​=16l(a9)=vl(7)−w5,7=10l(a_9)=vl(7)-w_{5,7}=10l(a9​)=vl(7)−w5,7​=10l(a8)=vl(7)−w4,7=7l(a_8)=vl(7)-w_{4,7}=7l(a8​)=vl(7)−w4,7​=7l(a7)=vl(6)−w4,6=7l(a_7)=vl(6)-w_{4,6}=7l(a7​)=vl(6)−w4,6​=7l(a6)=vl(5)−w3,5=8l(a_6)=vl(5)-w_{3,5}=8l(a6​)=vl(5)−w3,5​=8l(a5)=vl(4)−w2,4=6l(a_5)=vl(4)-w_{2,4}=6l(a5​)=vl(4)−w2,4​=6l(a4)=vl(4)−w1,4=6l(a_4)=vl(4)-w_{1,4}=6l(a4​)=vl(4)−w1,4​=6l(a3)=vl(3)−w0,3=3l(a_3)=vl(3)-w_{0,3}=3l(a3​)=vl(3)−w0,3​=3l(a2)=vl(2)−w0,2=2l(a_2)=vl(2)-w_{0,2}=2l(a2​)=vl(2)−w0,2​=2l(a1)=vl(1)−w0,1=0l(a_1)=vl(1)-w_{0,1}=0l(a1​)=vl(1)−w0,1​=0 关键路径算法的实现 由于每个事件的最早发生时间 ve(i) 和最迟发生时间 vl(i) 要在拓扑序列的基础上进行计算，所以关键路径算法的实现要基于拓扑排序算法，我们仍采用邻接表做有向图的存储结构。 算法的实现要引入以下辅助的数据结构。 引入的数据结构 解释 一维数组 ve[i] 事件 viv_ivi​ 的最早发生时间 一维数组 vl[i] 事件 viv_ivi​ 的最迟发生时间 一维数组 topo[i] 记录拓扑序列的顶点序号 关键路径算法实现的步骤如下。 调用拓扑排序算法，使拓扑序列保存在 topo 中。 将每个事件的最早发生时间 ve[i] 初始化为0，ve[i] = 0。 根据 topo 中的值，按从前向后的拓扑次序，依次求每个事件的最早发生时间，循环n次，执行以下操作： 取得拓扑序列中的顶点序号 k，k = topo[i]； 用指针 p 依次指向 k 的每个邻接顶点，取得每个邻接顶点的序号 j=p-&gt;adjvex，依次更新顶点 j 的最早发生时间 ve[j]。if(ve[j]&lt;ve[k]+p-&gt;weight) ve[j]=ve[k]+p-&gt;weight； 将每个事件的最迟发生时间 vl[i] 初始化为汇点的最早发生时间，vl[i] = ve[n-1]。 根据 topo 中的值，按从后向前的逆拓扑次序，依次求每个事件的最迟发生时间，循环n次，执行以下操作： 取得拓扑序列中的顶点序号 k，k = topo[i]； 用指针 p 依次指向 k 的每个邻接顶点，取得每个邻接顶点的序号 j=p-&gt;adjvex，依次根据 k 的邻接点，更新 k 的最迟发生时间 vl[k]。if(vl[k]&gt;vl[j]-p-&gt;weight) vl[k]=vl[j]-p-&gt;weight； 判断某一活动是否为关键活动，循环n次，执行以下操作：对于每个顶点 i，用指针 p 依次指向 i 的每个邻接顶点，取得每个邻接顶点的序号 j = p-&gt;adjvex，分别计算活动&lt;vi,vj&gt;&lt;v_i,v_j&gt;&lt;vi​,vj​&gt;的最早和最迟开始时间 e 和 l，e = ve[i]；l=vl[j]-p-&gt;weight；如果 e 和 l 相等，则活动&lt;vi,vj&gt;&lt;v_i,v_j&gt;&lt;vi​,vj​&gt;为关键活动，输出弧&lt;vi,vj&gt;&lt;v_i,v_j&gt;&lt;vi​,vj​&gt;。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int ve[MaxVertexNum]; //事件vi的最早发生时间int vl[MaxVertexNum]; //事件vi的最迟发生时间bool CriticalPath(ALGraph G)&#123;//G为邻接表存储的有向网，输出G的各项关键活动 int topo[MaxVertexNum]; //调用拓扑排序算法，使拓扑序列保存在topo中，若调用失败，则存在有向环，返回false if(!TopologicalSort(G,topo)) return false; for(int i=0;i&lt;G.vexnum;i++) //给每个事件的最早发生时间置初值0 ve[i]=0; /* ---------------- 按拓扑次序求每个事件的最早发生时间 ---------------- */ for(int i=0;i&lt;G.vexnum;i++)&#123; int k = topo[i]; //取得拓扑序列中的顶点序号k ArcNode *p = G.vertices[k].firstarc; //p指向k的第一个邻接顶点 while (p)&#123; int j = p-&gt;adjvex; //j为邻接顶点的序号 if(ve[k]+p-&gt;info&gt;ve[j]) //更新顶点j的最早发生时间ve[j] ve[j]=ve[k]+p-&gt;info; p = p-&gt;nextarc; //p指向k的下一个邻接顶点 &#125; &#125; for(int i=0;i&lt;G.vexnum;i++) //给每个事件的最迟发生时间置初值ve[汇点] vl[i]=ve[G.vexnum-1]; /* ---------------- 按逆拓扑次序求每个事件的最迟发生时间 ---------------- */ for(int i=G.vexnum-1;i&gt;=0;i--)&#123; int k = topo[i]; //取得拓扑序列中的顶点序号K ArcNode *p = G.vertices[k].firstarc; //p指向k的第一个邻接顶点 while (p)&#123; int j = p-&gt;adjvex; //j为邻接顶点的序号 if(vl[k]&gt;vl[j]-p-&gt;info) //更新顶点k的最迟发生时间vl[k] vl[k]=vl[j]-p-&gt;info; p = p-&gt;nextarc; //p指向k的下一个邻接顶点 &#125; &#125; /* ---------------- 判断每一活动是否为关键活动 ---------------- */ for(int i=0;i&lt;G.vexnum;i++)&#123; //每次循环针对vi为活动开始点的所有活动 ArcNode *p = G.vertices[i].firstarc; //p指向i的第一个邻接项点 while (p)&#123; int j = p-&gt;adjvex; //j为i的邻接顶点的序号 int e = ve[i]; //计算活动&lt;vi,vj&gt;的最早开始时间 int l = vl[j] - p-&gt;info; //计算活动&lt;vi,vj&gt;的最迟开始时间 if(e==l) //若为关键活动，则输出&lt;vi,vj&gt; cout&lt;&lt;&quot;&lt;&quot;&lt;&lt;G.vertices[i].data&lt;&lt;&quot;,&quot;&lt;&lt;G.vertices[j].data&lt;&lt;&quot;&gt;&quot;&lt;&lt;endl; p = p-&gt;nextarc; //p指向i的下一个邻接顶点 &#125; &#125; return true;&#125; 在求每个事件的最早和最迟发生时间，以及活动的最早和最迟开始时间时，都要对所有顶点及每个顶点边表中所有的边结点进行检查，由此，求关键路径算法的时间复杂度为 O(n+e)。 对于关键路径，需要注意以下几点： 关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可通过加快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。 网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"跟Alon学数据结构(入门)-第5章 树和二叉树","slug":"跟Alon学数据结构(入门)-第5章 树和二叉树","date":"2021-08-31T05:43:35.000Z","updated":"2021-10-05T07:57:57.534Z","comments":true,"path":"2021/08/31/跟Alon学数据结构(入门)-第5章 树和二叉树/","link":"","permalink":"https://alonscholar.github.io/2021/08/31/%E8%B7%9FAlon%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%85%A5%E9%97%A8)-%E7%AC%AC5%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"树和二叉树 树结构是一类重要的非线性数据结构。直观来看，树是以分支关系定义的层次结构。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示。树在计算机领域中也得到广泛应用，尤以二叉树最为常用。如在操作系统中，用树来表示文件目录的组织结构，在编译系统中，用树来表示源程序的语法结构，在数据库系统中，树结构也是信息的重要组织形式之一。 树和二叉树的定义 树的定义 树(Tree)是n(n≥0)个结点的有限集，它或为空树(n=0)；或为非空树，对于非空树T： 有且仅有一个称之为根的结点； 除根结点以外的其余结点可分为 m(m&gt;0）个互不相交的有限集 T1,T2,…,TmT_1,T_2,…,T_mT1​,T2​,…,Tm​，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。 如，在下图中，(a)是只有一个根结点的树；(b)是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集：T1={B,E,F,K,L},T2={C,G},T3={D,H,I,J,M}。T_1=\\{B,E, F, K, L\\}, T_2=\\{C,G\\},T_3=\\{D, H, I, J, M\\}。T1​={B,E,F,K,L},T2​={C,G},T3​={D,H,I,J,M}。T1、T2T_1、T_2T1​、T2​和T3T_3T3​都是根A的子树，且本身也是一棵树。例如T1T_1T1​，其根为B，其余结点分为两个互不相交的子集： T11={E,K,L},T12={F}T_{11}=\\{E,K,L\\},T_{12}=\\{F\\}T11​={E,K,L},T12​={F}。T11T_{11}T11​和T12T_{12}T12​都是B的子树。而T11T_{11}T11​中E是根，{K}\\{K\\}{K}和{L}\\{L\\}{L}是E的两棵互不相交的子树，其本身又是只有一个根结点的树。 显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下几个性质: 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。 树中所有结点可以有零个或多个后继。 树中的结点数等于所有结点的度数加1。 度为m的树中第i层上至多有mi−1m^{i-1}mi−1个结点(i≥1)(i ≥1)(i≥1)。 高度为h的m叉树至多有(mh−1)/(m−1)(m^h-1)/(m-1)(mh−1)/(m−1)个结点。 具有n个结点的m叉树的最小高度为[log⁡m(n(m−1)+1)][\\log_m {(n(m-1)+1)}][logm​(n(m−1)+1)]。 树适合于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在n个结点的树中有n-1条边。而树中每个结点与其下一层的零个或多个结点（即其子女结点）有直接关系。 树的基本术语 名词 解释 结点 树中的一个独立单元。包含一个数据元素及若干指向其子树的分支。 结点的度 结点拥有的子树数称为结点的度。如上图(b)中，A的度为3，C度为1，F度为0。 树的度 树的度是树内各结点度的最大值。 叶子 度为 0 的结点称为叶子或终端结点。 非终端结点 度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。 双亲和孩子 结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。如上图(b)中，B的双亲为A，B的孩子有E和F。 兄弟 同一个双亲的孩子之间互称兄弟。例如上图(b)中，H、I 和 J 互为兄弟。 祖先 从根到该结点所经分支上的所有结点。例如上图(b)中，M 的祖先为 A 、 D 和H。 子孙 以某结点为根的子树中的任一结点都称为该结点的子孙。例如上图(b)中，B 的子孙为E、K、 L 和F。 层次 结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加 1。 堂兄弟 双亲在同一层的结点互为堂兄弟。例如，结点 G 与E 、 F、 H 、 I 、 J互为堂兄弟。 树的深度 树中结点的最大层次称为树的深度或高度。如上图(b)中，树的深度为4。 有序树和无序树 如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。 路径和路径长度 树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的,而路径长度是路径上所经过的边的个数。由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。 森林 森林是m (m≥0）棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树。 二叉树的定义 二叉树(Binary Tree)是n(n≥0)个结点所构成的集合，它或为空树(n=0); 或为非空树，对于非空树T: 有且仅有一个称之为根的结点； 除根结点以外的其余结点分为两个互不相交的子集T1T_1T1​和T2T_2T2​, 分别称为T的左子树和右子树，且T1T_1T1​和T2T_2T2​本身又都是二叉树。 二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点： 二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于2 的结点）； 二叉树的子树有左右之分，其次序不能任意颠倒。 二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如下图所示。 树和二叉树的抽象数据类型定义 根据树的结构定义，加上树的一组基本操作就构成了树的抽象数据类型定义： 1234567891011121314151617181920ADT Tree&#123; 数据对象D：D 是具有相同特性的数据元素的集合。 数据关系R：若 D 为空集，则称为空树；其余略。 基本操作P： InitTree(&amp;T); //构造空树T。 DestroyTree(&amp;T); //销毁树T。 CreateTree(&amp;T,definition); //按definition构造树T。 ClearTree(&amp;T); //将树T清为空树。 TreeEmpty(T); //若 T 为空树，则返回 true, 否则 false。 TreeDepth(T); //返回T的深度。 Root(T); //返回T的根。 Value(T,cur_e); //返回 cur_e 的值。 Assign(T,cur_e,value); //结点 cur_e 赋值为 value。 Parent(T,cur_e); //若 cur_e是 T 的非根结点，则返回它的双亲，否则函数值为“空”。 LeftChild(T,cur_e); //若 cur_e是T 的非叶子结点，则返回它的最左孩子，否则返回“空”。 RightSibling(T,cur_e); //若 cur_e 有右兄弟，则返回它的右兄弟，否则函数值为“空”。 InsertChild(&amp;T,p,i,c); //插入c为T中p指结点的第i棵子树。 DeleteChild(&amp;T,p,i); //删除T中 p 所指结点的第i棵子树。 TraverseTree(T); //按某种次序对T的每个结点访问一次。&#125;ADT Tree 二叉树的抽象数据类型定义如下： 12345678910111213141516171819202122232425ADT BinaryTree&#123; 数据对象D：D 是具有相同特性的数据元素的集合。 数据关系R：若 D=∮，则R=∮，称BinaryTree为空二叉树；其余略。 基本操作P： InitBiTree(&amp;T); //构造空二叉树T。 DestroyBiTree(&amp;T); //销毁二叉树T。 CreateBiTree(&amp;T,definition); //按definition构造二叉树T。 ClearBiTree(&amp;T); //将二叉树T清为空树。 BiTreeEmpty(T); //若T为空二叉树，则返回true, 否则false。 BiTreeDepth(T); //返回T的深度。 Root(T); //返回T的根。 Value(T,e); //返回e的值。 Assign(T,&amp;e,value); //结点e赋值为value。 Parent(T,e); //若e是T的非根结点，则返回它的双亲，否则返回“空”。 LeftChild(T,e); //返回e的左孩子。若e无左孩子，则返回“空”。 RightChild(T,e); //返回e的右孩子。若e无右孩子，则返回“空”。 LeftSibling(T, e); //返回e的左兄弟。若e是T的左孩子或无左兄弟，则返回 “空”。 RightSibling(T,e); //返回e的右兄弟。若e是T的右孩子或无右兄弟，则返回 “空”。 InsertChild(&amp;T,p,LR,c); //根据LR为0或1,插入c为T中p所指结点的左或右子树。p所指结点的原有左或右子树则成为c的右子树。 DeleteChild(&amp;T, p, LR); //根据LR为0或1, 删除T中p所指结点的左或右子树。 PreOrderTraverse(T); //先序遍历T, 对每个结点访问一次。 InOrderTraverse(T); //中序遍历T, 对每个结点访问一次。 PostOrderTraverse(T); //后序遍历T, 对每个结点访问一次。 LevelOrderTraverse(T); //层序遍历T, 对每个结点访问一次。&#125;ADT BinaryTree 二叉树的性质和存储结构 几种特殊的二叉树 满二叉树 一棵高度为h，且含有2h−12^h-12h−1个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点，如图(a)所示。 可以对满二叉树的结点进行连续编号，约定编号从根结点起，自上而下，自左至右。由此可引出完全二叉树的定义。 完全二叉树 高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树，如图(b)所示。 其特点如下: 若i≤⌊n/2⌋i≤\\lfloor {n/2}\\rfloori≤⌊n/2⌋，则结点 i 为分支结点，否则为叶子结点。 叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。 若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征)。 按层序编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于 i 的结点均为叶子结点。 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。 二叉排序树 左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。 平衡二叉树 树上任一结点的左子树和右子树的深度之差不超过1。 二叉树的性质 二叉树具有下列重要特性： 性质1：在二叉树的第i层上至多有2i−12^{i-1}2i−1个结点(i≥1)。 性质2：深度为k的二叉树至多有2k−12^{k}-12k−1个结点(k≥1)。 性质3：对任何一棵二叉树T, 如果其终端结点数为n0n_0n0​，度为2的结点数为n2n_2n2​，则n0=n2+1n_0=n_2+1n0​=n2​+1。 性质4：具有n(n&gt;0)个结点的完全二叉树的高(深)度为⌈log⁡2(n+1)⌉\\lceil \\log_2 (n+ 1)\\rceil⌈log2​(n+1)⌉或⌊log⁡2n⌋+1\\lfloor \\log_2n \\rfloor+1⌊log2​n⌋+1。 性质5：对完全二叉树按从上到下、从左到右的顺序依次编号1,2,…, n，则有以下关系: 当i&gt;1时，结点 i 的双亲的编号为⌊i/2⌋\\lfloor i/2\\rfloor⌊i/2⌋，即当 i 为偶数时，其双亲的编号为i/2，它是双亲的左孩子；当 i 为奇数时，其双亲的编号为(i−1)/2(i- 1)/2(i−1)/2，它是双亲的右孩子。 当2i≤n时，结点 i 的左孩子编号为2i，否则无左孩子。 当2i+1≤n时，结点 i 的右孩子编号为2i+1，否则无右孩子。 结点 i 所在层次（深度）为⌊log2i⌋+1\\lfloor log_2i\\rfloor+ 1⌊log2​i⌋+1。 二叉树的存储结构 类似线性表，二叉树的存储结构也可采用顺序存储和链式存储两种方式。 顺序存储结构 顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排在这组单元中。 对于完全二叉树，只要从根起按层序存储即可，依次自上而下、自左至右存储结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组中下标为i-1的分量中。 对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中，如下图所示，图中以&quot;0&quot;表示不存在此结点。 由此可见，这种顺序存储结构仅适用于完全二叉树。因为，在最坏的情况下，一个深度为K且只有K个结点的单支树（树中不存在度为2的结点）却需要长度为2k−12^k-12k−1的一维数组。这造成了存储空间的极大浪费， 所以对于一般二叉树，更适合采取下面的链式存储结构。 链式存储结构 设计不同的结点结构可构成不同形式的链式存储结构。由二叉树的定义得知，二叉树的结点由一个数据元素和分别指向其左、 右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域：数据域和左、 右指针域，如下图(b)所示。有时，为了便于找到结点的双亲，还可在结点结构中增加一个指向其双亲结点的指针域，如图 ( c ) 所示。 利用上图中两种结点结构所得的二叉树的存储结构分别称为二叉链表和三叉链表，如下图所示。链表的头指针指向二叉树的根结点。 在不同的存储结构中，实现二叉树的操作方法也不同，如找结点x的双亲, 在三叉链表中很容易实现，而在二叉链表中则需从根指针出发巡查。由此，在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需进行何种操作。在下一节的二叉树遍历及其应用的算法均采用以下定义的二叉链表形式实现。 123456// －－－－ 二叉树的二叉链表存储表示 －－－－typedef char TElemType;typedef struct BiTNode&#123; TElemType data; //结点数据域 struct BiTNode *lchild,*rchild; //左右孩子指针&#125;BiTNode,*BiTree; 遍历二叉树和线索二叉树 在二叉树的一些应用中，常常要求在树中查找具有某种特征的结点，或者是对树中的全部结点逐一进行处理，这就提出了一个遍历二叉树的问题。线索二叉树是在第一次遍历时将结点的前驱、后继信息存储下来，便于再次遍历二叉树。 遍历二叉树 遍历二叉树(traversing binary tree)是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。 假如使用L、D、R分别表示遍历左子树、访问根结点和遍历右子树，且限定先左后右，则有我们常使用的4种遍历。我们使用下述表格进行说明： 名称 操作 先(根)序遍历 (DLR) 若二叉树不为空：(1) 访问根结点；(2) 先序遍历左子树；(3) 先序遍历右子树。 中(根)序遍历 (LDR) 若二叉树不为空：(1) 中序遍历左子树；(2) 访问根结点；(3) 中序遍历右子树。 后(根)序遍历 (LRD) 若二叉树不为空：(1) 后序遍历左子树；(2) 后序遍历右子树；(3) 访问根结点。 层次遍历(BFS) 按照从上到下、从左至右的顺序按层次遍历。 接下来，我们会围绕上图所示的二叉树来介绍二叉树的先中后序遍历，并给出相关算法描述。我们首先来看一下各种不同的遍历所得到的输出顺序。 类型 遍历结果 先序遍历 - + a * b - c d / e f 中序遍历 a + b * c - d - e / f 后序遍历 a b c d - * + e f / - 层次遍历 - + / a * e f b - c d 从遍历结果来看，先中后序遍历的结果所对应的恰好为表达式的前缀表示（波兰式）、中缀表示和后缀表示（逆波兰式）。 我们通过下图来具体了解一下先中后序遍历算法的递归执行过程。向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历的过程中访问结点时输出的信息。 只要沿着虚线从1出发到2结束，将沿途所见的三角形(或圆形或方形)内的字符记下，便得到遍历二叉树的先序（或中序或后序）序列。例如在下图中，沿虚线游走可以分别得到先序序列为ABDEC、中序序列为DBEAC、后序序列为DEBCA。 下面我们给出先中后序遍历算法的递归与非递归实现，与层次遍历的代码实现。 先序遍历 先序遍历遵循&quot;根左右&quot;的思想，即先访问根结点，然后是左子树和右子树。我们使用递归可以很轻松的实现其遍历的操作。 下面给出先序遍历的递归算法实现： 1234567void PreOrder(BiTree T)&#123; if (T!=NULL)&#123; //若二叉树非空 cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; //访问根结点 PreOrder(T-&gt;lchild); //先序遍历左子树 PreOrder(T-&gt;rchild); //先序遍历右子树 &#125;&#125; 根据先序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树为空时，再访问它的右子树。因此先序遍历非递归的实现步骤及代码如下： 访问结点P，并将结点P入栈； 判断结点P的左孩子是否为空； 若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P； 若不为空，则将P的左孩子置为当前的结点P； 直到P为NULL并且栈为空，则遍历结束。 123456789101112131415void PreOrder2(BiTree T)&#123; stack&lt;BiTree&gt; s; BiTNode *P = T; while (P || !s.empty())&#123; //直到P为NULL并且栈空，则遍历结束 if(P)&#123; //若当前结点非空 cout&lt;&lt;P-&gt;data&lt;&lt;&quot; &quot;; //访问当前结点 s.push(P); //将当前结点入栈 P = P-&gt;lchild; //将P的左孩子置为当前结点P &#125;else&#123; //若当前结点为空 P = s.top(); s.pop(); //取栈顶元素并进行出栈操作 P = P-&gt;rchild; //将栈顶元素的右孩子置为当前结点P &#125; &#125;&#125; 中序遍历 中序遍历遵循&quot;左根右&quot;的思想，即先访问左子树，然后是根结点和右子树。 下面给出中序遍历的递归算法实现： 1234567void InOrder(BiTree T)&#123; if (T != NULL)&#123; //若二叉树非空 InOrder(T-&gt;lchild); //中序遍历左子树 cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; //访问根结点 InOrder(T-&gt;rchild); //中序遍历右子树 &#125;&#125; 根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问输出，然后按相同的规则访问其右子树。因此中序遍历非递归的实现步骤及代码如下： 对于任一结点P： 若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理； 若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子； 直到P为NULL并且栈为空，则遍历结束。 123456789101112131415void InOrder2(BiTree T)&#123; stack&lt;BiTree&gt; s; BiTNode* P = T; while (P || !s.empty())&#123; //直到P为NULL并且栈空，则遍历结束 if(P)&#123; //若当前结点非空 s.push(P); //将当前结点入栈 P = P-&gt;lchild; //将P的左孩子置为当前结点P &#125;else&#123; //若当前结点为空 P = s.top(); s.pop(); //取栈顶元素并进行出栈操作 cout&lt;&lt;P-&gt;data&lt;&lt;&quot; &quot;; //访问栈顶结点 P = P-&gt;rchild; //将当前的P置为栈顶结点的右孩子 &#125; &#125;&#125; 后序遍历 后序遍历遵循&quot;左右根&quot;的思想，即先访问左子树，然后是右子树和根结点。 下面给出后序遍历的递归算法实现： 1234567void PostOrder(BiTree T)&#123; if (T != NULL)&#123; //若二叉树非空 PostOrder(T-&gt;lchild); //后序遍历左子树 PostOrder(T-&gt;rchild); //后序遍历右子树 cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; //访问根结点 &#125;&#125; 后序遍历的非递归实现是三种遍历方法中最难的。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。 后序非递归遍历算法的思路分析:从根结点开始，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，但是此时不能出栈并访问，因为如果其有右子树，还需按相同的规则对其右子树进行处理。直至上述操作进行不下去，若栈顶元素想要出栈被访问，要么右子树为空，要么右子树刚被访问完（此时左子树早已访问完)，这样就保证了正确的访问顺序。 1234567891011121314151617181920212223void PostOrder2(BiTree T)&#123; stack&lt;BiTree&gt; s; BiTNode* P = T; //根结点赋予指针p BiTNode* r = NULL; //记录最近访问的一个结点，即前一次访问的结点 while (P || !s.empty())&#123; if(P)&#123; s.push(P); P = P-&gt;lchild; &#125;else&#123; P = s.top(); //读取栈顶元素 if(P-&gt;rchild&amp;&amp;P-&gt;rchild!=r)&#123; //若右子树存在，且未被访问过 P = P-&gt;rchild; s.push(P); P = P-&gt;lchild; &#125;else&#123; //结点右子树不存在或右子树刚刚被访问 s.pop(); cout&lt;&lt;P-&gt;data&lt;&lt;&quot; &quot;; r = P; //记录最近被访问过的结点 P = NULL; &#125; &#125; &#125; &#125; 层次遍历 要进行层次遍历，需要借助一个队列。下面给出层次遍历的算法实现： 先将二叉树根结点入队，然后出队，访问出队结点。 若它有左子树，则将左子树根结点入队； 若它有右子树，则将右子树根结点入队。 然后出队，访问出队结点……如此反复，直至队列为空。 123456789101112131415void BFS(BiTree T)&#123; queue&lt;BiTree&gt; q; q.push(T); //先将二叉树根结点入队 BiTNode* p; while (!q.empty())&#123; //若队列非空 p = q.front(); q.pop(); //取队头元素,并出队 cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; //访问出队结点 if(p-&gt;lchild)&#123; //若它有左子树，则将左子树根结点入队; q.push(p-&gt;lchild); &#125; if(p-&gt;rchild)&#123; //若它有右子树，则将右子树根结点入队。 q.push(p-&gt;rchild); &#125; &#125;&#125; 无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含 n 个结点的二叉树，其时间复杂度均为 O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为 n, 则空间复杂度也为 O(n)。 由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。 因为先序遍历的顺序是&quot;根左右&quot;，由此可以确定，在先序序列中第一个结点一定是二叉树的根结点。另外，中序遍历的顺序是&quot;左根右&quot;，根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。 同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，进而得到一棵二叉树。 例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。 首先，由先序序列可知A为二叉树的根结点。中序序列中A之前的BC为左子树的中序序列，EDGHFI为右子树的中序序列。然后由先序序列可知B是左子树的根结点,D是右子树的根结点。以此类推，就能将剩下的结点继续分解下去，最后得到的二叉树如下图 ( c ) 所示。 二叉树遍历算法的应用 “遍历” 是二叉树各种操作的基础，假设访问结点的具体操作不仅仅局限于输出结点数据域的值，而把 “访问” 延伸到对结点的判别、计数等其他操作，可以解决一些关于二叉树的其他实际问题。如果在遍历过程中生成结点， 这样便可建立二叉树的存储结构。 创建二叉树的存储结构——二叉链表 为简化问题，设二叉树中结点的元素均为一个单字符。假设按先序遍历的顺序建立二叉链表，T 为指向根结点的指针，对于给定的一个字符序列， 依次读入字符， 从根结点开始， 递归创建二叉树。 扫描字符序列， 读入字符ch。 如果ch是一个 “#” 字符， 则表明该二叉树为空树，即T为NULL；否则执行以下操作： 申请一个结点空间T； 将ch赋给T-&gt;data； 递归创建T的左子树； 递归创建T的右子树； 1234567891011void CreateBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch==&#x27;#&#x27;) T = NULL; //递归结束， 建空树 else&#123; T = new BiTNode; //生成根结点 T-&gt;data = ch; //根结点数据域置为 ch CreateBiTree(T-&gt;lchild); //递归创建左子树 CreateBiTree(T-&gt;rchild); //递归创建右子树 &#125;&#125; 如我们给出先序序列：12#46###3#5##，可建立出如下二叉链表结构。 复制二叉树 复制二叉树就是利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。根据二叉树的特点，复制步骤如下： 如果是空树，递归结束，否则执行以下操作： 申请一个新结点空间，复制根结点； 递归复制左子树； 递归复制右子树。 1234567891011void Copy(BiTree T,BiTree &amp;NewT)&#123; if(T==NULL)&#123; NewT=NULL; return; &#125;else&#123; NewT = new BiTNode; NewT-&gt;data = T-&gt;data; //复制根结点 Copy(T-&gt;lchild,NewT-&gt;lchild); //递归复制左子树 Copy(T-&gt;rchild,NewT-&gt;rchild); //递归复制右子树 &#125;&#125; 计算二叉树的深度 如果是空树，递归结束，深度为0，否则执行以下操作： 递归计算左子树的深度记为m； 递归计算右子树的深度记为n； 如果 m 大于 n，二叉树的深度为 m+1，否则为 n+1。 12345678int Depth(BiTree T)&#123; if(T==NULL) return 0; //如果是空树，深度为0，递归结束 else&#123; int m = Depth(T-&gt;lchild); //递归计算左子树的深度 int n = Depth(T-&gt;rchild); //递归计算右子树的深度 return m&gt;n?(m+1):(n+1); //返回最大子树深度+1 &#125;&#125; 统计二叉树中结点的个数 如果是空树，则结点个数为 0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上 1 。 12345int NodeCount(BiTree T)&#123; if(T==NULL) return 0; else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;&#125; 线索二叉树 遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继。 传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在任一序列中的前驱或后继。我们可以利用上二叉树中所有结点的空指针，通过不同的遍历方式， 使这些空指针来存放其前驱或后继结点。 这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。 注： 在含n个结点的二叉树中，有n+1个空指针。 这是因为每个叶结点有2个空指针，每个度为1的结点有1个空指针，空指针总数为2n0+n12n_0 + n_12n0​+n1​，又n0=n2+1n_0 = n_2 + 1n0​=n2​+1，所以空指针总数为n0+n1+n2+1=n+1n_0+ n_1+n_2+1 =n+1n0​+n1​+n2​+1=n+1。 我们规定： 若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。如下图所示，还需增加两个标志域标识指针域是指向左（右）孩子还是指向前驱（后继)。 其中，标志域的含义如下： 线索二叉树的存储结构描述如下: 1234567// －－－－ 二叉树的二叉线索存储表示 －－－－typedef char TElemType;typedef struct BiThrNode&#123; TElemType data; //数据元素，可以是任意其他类型，这里采用char。 struct BiThrNode *lchild, *rchild; //左、右孩子指针。 int LTag=0, RTag=0; //左、右线索标志，0表示指向孩子结点，1表示指向线索。&#125; BiThrNode, *BiThrTree; 这里提出一些相关名词概念： 名词 解释 线索链表 以上面这种结点结构构成的二叉链表作为二叉树的存储结构。 线索 指向结点前驱和后继的指针。 线索二叉树 加上线索的二叉树，称之为线索二叉树 (Threaded Binary Tree)。 线索化 对二叉树以某种次序遍历使其变为线索二叉树的过程。 由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索， 而前驱或后继的信息只有在遍历时才能得到， 因此线索化的过程即为在遍历的过程中修改空指针的过程，可用递归算法。对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树，包括先序线索二叉树、中序线索二叉树和后序线索二叉树。以下我们将分别介绍三种序列实现的线索二叉树，以及代码实现。 中序线索二叉树 为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，而指针p指向当前访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就将它指向pre；检查pre的右指针是否为空，若为空就将它指向p，由此记录下遍历过程中访问结点的先后关系。如下图所示。 以结点p为根的子树中序线索化： 如果p非空，左子树递归线索化。 如果p的左孩子为空，则给p加上左线索，将其 LTag 置为1，让p的左孩子指针指向pre(前驱)；否则将p的LTag置为0。 如果pre不为空，并且pre的右孩子为空，则给pre加上右线索，将其 RTag 置为1，让pre的右孩子指针指向p(后继)；否则将pre的RTag置为0。 将pre指向刚访问过的结点p，即 pre=p。 右子树递归线索化。 12345678910111213141516171819202122232425BiThrNode *pre;//中序遍历对二叉树线索化的递归算法void InThreading(BiThrTree p)&#123; if (p)&#123; InThreading(p-&gt;lchild); //左子树递归线索化 if (!p-&gt;lchild)&#123; //如果左子树为空 p-&gt;LTag = 1; p-&gt;lchild = pre; &#125; if (pre &amp;&amp; !pre-&gt;rchild)&#123; //此处需要判断第一次pre是否为空的情况。 pre-&gt;RTag = 1; //给pre加上右线索 pre-&gt;rchild = p; //pre的右孩子指针指向p (后继） &#125; pre = p; //保持pre指向p的前驱 InThreading(p-&gt;rchild); //右子树递归线索化 &#125;&#125;//调用此方法完成线索化void CreateInThread(BiThrTree T)&#123; if (T != NULL)&#123;//完成线索化后，pre指向中序遍历的最后一个结点。所以还需要对最后一个结点进行处理。 InThreading(T); pre-&gt;rchild = NULL; pre-&gt;RTag = 1; &#125;&#125; 在二叉树的线索链表上也可以添加一个头结点，并令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；同时，令二叉树中序序列中第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。如下图所示： 带头结点的二叉树中序线索化: 12345678910111213141516//带头结点的中序线索化二叉树，相当于双向线索链表 void InOrderThreading(BiThrTree &amp;Head,BiThrTree T)&#123;//Head指向头结点 Head = new BiThrNode; //建头结点 Head-&gt;LTag = 0; //头结点有左孩子，若树非空，则其左孩子为树根 Head-&gt;RTag = 1; //头结点的右孩子指针为右线索 Head-&gt;rchild = Head; //初始化时右指针指向自己 if(!T) Head-&gt;lchild = Head; //若树为空，则左指针也指向自己 else&#123; Head-&gt;lchild = T; //头结点的左孩子指向根 pre = Head; //pre 初值指向头结点，可完成中序线索第一个结点指向头结点的功能 InThreading(T); //对以T为根的二叉树进行中序线索化 pre-&gt;rchild = Head; //线索化完，pre指向中序遍历的最后一个结点，最后一个结点rchild域的指针指向头结点 pre-&gt;RTag = 1; //pre的右标记为1 Head-&gt;rchild = pre; //头结点的rchild域的指针指向中序遍历时访问的最后一个结点 &#125; &#125; 对于线索二叉树的遍历，不能再像普通二叉树的遍历一样，因为会导致死循环。线索二叉树进行遍历时，需要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。 所以我们需要找到序列的第一个结点，以及序列的下一个结点（以不带头结点的线索化为例）。 1）查找p指针所指结点的前驱： 若p-&gt;LTag为1，则p的左链指示其前驱； 若p-&gt;LTag为0，则说明p有左子树，结点的前驱是遍历左子树时最后访问的一个结点（左子树中最右下的结点）。 2）查找p指针所指结点的后继： 若p-&gt;RTag为1，则p的右链指示其后继； 若p-&gt;RTag为0，则说明p有右子树。右子树访问的第一个结点就是下一个结点，即右子树中最左下的结点。 由以上的想法我们给出不含头结点的中序线索二叉树的中序遍历的算法： 12345678910111213141516//求中序线索二叉树中中序序列下的第一个结点BiThrNode* Firstnode(BiThrNode *p)&#123; while (p-&gt;LTag==0) //最左下结点 p = p-&gt;lchild; return p;&#125;//求中序线索二叉树中结点p在中序序列下的后继BiThrNode* Nextnode(BiThrNode *p)&#123; if(p-&gt;RTag==0) return Firstnode(p-&gt;rchild); else return p-&gt;rchild; //rtag==1 直接返回后继线索&#125;//中序线索二叉树的中序遍历void InOrder(BiThrNode *T)&#123; for(BiThrNode *p=Firstnode(T);p!=NULL;p=Nextnode(p)) cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;LTag&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;RTag&lt;&lt;endl;&#125; 先序线索二叉树 先序线索二叉树的思想类似，再先序遍历的基础上对二叉树进行线索化。构建出来的先序线索二叉树如下图所示。先序序列为ABCDF，其中将C的左链域指向前驱B，右链域指向后继D；结点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继F；结点F无左孩子，将左链域指向前驱D，无右孩子，也无后继故置空。 以结点p为根的子树先序线索化： 如果p非空，进行如下操作。 如果p的左孩子为空，则给p加上左线索，将其LTag置为1，让p的左孩子指针指向pre(前驱)；否则将p的LTag置为0。 如果pre不为空，并且pre的右孩子为空，则给pre加上右线索，将其RTag置为1，让pre的右孩子指针指向p(后继)；否则将pre的RTag置为0。 将pre指向刚访问过的结点p，即pre=p。 若左指针不是线索，左子树递归线索化。 若右指针不是线索，右子树递归线索化。 123456789101112131415161718192021222324252627BiThrNode *pre;//先序遍历对二叉树线索化的递归算法void PreThreading(BiThrTree p)&#123; if (p)&#123; if (!p-&gt;lchild)&#123; //如果左子树为空 p-&gt;LTag = 1; //给p加上左线索 p-&gt;lchild = pre; //p的左孩子指针指向pre(前驱） &#125; if (pre &amp;&amp; !pre-&gt;rchild)&#123; //此处需要判断第一次pre是否为空的情况。 pre-&gt;RTag = 1; //给pre加上右线索 pre-&gt;rchild = p; //pre的右孩子指针指向p(后继） &#125; pre = p; //保持pre指向p的前驱 if(p-&gt;LTag==0) //若p的左指针不是线索，再进行递归 PreThreading(p-&gt;lchild); //左子树递归线索化 if(p-&gt;RTag==0) //若p的右指针不是线索，再进行递归 PreThreading(p-&gt;rchild); //右子树递归线索化 &#125;&#125;//调用此方法完成线索化void CreatePreThread(BiThrTree T)&#123; if (T != NULL)&#123;//完成线索化后，pre指向先序遍历的最后一个结点。所以还需要对最后一个结点进行处理。 PreThreading(T); pre-&gt;rchild = NULL; pre-&gt;RTag = 1; &#125;&#125; 在先序线索二叉树中查找 1）查找p指针所指结点的前驱: 若p-&gt;LTag为1，则p的左链域指示其前驱； 若p-&gt;LTag为0，则说明p有左子树。此时p的前驱有两种情况：若*p是其双亲的左孩子，则其前驱为其双亲结点；否则应是其双亲的左子树上先序遍历最后访问到的结点。 2）查找p指针所指结点的后继: 若p-&gt;RTag为1，则p的右链指示其后继； 若p-&gt;RTag为0，则说明p有右子树。按先序遍历的规则可知，*p的后继必为其左子树根（若存在）或右子树根。 先序线索二叉树的先序遍历的算法实现： 12345678910111213void PreOrder(BiThrTree T)&#123; if(T)&#123; BiThrNode *p = T; while (p)&#123; while (p-&gt;LTag==0)&#123;//左指针不是线索，则边访问边左移 cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;LTag&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;RTag&lt;&lt;endl; p = p-&gt;lchild; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;LTag&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;RTag&lt;&lt;endl; //此时p左指针必为线索，但未访问，则访问 p = p-&gt;rchild; //此时p左孩子不存在 &#125; &#125;&#125; 后序线索二叉树 后序线索二叉树的过程:后序序列为CDBFA，结点C无左孩子，也无前驱故置空，无右孩子，将右链域指向后继D；结点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继B；结点F无左孩子，将左链域指向前驱B，无右孩子，将右链域指向后继A，得到的后序线索二叉树如下图所示。 后序线索化的代码如下： 1234567891011121314151617BiThrNode *pre;//后序遍历对二叉树线索化的递归算法void PostThreading(BiThrTree p)&#123; if (p)&#123; PostThreading(p-&gt;lchild); //左子树递归线索化 PostThreading(p-&gt;rchild); //右子树递归线索化 if (!p-&gt;lchild)&#123; //如果左子树为空 p-&gt;LTag = 1; //给p加上左线索 p-&gt;lchild = pre; //p的左孩子指针指向pre (前驱） &#125; if (pre &amp;&amp; !pre-&gt;rchild)&#123; //此处需要判断第一次pre是否为空的情况。 pre-&gt;RTag = 1; //给pre加上右线索 pre-&gt;rchild = p; //pre的右孩子指针指向p (后继） &#125; pre = p; //保持pre指向p的前驱 &#125;&#125; 在后序线索二叉树中查找 1）查找p指针所指结点的前驱: 若p-&gt;LTag为1，则p的左链指示其前驱； 若p-&gt;LTag为0，当p-&gt;RTag也为0时，则p的右链指示其前驱。若p-&gt;LTag为0，而p-&gt;RTag为1时，则p的左链指示其前驱。 2）查找p指针所指结点的后继情况比较复杂，分以下情况讨论： 若 *p是二叉树的根，则其后继为空； 若 *p是其双亲的右孩子，则其后继为双亲结点； 若 *p是其双亲的左孩子，且 *p没有右兄弟，则其后继为双亲结点； 若 *p是其双亲的左孩子，且 *p有右兄弟，则其后继为双亲的右子树上按后序遍历列出的第一个结点（ 即右子树中 “最左下” 的叶结点）。 可见在后序线索二叉树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。这里不再进行阐述。 树和森林 树的存储结构 树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍3种常用的存储结构。 双亲表示法 这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。 双亲表示法的存储结构描述如下: 12345678910#define MAX_TREE_SIZE 100 //树中最多结点树typedef char TElemType;typedef struct&#123; //树的结点定义 TElemType data; //数据元素 int parent; //双亲位置域&#125;PTNode;typedef struct&#123; //树的类型定义 PTNode nodes[MAX_TREE_SIZE]; //所有结点数组 int n; //结点数&#125;PTree; 该存储结构利用了每个结点(根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。 孩子表示法 孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表(叶子结点的孩子链表为空表)。不仅如此，还可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起。如下图所示(对应的树为双亲表示法的树)。 孩子兄弟法 孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容:结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点)，如下图所示(对应的树为双亲表示法的树)。 孩子兄弟表示法的存储结构描述如下: 123456// ---- 树的二叉链表（孩子-兄弟）存储表示 ----typedef char TElemType;typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild,*nextsibling; //第一个孩子和右兄弟指针&#125;CSNode,*CSTree; 这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。 森林与二叉树的转换 由于二叉树和树都可以用二叉链表作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树，可以找到唯一的一棵二叉树与之对应。从物理结构上看，它们的二叉链表是相同的，只是解释不同而已。 树转换成二叉树 从树的二叉链表表示的定义可知，任何一棵和树对应的二叉树，其根结点的右子树必空。这是因为根结点没有兄弟，所以对应的二叉树没有右子树。 树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称&quot;左孩子右兄弟&quot;。 森林转换成二叉树 将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子树……以此类推,就可以将森林转换为二叉树。 二叉树转换成森林 二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树,应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。 树和森林的遍历 树的遍历 如下图中所展示的树来说明一下相关的几种树遍历。 类型 描述 遍历序列 先根遍历 先访问树的根结点，然后依次先根遍历根的每棵子树。 ABEFCDG 后根遍历 先依次后根遍历每棵子树，然后访问根结点。（对应其转换成二叉树的中序遍历） EFBCGDA 层次遍历 按层序依次访问各结点。 ABCDEFG 森林的遍历 按照森林和树相互递归的定义，可得到森林的两种遍历方法。 类型 描述 遍历序列 先序遍历森林 ① 访问森林中第一棵树的根结点。② 先序遍历第一棵树中根结点的子树森林。③ 先序遍历除去第一棵树之后剩余的树构成的森林。 ABCDEFGHIJ 中序遍历森林 ① 中序遍历森林中第一棵树的根结点的子树森林。② 访问第一棵树的根结点。③ 中序遍历除去第一棵树之后剩余的树构成的森林。 BCDAFEHJIG 当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和中序遍历即为其对应二叉树的先序和中序遍历。 树与二叉树的应用 二叉排序树(BST) 二叉排序树的定义 二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树： 若左子树非空，则左子树上所有结点的值均小于根结点的值。 若右子树非空，则右子树上所有结点的值均大于根结点的值。 左、右子树也分别是一棵二叉排序树。 根据二叉排序树的定义，左子树结点值 &lt; 根结点值 &lt; 右子树结点值，所以对二叉排序树进行中序遍历，可以得到一个递增的有序序列。例如，下图所示二叉排序树的中序遍历序列为1 2 3 4 6 8。 二叉排序树的在c++中的定义与普通二叉树一样： 12345// ---- 二叉排序树的定义 ----typedef struct BSTNode&#123; int data; //这里我们使用int类型，也可以使用其它类型 struct BSTNode *lchild,*rchild; //定义左子树与右子树指针&#125;BSTNode,*BiTree; 二叉排序树的查找 二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。 二叉排序树的非递归查找算法: 1234567BSTNode* BST_Search(BiTree T,int key)&#123; while (T!=NULL &amp;&amp; key!=T-&gt;data)&#123; //当树空或等于根结点值，结束循环 if(key&lt;T-&gt;data) T = T-&gt;lchild; //小于，在左子树查找 else T = T-&gt;rchild; //大于，在右子树查找 &#125; return T;&#125; 二叉排序树的递归算法实现： 12345678BSTNode* BST_Search2(BiTree T,int key)&#123; if(T==NULL || key == T-&gt;data) //当树空或等于根结点值，结束递归 return T; if(key&lt;T-&gt;data) return BST_Search2(T-&gt;lchild,key); //值小于根结点，在左子树查找 else return BST_Search2(T-&gt;rchild,key); //值大于根结点，在右子树查找&#125; 二叉排序树的插入 插入结点的过程如下: 若原二叉排序树为空，则直接插入结点; 否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。 插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。 如下图所示，在一个二叉排序树中依次插入结点28和结点58，虚线表示的边是其查找的路径。 二叉排序树插入操作的算法描述如下: 123456789101112131415//若插入成功返回true，插入失败返回falsebool BST_Insert(BiTree &amp;T,int key)&#123; if(T==NULL)&#123; //若递归到根结点为空，则说明可以插入 T=(BiTree)malloc(sizeof(BSTNode)); T-&gt;data = key; T-&gt;lchild = T-&gt;rchild = NULL; return true; &#125;else if(key==T-&gt;data)&#123; //若树中存在相同关键字的结点，插入失败 return false; &#125;else if(key&lt;T-&gt;data)&#123; //若值小于结点，插入到其左子树 return BST_Insert(T-&gt;lchild,key); &#125;else&#123; //若值大于结点，插入到其右子树 return BST_Insert(T-&gt;rchild,key); &#125;&#125; 二叉排序树的构造 从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。设查找的关键字序列为{45,24,53,45,12,24}\\{45,24,53,45,12,24\\}{45,24,53,45,12,24}，则生成的二叉排序树如下图所示。 构造二叉排序树的算法描述如下: 12345678void Creat_BST(BiTree &amp;T,int keys[],int n)&#123;//keys是关键字序列，n表示其长度 T = NULL; //初始时T为空树 int i = 0; while (i&lt;n)&#123; //依次将每个关键字插入到二叉排序树中 BST_Insert(T,keys[i]); i++; &#125;&#125; 二叉排序树的删除 在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理: 若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱)，这样就转换成了第一或第二种情况。 下图显示了在3种情况下分别删除结点45,78,78的过程。 二叉排序树的删除算法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243bool BST_Delete(BiTree &amp;T,int key)&#123; BSTNode *z = BST_Search(T,key); //通过要删除的结点的值找到该结点 if(z==NULL) //若要删除的结点不存在，删除失败 return false; if(z-&gt;lchild==NULL &amp;&amp; z-&gt;rchild==NULL)&#123;//若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。 z = NULL; free(z); &#125;else if(z-&gt;lchild==NULL &amp;&amp; z-&gt;rchild!=NULL)&#123;//若结点z只有一棵右子树,让右子树代替z的位置 BSTNode *p = z-&gt;rchild; z-&gt;data = p-&gt;data; z-&gt;lchild = p-&gt;lchild; z-&gt;rchild = p-&gt;rchild; free(p); &#125;else if(z-&gt;rchild==NULL &amp;&amp; z-&gt;lchild!=NULL)&#123;//若结点z只有一棵左子树,让左子树代替z的位置 BSTNode *p = z-&gt;lchild; z-&gt;data = p-&gt;data; z-&gt;lchild = p-&gt;lchild; z-&gt;rchild = p-&gt;rchild; free(p); &#125;else&#123;//结点z有左、右两棵子树，则令z的直接后继替代z //1. 先找到z的右孩子的最下面的左孩子，即为右孩子的最小的那个(是z的直接后继) BSTNode *left = z-&gt;rchild; while (left-&gt;lchild != NULL)&#123; left = left-&gt;lchild; &#125; //2. 将右孩子的最下面的左孩子的数据赋给node z-&gt;data = left-&gt;data; //3. 处理这个直接后继结点，因为是最后的一个左孩子肯定没有左孩子， //所以如果该结点有右孩子，就将右孩子赋予改结点。否则将该结点置为NULL if (left-&gt;rchild != NULL)&#123; BSTNode *p = left-&gt;rchild; left-&gt;data = p-&gt;data; left-&gt;lchild = p-&gt;lchild; left-&gt;rchild = p-&gt;rchild; free(p); &#125; else&#123; left = NULL; free(left); &#125; &#125; return true;&#125; 二叉排序树的查找效率分析 从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树，如下图所示。 在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增加为元素个数n。 补充知识点： 等概率情况下，上图(a)查找成功的平均查找长度为：ASLa=(1+2×2+3×4＋4×3)/10=2.9ASL_a= (1 +2×2+3×4＋4×3)/10= 2.9ASLa​=(1+2×2+3×4＋4×3)/10=2.9 上图(b)查找成功的平均查找长度为：ASLb=(1+2＋3＋4＋5＋6＋7＋8+9+10)/10=5.5ASL_b=(1+2＋3＋4＋5＋6＋7＋8+9+ 10)/10= 5.5ASLb​=(1+2＋3＋4＋5＋6＋7＋8+9+10)/10=5.5 类型 从查找过程分析 从维护分析 适用情况 二叉排序树 查找效率取决于树的高度。输入序列决定了判定树的形态，故判定树不唯一，查找时间复杂度最好为O(log2n)O(log_2n)O(log2​n)，最坏为O(n)O(n)O(n)。 无须移动结点，只需修改指针即可完成插入和删除操作，平均执行时间为O(log2n)O(log_2n)O(log2​n)。 动态查找表 二分查找 判定树唯一，查找时间复杂度为O(log2n)O(log_2n)O(log2​n)。 二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的代价是O(n)。 静态查找表 平衡二叉树(AVL树) 平衡二叉树的定义 为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树(Balanced Binary Tree)，简称平衡树。 平衡因子：结点左子树与右子树的高度差。 平衡二叉树：平衡二叉树结点的平衡因子的值只可能是 -1、0或1。 平衡二叉树的插入 二叉排序树保证平衡的基本思想如下： 每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。 若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A。 再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。 注意： 每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。 平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况： LL平衡旋转(右单旋转) 由于在结点 A 的左孩子的左子树插入了新结点，导致A的平衡因子由1增至2，需要一次向右的旋转操作。右旋之后，B变为根结点，A变为B的右子树，B的原右子树按照大小次序，应作为A的左子树。 RR平衡旋转(左单旋转) 由于在结点 A 的右孩子的右子树插入了新结点，导致A的平衡因子由-1减至-2，需要一次向左的旋转操作。左旋之后，B变为根结点，A变为B的左子树，B的原左子树按照大小次序，应作为A的右子树。 LR平衡旋转(先左后右双旋转) 由于在结点 A 的左孩子的右子树插入了新结点，导致A的平衡因子由1增至2，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置。 RL平衡旋转(先右后左双旋转) 由于在结点 A 的右孩子的左子树插入了新结点，导致A的平衡因子由-1减至-2，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置。 平衡二叉树的查找 在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。因此平衡二叉树的平均查找长度为O(log2n)O(log_2n)O(log2​n)。 哈夫曼树和哈夫曼编码 哈夫曼树的基本概念 哈夫曼(Huffman)树又称最优树，是一类带权路径长度最短的树，在实际中有广泛的用途。 哈夫曼树的定义，涉及路径、路径长度、权等概念，下面先给出这些概念的定义，然后再介绍哈夫曼树。 名词 定义 路径 从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。 路径长度 路径上的分支数目称作路径长度。 树的路径长度 从树根到每一结点的路径长度之和。 权 赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。 结点的带权路径长度 从该结点到树根之间的路径长度与结点上权的乘积。 树的带权路径长度 树中所有叶子结点的带权路径长度之和，通常记作WPL=∑k=1nwklkWPL=\\sum\\limits_{k=1}^nw_kl_kWPL=k=1∑n​wk​lk​。 哈夫曼树 带权路径长度 WPL 最小的二叉树称做最优二叉树或哈夫曼树。 例如，下图中所示的3棵二叉树，都含4个叶子结点a、b、c 、d, 分别带权7、5、2、4，它们的带权路径长度分别为： 其中c树的WPL最小，可以验证，它恰好为哈夫曼树。 哈夫曼树的构造算法 给定n个权值分别为w1,w2,...,wnw_1,w_2,..., w_nw1​,w2​,...,wn​的结点，构造哈夫曼树的算法描述如下: 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。 从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 重复步骤2）和3)，直至F中只剩下一棵树为止。 从上述构造过程中可以看出哈夫曼树具有如下特点: 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。 构造过程中共新建了n-1个结点（双分支结点)，因此哈夫曼树的结点总数为2n-1。 每次构造都选择 2 棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。 例如，权值{7,5,2,4}\\{7,5,2,4\\}{7,5,2,4}的哈夫曼树的构造过程如下图所示。 哈夫曼算法的实现： 初始化：首先动态申请 2n 个单元；然后循环 2n-1 次，从 1 号单元开始，依次将 1 至 2n-1 所有单元中的双亲、左孩子、右孩子的下标都初始化为0; 最后再循环n次，输入前n个单元中叶子结点的权值。 创建树：循环 n-1 次，通过 n-1 次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为0且权值最小的两个树根结点 s1 和 s2；删除是指将结点 s1 和 s2 的双亲改为非0；合并就是将 s1 和 s2 的权值和作为一个新结点的权值依次存入到数组的第 n+1 之后的单元中，同时记录这个新结点左孩子的下标为 s1， 右孩子的下标为 s2。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#define Infinite 99999999//这里使用数组的方式顺序存储哈夫曼树，前n个位置存储了叶子结点，后n-1个位置存储了非叶子结点。//---- 哈夫曼树的存储表示 ----typedef struct&#123; int weight; //结点的权值 int parent,lchild,rchild; //结点的双亲、左孩子和右孩子的下标&#125;HTNode,*HuffmanTree; //动态分配数组存储哈夫曼树//选择两个其双亲域为0 且权值最小的结点，并返回它们在 HT 中的序号 sl和 s2void Select(HuffmanTree &amp;HT,int n,int &amp;s1,int &amp;s2)&#123; int min = Infinite; //找出最小值的下标 for(int i=1;i&lt;=n;i++)&#123; if(HT[i].parent==0 &amp;&amp; HT[i].weight&lt;min)&#123; s1 = i; min = HT[i].weight; &#125; &#125; min = Infinite; //找出值第二小的下标 for(int i=1;i&lt;=n;i++)&#123; if(HT[i].parent==0 &amp;&amp; HT[i].weight&lt;min &amp;&amp; i!=s1)&#123; s2 = i; min = HT[i].weight; &#125; &#125;&#125;void CreateHuffmanTree(HuffmanTree &amp;HT,int n)&#123; if(n&lt;=1) return; int m = 2*n-1; //n个叶子结点的哈夫曼树共有2n-1个结点。 HT = new HTNode[m+1]; //0号单元不用，动态分配m+1个单元。 for(int i=1;i&lt;=m;i++)&#123; //初始化1~m号单元 HT[i].parent = 0; HT[i].lchild = 0; HT[i].rchild = 0; &#125; for(int i=1;i&lt;=n;i++) //输入前n个单元中叶子结点的权值 cin&gt;&gt;HT[i].weight; //-------- 创建哈夫曼树 -------- for(int i=n+1;i&lt;=m;i++)&#123; int s1,s2; //在 HT[k] (k在1到i-1之间) 中选择两个其双亲域为0且权值最小的结点，并返回它们在 HT 中的序号 sl和 s2 Select(HT,i-1,s1,s2); HT[s1].parent = HT[s2].parent = i; //将两个最小的结点的父结点设置为下标i HT[i].lchild = s1; //将HT[i]的左孩子下标设置为s1 HT[i].rchild = s2; //将HT[i]的右孩子下标设置为s2 HT[i].weight = HT[s1].weight+HT[s2].weight; //HT[i]的权值为两个孩子权值之和 &#125;&#125; 哈夫曼编码 为了引出哈夫曼编码的思想，我们先说明一些概念： 名词 解释 固定长度编码 对每个字符用相等长度的二进制位表示。 可变长度编码 允许对不同字符用不等长的二进制位表示。 前缀编码 在一个编码方案中，没有一个编码是另一个编码的前缀。 光看上面的概念不是很好理解，我们来举例说明一下这些概念。 如a,b,c,d四个字符，我们若用二进制表示，可以表示为：a-&gt;00，b-&gt;01，c-&gt;10，d-&gt;11。这些字符编码的二进制位都相等，所以我们称其为固定长度编码。 倘若在一篇文章中，a出现了10次，b出现了6次，而c和d各只出现了2次，这时候我们再使用固定长度编码就变得不太聪明了。因为a出现的次数最多，我们完全可以使其用一个更短的编码如0表示，而b出现次数第二多，我们用1表示，c使用10，d使用11。这样我们得到的编码从整体上来说，就变得更短，压缩数据的效果就越好。这便是可变长度编码。 从上面介绍的可变长度编码可以观察出一些问题，就是解码的时候有多种可能性。比如01101，我们可以解码成adab也可以解码成abcb。这种情况的出现是因为b-&gt;1是c-&gt;10，d-&gt;11的前缀，所以我们解码得到的结果不唯一，这样显然是不行的，我们需要确保编码与解码的准确性。所以在一个编码方案中，当任一个编码都不是其他任何编码的前缀时，我们称为前缀编码。 了解到上面的概念后，我们来提出哈夫曼树实现哈夫曼编码的思路： 哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串， 该二进制串就称为哈夫曼编码。 由哈夫曼树得到哈夫曼编码很简单，我们将每个字符当作一个独立的结点，其权值为它出现的频度，然后构造哈夫曼树。将每个左分支置为0，右分支置为1，从根结点到叶子结点(该字符)的路径即为该字符的哈夫曼编码。 在构造好哈夫曼树之后，求哈夫曼编码编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止。 回溯时走左分支则生成代码0，走右分支则生成代码1。 根据哈夫曼树求哈夫曼编码的算法实现： 由哈夫曼树的构造算法得知，前n个元素记录的为叶子结点，后n-1个元素记录的为合并出来的父结点。所以我们遍历前n个叶子结点。 记录叶子结点的下标，和其父结点的下标，然后回溯判断子结点是父结点的左孩子还是右孩子，左孩子输出0，右孩子输出1。 循环上述操作，不断更新孩子结点和父结点的下标，直到结点的父结点下标为0，表示已经到根结点，停止循环。 12345678910111213141516171819//在这里我们定义哈夫曼树的时候多加一个字符型的data域，用于记录结点是哪个字符。void CreateHuffmanCode(HuffmanTree HT,int n)&#123; int start; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;HT[i].data&lt;&lt;&#x27;:&#x27;; start = i; //从叶子结点开始 int p = HT[start].parent; //p为父结点的下标 while (p!=0)&#123;//当p的下标为0时结束，哈夫曼树下标从1开始记录 if(HT[p].lchild==start)&#123;//判断原子结点是父结点的左孩子还是右孩子 cout&lt;&lt;&#x27;0&#x27;&lt;&lt;&#x27; &#x27;; //左孩子输出0 &#125;else&#123; cout&lt;&lt;&#x27;1&#x27;&lt;&lt;&#x27; &#x27;; //右孩子输出1 &#125; start = p; //更新子结点 p = HT[p].parent; //更新父结点 &#125; cout&lt;&lt;endl; &#125;&#125; 由上述算法得到的哈夫曼编码为倒序输出的结果，因为是从叶子结点从下往上输出的，可以使用栈来逆转顺序，也可以使用容器或数组来存储哈夫曼编码的结果，此处不在阐述。 文件的编码和译码 (1) 编码：有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符c，在哈夫曼编码表HC中找到此字符，将字符c转换为编码表中存放的编码串。 (2) 译码：依次读入文件的二进制码，从哈夫曼树的根结点出发，读到0走左孩子，读到1走右孩子，一旦到达叶子结点将其数据输出即可。 树的应用—并查集 并查集是一种简单的集合表示，它支持以下3种操作： Union(S,Root1,Root2)：把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不执行合并。 Find(S,x)：查找集合S中单元素x所在的子集合，并返回该子集合的名字。 Initial(S)：将集合S中的每个元素都初始化为只有一个单元素的子集合。 通常使用树（森林）的双亲表示法作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数。 若设有一个全集合为S={0,1,2,3,4,5,6,7,8,9}S= \\{0,1,2,3,4,5,6,7,8,9\\}S={0,1,2,3,4,5,6,7,8,9}，下面介绍使用并查集的一些操作。 状态 介绍 图片展示 初始化 每个子集合的数组值为-1。 集合合并 子集合合并为3个更大的子集合后。子结点值为根结点下标，根结点值为集合元素个数的相反数。 两个子集合合并 将其中一个子集合根结点的双亲指针指向另一个集合的根结点。S1∪S2S_1 ∪S_2S1​∪S2​ 在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从0到size-1。其中size是最大元素的个数。下面是并查集主要运算的实现。 12345678910111213141516171819202122#define SIZE 100 //定义集合元素的个数 int UFSets[SIZE]; //集合元素数组，使用双亲表示法void Initial(int S[])&#123; for(int i=0;i&lt;SIZE;i++) //每个自成单元素集合 S[i]=-1;&#125;int Find(int S[],int x)&#123; while (S[x]&gt;0)&#123; //循环寻找x的根 x=S[x]; &#125; return x; //返回树的根&#125;void Union(int S[],int Root1,int Root2)&#123; //要求传入的为两个根结点，可以用Find方法找到根结点 if(Root1!=Root2)&#123; //若两个根结点不同 S[Root1] += S[Root2]; //将集合Root2中的元素个数加到集合Root1上 S[Root2]=Root1; //将根Root2连接到另一根Root1下面 &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"跟Alon学数据结构(入门)-第4章 串、数组和广义表","slug":"跟Alon学数据结构(入门)-第4章 串、数组和广义表","date":"2021-08-28T05:43:35.000Z","updated":"2021-10-05T07:57:46.789Z","comments":true,"path":"2021/08/28/跟Alon学数据结构(入门)-第4章 串、数组和广义表/","link":"","permalink":"https://alonscholar.github.io/2021/08/28/%E8%B7%9FAlon%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%85%A5%E9%97%A8)-%E7%AC%AC4%E7%AB%A0%20%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/","excerpt":"","text":"串、数组和广义表 计算机上的非数值处理的对象大部分是字符串数据， 字符串一般简称为串。串是一种特殊的线性表， 其特殊性体现在数据元素是一个字符， 也就是说， 串是一种内容受限的线性表。由于现今使用的计算机硬件结构是面向数值计算的需要而设计的， 在处理字符串数据时比处理整数和浮点数要复杂得多。而且， 在不同类型的应用中， 所处理的字符串具有不同的特点， 要有效地实现字符串的处理， 就必须根据具体情况使用合适的存储结构。多维数组和广义表可以看成是线性表的一种扩充， 即线性表的数据元素自身又是一个数据结构。 串的定义 串(string)(或字符串）是由零个或多个字符组成的有限序列， 一般记为：s=&quot;a1a2...an&quot;(n≥0)s=&quot;a_1a_2...a_n&quot; (n≥0)s=&quot;a1​a2​...an​&quot;(n≥0) s是串的名，用双引号括起来的字符序列是串的值； ai(1≤i≤n)a_i(1≤i≤n)ai​(1≤i≤n)可以是字母、数字或其他字符； 串中字符的数目n称为串的长度。零个字符的串称为空串(null string) , 其长度为零。 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。 通常称字符在序列中的序号为该字符在串中的位置。 子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。 称两个串是相等的， 当且仅当这两个串的值相等。 由一个或多个空格组成的串 &quot; &quot; 称为空格串 (blank string，请注意：此处不是空串）， 其长度为串中空格字符的个数。 我们用符号 &quot;ϕ&quot;&quot; \\phi &quot;&quot;ϕ&quot; 来表示空串。 串的类型定义、存储结构及其运算 串的抽象类型定义 串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。 然而，串的基本操作和线性表有很大差别。在串的基本操作中，通常以 “串的整体” 作为操作对象，如查找某个子串，插入一个子串，删除一个子串等等。 下面给出串的抽象数据类型定义： 123456789101112131415161718ADT String&#123; 数据对象：D=&#123;ai|ai∈CharacterSet,i=1,2,...,n,n&gt;=0&#125; 数据关系：Rl=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 基本操作： StrAssign(&amp;T, chars); //赋值操作。把串T赋值为chars。 StrCopy(&amp;T,S); //复制操作。由串S复制得到串T。 StrEmpty(S); //判空操作。若S为空串，则返回true，否则返回false。 StrCompare(S,T);//比较操作。若S&gt;T, 则返回值&gt;0;若S=T，则返回值=0; 若S&lt;T，则返回值&lt;0。 StrLength(S); //求串长。返回串S的元素个数。 SubString(&amp;Sub,S,pos,len); //求子串。用Sub返回串S的第pos个字符起长度为len的子串。 Concat(&amp;T,S1,S2); //串联接。用T返回由S1和S2联接而成的新串。 Index(S,T); //定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置;否则返回值为0。 ClearString(&amp;S); //清空操作。将S清为空串。 DestroyString(&amp;S); //销毁串。将串S销毁。 Replace(&amp;S,T,V); //用V替换主串S中出现的所有与T相等的不重叠的子串。 StrInsert(&amp;S,pos,T); //在串 S 的第 pos 个字符之前插人串 T。 StrDelete(&amp;S,pos,len); //从串 S 中删除第 pos 个字符起长度为 len 的子串。&#125;ADT String 串的存储结构 与线性表类似， 串也有两种基本存储结构：顺序存储和链式存储。但考虑到存储效率和算法的方便性， 串多采用顺序存储结构。 串的顺序存储 类似于线性表的顺序存储结构， 用一组地址连续的存储单元存储串值的字符序列。 按照预定义的大小， 为每个定义的串变量分配一个固定长度的存储区， 则可用定长数组如下描述： 1234567// －－－－－ 串的定长顺序存储结构－－－－－#define MaxLen 255 //串的最大长度typedef struct&#123; char ch[MaxLen]; //存储串的一维数组 int length; //串的当前长度&#125;SString; 这种定义方式是静态的， 在编译时刻就确定了串空间的大小。 而多数情况下， 在操作中串值长度的变化较大， 这样为串变量设定固定大小的空间不合理。 因此最好是根据实际需要， 在程序执行过程中动态地分配和释放字符数组空间。 在C语言中，存在一个称之为 “堆”（Heap） 的自由存储区，并用malloc ()和free ()函数来完成动态存储管理。利用 malloc() 为每个新产生的串分配一块实际串长所需的存储空间，若分配成功,则返回一个指向起始地址的指针，作为串的基地址，这个串由ch 指针来指示；若分配失败，则返回NULL。已分配的空间可用free()释放掉。 123456// －－－－－ 串的堆式顺序存储结构 －－－－－typedef struct&#123; char *ch; //若是非空串， 则按串长分配存储区， 否则 ch 为 NULL int length; //串的当前长度&#125;HString; 串的链式存储 类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。下图(a)是结点大小为4(即每个结点存放4个字符）的链表，图(b)是结点大小为1的链表。 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上 “#” 或其他的非串值字符（通常 “#” 不属于串的字符集，是一个特殊的符号）。 为了便于进行串的操作，当以链表存储串值时，除头指针外， 还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。定义如下： 1234567891011// －－－－－ 串的链式存储结构 －－－－－#define CHUNKSIZE 80 //可由用户定义的块大小typedef struct Chunk&#123; char ch[CHUNKSIZE]; struct Chunk *next;&#125;Chunk;typedef struct&#123; Chunk *head,*tail; //串的头和尾指针 int length; //串的当前长度&#125;LString; 在链式存储方式中，结点大小的选择直接影响着串处理的效率。存储密度小（如结点大小为1时），运算处理方便，然而，存储占用量大。如果在串处理过程中需进行内、 外存交换的话， 则会因为内外存交换操作过多而影响处理的总效率。 应该看到，串的字符集的大小也是一个重要因素。 一般来说，字符集小，则字符的机内编码就短，这也影响串值存储方式的选取。 串的模式匹配算法 子串的定位运算通常称为串的模式匹配或串匹配。此运算的应用非常广泛，比如在搜索引擎、拼写检查、 语言翻译、数据压缩等应用中， 都需要进行串匹配。 串的模式匹配设有两个字符串S和T, 设S为主串，也称正文串；设T为子串，也称为模式串。在主串S中查找与模式T相匹配的子串，如果匹配成功， 确定相匹配的子串中的第一个字符在主串S中出现的位置。 著名的模式匹配算法有BF算法和KMP算法， 下面详细介绍这两种算法。 一、BF算法 最简单直观的模式匹配算法是 BF (Brute-Force) 暴力匹配算法。 模式匹配不一定是从主串的第一个位置开始， 可以指定主串中查找的起始位置 pos。如果采用字符串顺序存储结构， 可以写出不依赖于其他串操作的匹配算法。 BF算法的主要思想为：从主串S的第一个字符起，与模式 T 的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起，重新和模式的字符比较；以此类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为与模式T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为零。 下面展示了模式 T=&quot;abcac&quot;和主串S的匹配过程，每次匹配失败后，都把模式 T 后移一位。 BF算法的步骤如下： 分别利用计数指针 i 和 j 指示主串 S 和模式 T 中当前正待比较的字符位置， i 初值为pos, j 初值为0。 如果两个串均未比较到串尾，即 i 和 j 均分别小于S和T的长度时，则循环执行以下操作： S[i] 和T[i] 比较，若相等，则i和j分别指示串中下个位置， 继续比较后续字符； 若不等，指针后退重新开始匹配， 从主串的下一个字符 (i=i-j+1) 起再重新和模式的第一个字符(j=0) 比较。 如果 j == T.length, 说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号 (i-T.length + 1); 否则称匹配不成功，返回0。 注意：我们上述图片展示的字符串下标是从1开始的，而我们的算法步骤分析和算法实现下标是从0开始的，最后返回值是序号(序号下标从1开始)。若想要返回值为字符串下标，则只需要当匹配成功时，返回 i - T.length ；匹配失败时，返回 -1 即可。 BF算法的代码实现： 1234567891011121314151617int Index_BF(string S,string T,int pos)&#123; int i = pos,j = 0; //在此我们的下标从0开始。 while (j&lt;T.length() &amp;&amp; i&lt;S.length()) &#123; if(S[i] == T[j])&#123; i++; j++; &#125;else&#123; i = i - j + 1; j = 0; &#125; &#125; if(j==T.length())&#123; //说明模式串匹配完了最后一个字符 return i - T.length() + 1; //返回的为匹配首字母在主串中的序号 &#125;else&#123; return 0; &#125;&#125; 最好情况的时间复杂度：每趟不成功的匹配都发生在模式串的第一个字符与主串中相应字符的比较。例如，S=“aaaaaba”，T=“ba”。设主串的长度为n, 子串的长度为m, 假设从主串的第i个位置开始与模式串匹配成功，则在前 i-1 趟匹配中字符总共比较了 i-1 次；若第 i 趟成功的字符比较次数为 m, 则总比较次数为 i - 1 + m。 对于成功匹配的主串， 其起始位置由 1 到 n-m+1, 假定这 n - m+1 个起始位置上的匹配成功概率相等，则最好的情况下匹配成功的平均比较次数为: ∑i=1n−m+1pi(i−1+m)=1n−m+1∑i=1n−m+1i−1+m=12(n+m)\\sum\\limits_{i=1}^{n-m+1}p_i(i-1+m)=\\frac {1} {n-m+1}\\sum\\limits_{i=1}^{n-m+1}i-1+m=\\frac{1}{2}(n+m)i=1∑n−m+1​pi​(i−1+m)=n−m+11​i=1∑n−m+1​i−1+m=21​(n+m) 即最好情况下的平均时间复杂度是 O(n + m)。 最坏情况的时间复杂度：每趟不成功的匹配都发生在模式串的最后一个字符与主串中相应字符的比较。例如，S=“aaaaaab”，T=“aab”。假设从主串的第 i 个位置开始与模式串匹配成功，则在前 i - 1 趟匹配中字符总共比较了 (i-1)*m 次；若第 i 趟成功的字符比较次数为m，则总比较次数 i * m。因此最坏情况下匹配成功的平均比较次数为：∑i=1n−m+1pi(i∗m)=1n−m+1∑i=1n−m+1i∗m=12m∗(n−m+2)\\sum\\limits_{i=1}^{n-m+1}p_i(i*m)=\\frac {1} {n-m+1}\\sum\\limits_{i=1}^{n-m+1}i*m=\\frac{1}{2}m*(n-m+2)i=1∑n−m+1​pi​(i∗m)=n−m+11​i=1∑n−m+1​i∗m=21​m∗(n−m+2) 即最坏情况下的平均时间复杂度是 O(n × m)。 二、KMP算法 这种改进算法是由 Knuth 、 Morris 和 Pratt 同时设计实现的， 因此简称 KMP 算法。 此算法相比于BF(暴力)算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。此算法可以在**O(n + m)**的时间数量级上完成串的模式匹配操作。 那么KMP是如何消除了主串指针的回溯问题呢？ 我们来分析一下下面介绍的情况： 我们可知，在上图中当主串A与模式B发生了失配时，若按照BF算法的执行情况，那么下一次比较时 i 指针会指向下一个元素，即B元素。j 指针会重新回到起点，即模式的A元素。显然这是没有必要的！倘若我们人为的去观测此字符串，那么我们会很自然的去选择让模式串的首位置A元素去匹配主串的第四个A元素。这样就完成了匹配。这便为KMP算法的精华所在。如下图所示： 至此，匹配成功。 由此可以看出，每次匹配失败后模式串移动的距离不一定是 1，某些情况下一次可移动多个位置，这就是 KMP 模式匹配算法。 那么如何判断匹配失败后模式串向后移动的距离呢？ 每次模式匹配失败后，计算模式串向后移动的距离是 KMP 算法中的核心部分。 其实，匹配失败后模式串移动的距离和主串没有关系，只与模式串本身有关系。 例如，我们将前面的模式串 B 改为 “ABCAE”，则在第一次模式匹配失败，由于匹配失败位置模式串中字符 ‘E’ 前面有两个字符 ‘A’，因此，第二次模式匹配应改为如下图所示的位置： 我们可以这样理解：因为模式串B在失配后前面的子串&quot;ABCA&quot;有一个相等的最大前后缀A，故进行下一次匹配时，可跳过此公共的最大前后缀A，直接让模式串的第2个元素B去与主串的下一个字符进行比较。 因此，我们可以给每个模式串配备一个数组（例如 next[]），用于存储模式串中每个字符对应指针 j 重定向的位置（也就是存储模式串的数组下标），比如 j=3，则表示该字符匹配失败后指针 j 指向模式串中第 3 个字符。 补充： 前缀字符串：指的是位于模式串起始位置的字符串，例如模式串 “ABCD”，则 “A”、“AB”、“ABC” 以及 “ABCD” 都属于前缀字符串； 后缀字符串：指的是位于串结尾处的字符串，还拿模式串 “ABCD” 来说，“D”、“CD”、“BCD” 和 “ABCD” 为后缀字符串。 模式串中各字符对应 next 值的计算方式是，取该字符前面的字符串（不包含自己），其前缀字符串和后缀字符串相同字符的最大个数再 +1 就是该字符对应的 next 值。 注意，模式串中第一个字符对应的值为 0，第二个字符对应 1 ，这是固定不变的。 我们给出模式串&quot;ABCAE&quot; 中，各字符对应的 next 值 ： 模式串 A B C A E next[]： 0 1 1 1 2 从上图可以看出，当字符 ‘E’ 匹配失败时，指针 j 指向模式串数组中第 2 个字符，即 ‘B’，同之前讲解的匹配思路不谋而合。 为了加深理解，我们再给出模式串&quot;abaabcac&quot;中，各字符对应的next值： j 1 2 3 4 5 6 7 8 模式串 a b a a b c a c next[j]： 0 1 1 2 2 3 1 2 下面给出KMP算法的代码实现： (1) 代码实现next数组构造。 我们首先明确一点，i 指向的是后缀表达式的末尾位置，j 指向的是前缀表达式的末尾位置。同时，指针j同样也表示现已经匹配的最大前后缀长度。 1234567891011121314151617181920// 通过模式串t获取其next数组void get_next(char *t, int *next)&#123; int i = 0, j = -1; next[0] = -1; while (i &lt; strlen(t)) &#123; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl; if (j == -1 || t[i] == t[j]) &#123; i++; j++; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125;&#125; (2) 代码实现KMP算法。 123456789101112131415161718192021//根据模式串的next数组返回模式串在主串中出现的下标(从0开始),若没有出现返回-1int kmp(char *s,char *t)&#123; int len = strlen(t); int next[len] = &#123;0&#125;; get_next(t, next); int i =0,j=0; int n = strlen(s),m = strlen(t); while (i&lt;n &amp;&amp; j&lt;m) &#123; if(j==-1 || s[i]==t[j])&#123; i++; j++; &#125;else&#123; j = next[j]; &#125; &#125; if(j&gt;=m) return i-j; return -1;&#125; 数组 数组的类型定义 数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受 n(n≥1) 个线性关系的约束，每个元素在 n 个线性关系中的序号i1,i2,…,ini_1,i_2,…,i_ni1​,i2​,…,in​称为该元素的下标，可以通过下标访问该数据元素。因为数组中每个元素处于 n(n≥1) 个关系中，故称该数组为 n 维数组。数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。 一维数组可以看成是一个线性表，二维数组可以看成数据元素是线性表的线性表。下图所示的二维数组可以看成是一个线性表。 数组一旦被定义， 它的维数和维界就不再改变。 因此， 除了结构的初始化和销毁之外， 数组只有存取元素和修改元素值的操作。 抽象数据类型数组可形式地定义为： 1234567891011ADT Array&#123; 数据对象：ji=0,...,bi-1,i=1,2,...,n, D = &#123;aj_1j_2...j_n | n(&gt;0)称为数组的维数，bi是数组第i维的长度， ji是数组元素的第j维的下标，aj_1j_2...j_n∈ElemSet&#125; 数据关系：R=&#123;R1,R2,...,Rn&#125; 基本操作： InitArray(&amp;A,boundi,...,boundn);//若维数n和各维长度合法，则构造相应的数组A,返回OK。 DestroyArray(&amp;A); //销毁数组A。 Value(A,&amp;e,index1,...,indexn);//若各下标不超界,则e赋值为所指定的A的元素值,返回OK。 Assign(&amp;A,e,index1,...,indexn);//若下标不超界,则将e的值赋给所指定的A的元素,返回OK。&#125;ADT Array 数组的顺序存储 由于数组一般不做插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。 因此，采用顺序存储结构表示数组比较合适。 存储方式 说明 图片表示 以列序为主序 假设每个数据元素占 L 个存储单元， 则二维数组 A[0…m-1, 0…n-1] (即下标从 0 开始， 共有m行n列) 中任一元素aija_{ij}aij​的存储位置可由下式确定：Loc(i,j)=Loc(0,0)+(i+j*m)L。 以行序为主序 假设每个数据元素占 L 个存储单元， 则二维数组 A[0…m-1, 0…n-1] (即下标从 0 开始， 共有m行n列) 中任一元素aija_{ij}aij​的存储位置可由下式确定：Loc(i,j)=Loc(0,0)+(n*i+j)L。 LOC(i,j)是aija_{ij}aij​的存储位置；LOC(0, 0) 是 a00a_{00}a00​的存储位置， 即二维数组 A 的起始存储位置，也称为基地址或基址。 特殊矩阵的压缩存储 压缩存储:指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是为了节省存储空间。 特殊矩阵:指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上(下）三角矩阵、对角矩阵等。 特殊矩阵的压缩存储方法:找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。 对称矩阵 若对一个n阶方阵A[ 1…n ] [ 1…n]中的任意一个元素ai,ja_{i,j}ai,j​,都有ai,j=aj,i(1≤i,j≤n)a_{i,j}= a_{j,i} ( 1≤i,j ≤n)ai,j​=aj,i​(1≤i,j≤n)，则称其为对称矩阵。对于一个n阶方阵，其中的元素可以划分为3个部分，即上三角区、主对角线和下三角区，如下图所示。 对于n阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将对称矩阵A [ 1…n ] [ 1…n]存放在一维数组B[n (n+1)/2]中，即元素ai,ja_{i,j}ai,j​存放在bkb_kbk​中。只存放下三角部分(含主对角）的元素。 在数组B中，前面的元素顺序为：a1,1,a2,1,a2,2,a3,1,a3,2,a3,3...a_{1,1},a_{2,1},a_{2,2},a_{3,1},a_{3,2},a_{3,3}...a1,1​,a2,1​,a2,2​,a3,1​,a3,2​,a3,3​... 压缩过后，元素ai,ja_{i,j}ai,j​在数组B中的下标 k=1＋2+…+(i -1)+j-1=i(i-1)/2+j-1(数组下标从0开始)。 因此，元素下标之间的对应关系如下: 对称矩阵的压缩存储代码实现： 12345678910111213141516171819202122232425262728// 将对称矩阵压缩为一维矩阵存储int* compress(int arr[4][4])&#123; int size = sizeof(arr[0]) / sizeof(arr[0][0]); int length = size * (1 + size) / 2; int *a; a = new int[length]; int i = 0; int index = 0; while (i&lt;size) &#123; for(int j=0;j&lt;=i;j++)&#123; a[index++] = arr[i][j]; &#125; i++; &#125; return a;&#125;// 将压缩后的一维数组，转换对应的二维数组的值int transfrom(int arr[],int i,int j)&#123; int k; if(i&gt;=j)&#123;//下对角区和主对角线元素 k = i*(i-1)/2+j-1; &#125;else&#123;//上对角区元素 k = j*(j-1)/2+i-1; &#125; return arr[k];&#125; 三角矩阵 下三角矩阵中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次，故可以将下三角矩阵A[ 1…n ] [ 1…n]压缩存储在B[n(n+1)/2+1]中。 上三角矩阵中，下三角区的所有元素均为同一常量。只需存储主对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储在B[n(n+1)/2+1]中。 矩阵类型 元素下标对应关系 内存中压缩存储形式 下三角矩阵 上三角矩阵 下面以下三角矩阵压缩存储为例，给出代码实现： 1234567891011121314151617181920212223242526272829303132// 将三角矩阵压缩为一维矩阵存储int *compress(int arr[4][4])&#123; int size = sizeof(arr[0]) / sizeof(arr[0][0]); int length = size * (1 + size) / 2; int *a; a = new int[length + 1]; int i = 0; int index = 0; while (i &lt; size) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[index++] = arr[i][j]; &#125; i++; &#125; a[length] = 0; return a;&#125;// 将压缩后的一维数组，转换对应的二维数组的值int transfrom(int arr[],int i,int j)&#123; int k; int n = 4; if(i&gt;=j)&#123;//下对角区和主对角线元素 k = i*(i-1)/2+j-1; &#125;else&#123;//上对角区元素 k = n*(n+1)/2; &#125; return arr[k];&#125; 三对角矩阵 三对角矩阵也称带状矩阵。对于n阶方阵A中的任一元素ai,ja_{i,j}ai,j​，当∣i−j∣&gt;1|i -j|&gt;1∣i−j∣&gt;1时，有ai,j=0(1≤i,j≤n)a_{i,j}=0 (1≤i, j ≤n)ai,j​=0(1≤i,j≤n)，则称为三对角矩阵，如下图所示。在三对角矩阵中，所有非零元素都集中在以主对角线为中心的3条对角线的区域，其他区域的元素都为零。 三对角矩阵A也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且 a1,1a_{1,1}a1,1​存放于B[0]中，其存储形式如下图所示。 由此可以计算矩阵A中3条对角线上的元素ai,j(1≤i,j≤n,∣i一j∣≤1)a_{i,j}(1≤i, j≤n,|i一 j|≤1)ai,j​(1≤i,j≤n,∣i一j∣≤1)在一维数组B中存放的下标为k=2i+j−3k= 2i+j-3k=2i+j−3。 反之,若已知三对角线矩阵中某元素ai,ja_{i,j}ai,j​存放于一维数组B的第k个位置,则可得i=[(k+1)/3+1],j=k–2i+3i=[(k+1)/3+1],j=k –2i+3i=[(k+1)/3+1],j=k–2i+3。 稀疏矩阵 矩阵中非零元素的个数t，相对矩阵元素的个数s来说非常少，即s&gt;&gt;t的矩阵称为稀疏矩阵。例如，一个矩阵的阶为100×100，该矩阵中只有少于100个非零元素。 若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元组(行标，列标，值)，如下图所示。然后再按照某种规律存储这些三元组。稀疏矩阵压缩存储后便失去了随机存取特性。 稀疏矩阵的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536void compress(int arr[5][4], int row, int col)&#123; int num = 0; //用于统计数组中不为0的个数 for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(arr[i][j]!=0)&#123; num++; &#125; &#125; &#125; int sparse[num+1][3]; //定义稀疏数组 //系数数组的第一行记录 行号，列号，总共元素个数 sparse[0][0] = row; sparse[0][1] = col; sparse[0][2] = num; int n = 1; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(arr[i][j]!=0)&#123; sparse[n][0] = i; sparse[n][1] = j; sparse[n][2] = arr[i][j]; n++; &#125; &#125; &#125; cout&lt;&lt;&quot;After the matrix is compressed: &quot;&lt;&lt;endl; for(int i=0;i&lt;num+1;i++)&#123; for(int j=0;j&lt;3;j++)&#123; cout&lt;&lt;sparse[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 稀疏矩阵的三元组既可以采用数组存储，也可以采用十字链表法存储。 广义表 广义表的定义 顾名思义，广义表是线性表的推广，也称为列表。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。 广义表一般记作：LS=(a1,a2,...,an)LS=(a_1,a_2,...,a_n)LS=(a1​,a2​,...,an​) 广义表的存储结构","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"跟Alon学数据结构(入门)-第3章 栈和队列","slug":"跟Alon学数据结构(入门)-第3章 栈和队列","date":"2021-08-24T05:43:35.000Z","updated":"2021-10-05T07:57:23.492Z","comments":true,"path":"2021/08/24/跟Alon学数据结构(入门)-第3章 栈和队列/","link":"","permalink":"https://alonscholar.github.io/2021/08/24/%E8%B7%9FAlon%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%85%A5%E9%97%A8)-%E7%AC%AC3%E7%AB%A0%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"栈和队列 栈和队列是两种重要的线性结构。从数据结构角度看， 栈和队列也是线性表， 其特殊性在于栈和队列的基本操作是线性表操作的子集， 它们是操作受限的线性表， 因此， 可称为限定性的数据结构。但从数据类型角度看，它们是和线性表不相同的两类重要的抽象数据类型。 栈和队列的定义和特点 栈的定义和特点 栈(Stack)是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作，如下图所示。 栈顶(Top)。 线性表允许进行插入删除的那一端。 表尾端。 栈底(Bottom)。固定的，不允许进行插入和删除的另一端。 表头端。 空栈。不含任何元素的空表。 假设某个栈S=(a1,a2,a3,a4,a5)S=(a_1,a_2, a_3,a_4,a_5)S=(a1​,a2​,a3​,a4​,a5​),如上图所示，则 a1a_1a1​为栈底元素，a5a_5a5​为栈顶元素。由于栈只能在栈顶进行插入和删除操作，进栈次序依次为a1,a2,a3,a4,a5a_1,a_2, a_3,a_4,a_5a1​,a2​,a3​,a4​,a5​,而出栈次序为a5,a4,a3,a2,a1a_5,a_4, a_3,a_2,a_1a5​,a4​,a3​,a2​,a1​。由此可见，栈的操作特性可以明显地概括为后进先出(Last In First Out，LIFO)。 栈的数学性质: n个不同元素进栈，出栈元素不同排列的个数为1n+1C2nn\\frac {1} {n+1}C{^n_{2n}}n+11​C2nn​。上述公式称为卡特兰(Catalan)数，可采用数学归纳法证明，有兴趣的读者可以参考组合数学教材。 队列的定义和特点 队列(Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队;删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（First In First Out，FIFO)，如下图所示。 队头 (Front)。允许删除的一端，又称队首。 队尾 (Rear)。允许插入的一端。 空队列。不含任何元素的空表。 假设队列为 q=(a1,a2,a3,a4,a5)q=(a_1,a_2,a_3,a_4,a_5)q=(a1​,a2​,a3​,a4​,a5​) 。那么，a1a_1a1​ 就是队头元素， a5a_5a5​则是队尾元素。队列中的元素是按照a1,a2,a3,a4,a5a_1,a_2,a_3,a_4,a_5a1​,a2​,a3​,a4​,a5​的顺序进入的，退出队列也只能按照这个次序依次退出。 栈的表示和操作的实现 栈的类型定义 栈的基本操作除了入栈和出栈外， 还有栈的初始化、 栈空的判定，以及取栈顶元素等。下面给出栈的抽象数据类型定义： 123456789101112131415ADT Stack&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 约定an端为栈顶，a1端为栈底。 基本操作： InitStack(&amp;S); //初始化一个空栈S。 DestroyStack(&amp;S); //销毁栈，并释放栈s占用的存储空间(”&amp;”表示引用调用)。 ClearStack(&amp;S); //将S清为空栈。 StackEmpty(S); //判断一个栈是否为空，若栈S为空则返回true,否则返回false。 StackLength(S); //返回S的元素个数，即栈的长度。 GetTop(S, &amp;x); //读栈顶元素，若栈s非空，则用x返回栈顶元素。 Push(&amp;S,x); //进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;S,&amp;x); //出栈，若栈S非空，则弹出栈顶元素，并用x返回。 StackTraverse(S); //从栈底到栈顶依次对S的每个数据元素进行访问。 &#125;ADT Stack 顺序栈的表示和实现 采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。 顺序栈的定义如下： 1234567// －－－－－ 顺序栈的存储结构－ －－－－#define MAXSIZE 100 //定义栈中元素的最大个数typedef char SElemType; typedef struct &#123; SElemType data[MAXSIZE]; //存放栈中元素 int top; //栈顶指针&#125;SqStack; 下图所示为顺序栈中数据元素和栈指针之间的对应关系。 栈顶指针: S.top，初始时设置S.top=-1; 栈顶元素:S.data[S.top]。 进栈操作: 栈不满时，栈顶指针先加1，再送值到栈顶元素。 出栈操作: 栈非空时，先取栈顶元素值，再将栈顶指针减1。 栈空条件: S.top==-1; 栈满条件: S.top==MAXSIZE-1; 栈长:S.top+1。 下面是顺序栈常用的基本操作的实现。 一、顺序栈的初始化 为顺序栈分配一个最大容量为MAXSIZE的数组空间。 栈顶指针初始为-1，表示栈空。 123void InitStack(SqStack &amp;S)&#123; S.top = -1; //初始化栈顶指针&#125; 二、顺序栈判栈空、栈满 当top指针指向-1时，栈为空。 当top指针指向MAXSIZE-1时，栈为满。因为数组下标从0开始。 123456bool StackEmpty(SqStack S)&#123; return S.top == -1;&#125;bool StackFull(SqStack S)&#123; return S.top == MAXSIZE-1;&#125; 三、顺序栈的入栈 判断栈是否满， 若满则返回false。 栈顶指针加1，将新元素压入栈顶。 12345678bool Push(SqStack &amp;S,SElemType e)&#123; if(StackFull(S))&#123; //栈满则返回false return false; &#125;else&#123; S.data[++S.top] = e; //栈顶指针先+1，再将新元素e压入栈顶 return true; &#125;&#125; 四、顺序栈的出栈 判断栈是否空，若空则返回false。 栈顶元素出栈，栈顶指针减1。 12345678bool Pop(SqStack &amp;S,SElemType &amp;e)&#123; if(StackEmpty(S))&#123;//栈空 return false; &#125;else&#123; e = S.data[S.top--]; //栈顶元素赋给e，栈顶指针减1。 return true; &#125;&#125; 五、取顺序栈的栈顶元素 判断栈是否空，若空则返回false。 因为栈顶指针指向的就是栈顶元素的位置，所以返回S.data[S.top]的元素即可。 1234567bool GetTop(SqStack S,SElemType &amp;e)&#123; if(!StackEmpty(S))&#123; //若栈非空 e = S.data[S.top]; return true; &#125; return false; //栈空&#125; 链栈的表示和实现 采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead 指向栈顶元素，如下图所示。 链栈的定义如下： 123456// －－－－－ 链栈的存储结构－－－－－typedef char SElemType;typedef struct StackNode&#123; SElemType data; //数据域 struct StackNode *next; //指针域&#125;StackNode,*LinkStack; 由于栈的主要操作是在栈顶插入和删除， 显然以链表的头部作为栈顶是最方便的， 而且没必要像单链表那样为了操作方便附加一个头结点。 下面给出链栈部分操作的实现。 一、链栈的初始化 链栈的初始化操作就是构造一个空栈， 因为没必要设头结点，所以直接将栈顶指针置空即可。 123void InitStack(LinkStack &amp;S)&#123; S=NULL; //栈顶指针置空&#125; 二、链栈的入栈 为入栈元素 e 分配空间， 用指针 p 指向。 将新结点数据域置为e。 将新结点插入栈顶。 修改栈顶指针为 p。 123456void Push(LinkStack &amp;S,SElemType e)&#123; StackNode *p = new StackNode; //生成新结点 p-&gt;data = e; //将新结点数据域置为e p-&gt;next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p&#125; 链栈入栈过程如下图所示： 三、链栈的出栈 判断栈是否为空 ，若空则返回false。 将栈顶元素赋给e。 临时保存栈顶元素的空间，以备释放。 修改栈顶指针，指向新的栈顶元素。 释放原栈顶元素的空间。 12345678bool Pop(LinkStack &amp;S,SElemType &amp;e)&#123; if(S==NULL) return false; //栈空 e = S-&gt;data; //将栈顶元素赋给 e StackNode *p = S; //用 p 临时保存栈顶元素空间,以备释放 S = S-&gt;next; //修改栈顶指针 free(p); //释放原栈顶元素的空间 return true;&#125; 链栈的出栈过程如下图所示： 四、取链栈的栈顶元素 判断栈是否为空，若空则返回false。 返回栈顶指针S指向的值，用e进行保存。 1234567bool GetTop(LinkStack S,SElemType &amp;e)&#123; if(S!=NULL)&#123; //栈非空 e = S-&gt;data; //返回栈顶元素的值，栈顶指针不变 return true; &#125; return false;&#125; 共享栈 利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示。 两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空；仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满。当0号栈进栈时top0 先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时则刚好相反。 共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。其存取数据的时间复杂度均为O(1)，所以对存取效率没有什么影响。 队列的表示和操作的实现 队列的类型定义 队列的操作与栈的操作类似，不同的是，删除是在表的头部（即队头）进行。 下面给出队列的抽象数据类型定义： 123456789101112131415ADT Queue&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 约定a1端为队列头，an端为队列尾。 基本操作： InitQueue(&amp;Q); //初始化队列,构造一个空队列Q。 DestroyQueue(&amp;Q); //销毁队列。 ClearQueue(&amp;Q); //将Q清为空队列。 QueueEmpty(Q); //判队列空，若队列Q为空返回true，否则返回false。 QueueLength(Q); //返回Q的元素个数，即队列的长度。 GetHead(Q,&amp;x); //读队头元素，若队列Q非空，则将队头元素赋值给x。 EnQueue(&amp;Q,x); //入队，若队列Q未满，将x加入，使之成为新的队尾。 DeQueue(&amp;Q,&amp;x); //出队，若队列Q非空，删除队头元素，并用x返回。 QueueTraverse(Q); //从队头到队尾，依次对Q的每个数据元素访问。 &#125;ADT Queue 循环队列—队列的顺序表示和实现 和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变量 front 和 rear 分别指示队列头元素及队列尾元素的位置（后面分别称为头指针和尾指针）。 队列的顺序存储结构表示如下： 1234567// －－－－－ 队列的顺序存储结构－ －－－－#define MAXSIZE 100 //队列可能达到的最大长度typedef char QElemType;typedef struct &#123; QElemType data[MAXSIZE]; //存放队列元素 int front,rear; //队头指针和队尾指针&#125;SqQueue; 在此约定：初始化创建空队列时，令 front = rear = 0 , 每当插入新的队列尾元素时，尾指针 rear 增1; 每当删除队列头元素时，头指针 front 增1。因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置，如下图所示。 初始状态（队空条件): Q.front == Q.rear == 0。 进队操作: 队不满时，先送值到队尾元素，再将队尾指针加1。 出队操作: 队不空时，先取队头元素值，再将队头指针加1。 思考： 能否用Q.rear==MAXSIZE作为队列满的条件呢? 答：显然不能，如上图(d)所示，队列中仅有两个元素，但仍满足该条件。这时候入队出现“上溢出” ，但这种溢出并不是真正的溢出，在data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。 怎么解决这种 “假溢出” 问题呢？一个巧妙的办法就是将顺序队列变为一个环状的空间，如下图所示，称之为循环队列。 初始时: Q.front = Q.rear = 0。 队首指针进1: Q.front = (Q.front+1)%MAXSIZE。 队尾指针进1: Q.rear = (Q.rear+1 )%MAXSIZE。 队列长度: (Q.rear+MAXSIZE-Q.front ) %MAXSIZE。 新问题： 循环队列队空和队满的判断条件是什么呢？因为队空条件是 Q.front == Q.rear 。而且当入队时有可能出现上图(d)的情况，此时也有Q.front == Q.rear。 那么如何区别队满还是队空呢？ 为了区分队空还是队满的情况，给出三种处理方式进行参考： 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队头指针在队尾指针的下一位置作为队满的标志”，如上图(d2)所示。 此时队满条件为： (Q.rear+1) %MAXSIZE == Q.front。队空条件仍为： Q.front == Q.rear。 类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size == 0；队满的条件为Q.size == MAXSIZE。这两种情况都有 Q.front == Q.rear。 类型中增设 tag 数据成员，以区分是队满还是队空。tag 等于0时，若因删除导致Q.front == Q.rear，则为队空; tag等于1时，若因插入导致Q.front == Q.rear，则为队满。 下面给出用第一种方法实现循环队列的操作。 一、循环队列的初始化 为队列分配一个最大容量为MAXSIZE的数组空间。 头指针和尾指针置为零， 表示队列为空。 123void InitQueue(SqQueue &amp;Q)&#123; Q.front = Q.rear = 0; //头指针和尾指针置为零， 队列为空&#125; 二、求循环队列的长度 对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列，差值可能为负数，所以需要将差值加上MAXSIZE, 然后与MAXSIZE求余。 123int QueueLength(SqQueue Q)&#123; return (Q.rear - Q.front + MAXSIZE)%MAXSIZE;&#125; 三、循环队列的入队 判断队列是否满，若满则返回false。 将新元素插入队尾。 队尾指针加1。 1234567bool EnQueue(SqQueue &amp;Q, QElemType e)&#123; if ((Q.rear + 1) % MAXSIZE == Q.front) //尾指针在循环意义上加1后等于头指针,表明队满 return false; Q.data[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear+1) % MAXSIZE; //队尾指针加1 return true;&#125; 四、循环队列的出队 判断队列是否为空， 若空则返回false。 保存队头元素。 队头指针加1。 123456bool DeQueue(SqQueue &amp;Q, QElemType &amp;e)&#123; if (Q.front == Q.rear) return false; //队空 e = Q.data[Q.front]; //保存队头元素 Q.front = (Q.front+1) % MAXSIZE; //队头指针加1 return true;&#125; 五、取循环队列的队头元素 判断队列是否为空， 若空则返回false。 返回队头元素。 1234567bool GetHead(SqQueue Q,QElemType &amp;e)&#123; if(Q.front == Q.rear)&#123; //队列空，返回false return false; &#125; e = Q.data[Q.front]; //队列非空，返回队头元素的值 return true;&#125; 链队—队列的链式表示和实现 队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同)。队列的链式存储如下图所示。 这里和线性表的单链表一样， 为了操作方便起见，给链队添加一个头结点， 并令头指针始终指向头结点。队列的链式存储结构表示如下： 123456789// －－－－－ 队列的链式存储结构－－－－－typedef char QElemType;typedef struct QNode&#123; //链式队列结点 QElemType data; struct QNode *next;&#125;QNode;typedef struct&#123; //链式队列 struct QNode *front,*rear; //队列的队头和队尾指针&#125;LinkQueue; 链队的操作即为单链表插入和删除操作的特殊情况， 只是需进一步修改尾指针或头指针。下面给出链队初始化、 入队、 出队等操作的实现。 链队的基本操作实现如下。 一、链队的初始化 生成新结点作为头结点， 队头和队尾指针指向此结点。 头结点的指针域置空。 1234void InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front-&gt;next = NULL; //头结点的指针域置空&#125; 二、链队的入队 为入队元素分配结点空间，用指针p指向。 将新结点数据域置为e。 将新结点插入到队尾 。 修改队尾指针为p。 1234567void EnQueue(LinkQueue &amp;Q,QElemType e)&#123; QNode *p = new QNode; //为入队元素分配结点空间，用指针p指向 p-&gt;data = e; //将新结点数据域置为e p-&gt;next = NULL; //将新结点插入到队尾 Q.rear-&gt;next = p; Q.rear = p;&#125; 链队的入队即为普通单链表的尾插法，可理解为向尾部插入一个元素，这里不再画图阐述，请读者自行脑补。 三、链队的出队 判断队列是否为空，若空则返回false。 临时保存队头元素的空间，以备释放。 修改队头指针，指向下一个结点。 判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值， 指向头结点。 释放原队头元素的空间。 123456789bool DeQueue(LinkQueue &amp;Q,QElemType &amp;e)&#123; if(Q.front==Q.rear) return false; //队列空,返回false QNode *p = Q.front-&gt;next; //p指向队头元素 e = p-&gt;data; Q.front-&gt;next = p-&gt;next; //修改头指针 if(Q.rear == p) Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点 free(p); return true;&#125; 链队的出队可理解为从单链表中将第一个元素(首元结点)删除的过程，值得注意的是，链队出队操作时还要考虑当队列中最后一个元素被删后，队列尾指针也丢失了，因此需对队尾指针重新赋值（指向头结点）。 四、取链队的队头元素 判断队列是否为空，若空则返回false。 返回队头元素。 12345bool GetHead(LinkQueue Q,QElemType &amp;e)&#123; if(Q.front==Q.rear) return false; //队列空,返回false e = Q.front-&gt;next-&gt;data; //返回队头元素的值，队头指针不变 return true;&#125; 双端队列 双端队列是指允许两端都可以进行入队和出队操作的队列，如下图所示。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。 在双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。 输出受限的双端队列 ：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列，如下图所示。 输入受限的双端队列 ：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列,如下图所示。 若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。 栈和队列的实际应用 栈在进制转换中的应用 想一下，我们在十进制转为其他进制的时候的做法，除取余数法，大致过程如下图所示： 每次除以进制d，然后取余，最后将余数从下至上排列即为d进制数。这刚好符合了栈的特性，每次将取余的数入栈，最后依次出栈，这样刚好将取余的数反过来输出了，这样就实现了十进制转换为d进制数。在这里我们简单实现一个十进制转八进制的函数： 123456789101112void Conversion(int N)&#123; //对于任意一个非负十进制数，打印输出与其等值的八进制数 stack&lt;int&gt; stack; //这里采用c++内置的栈。 while (N)&#123; stack.push(N%8); N/=8; &#125; while (!stack.empty())&#123; cout&lt;&lt;stack.top()&lt;&lt;&quot; &quot;; stack.pop(); &#125;&#125; 显然， 该算法的时间和空间复杂度均为 O(log8n)O(log_8n)O(log8​n)。 栈在括号匹配中的应用 假设表达式中允许包含两种括号:圆括号和方括号，其嵌套的顺序任意即 ([]())( []( ) )([]()) 或 [([][])][([][])][([][])] 等均为正确的格式，[)])[)])[)])或 ([())([())([()) 或 (()](()](()] 均为不正确的格式。 考虑下列括号序列： 分析： 计算机接收第1个括号 “[” 后，期待与之匹配的第8个括号 “]” 出现。 获得了第2个括号 “(”，此时第1个括号 “[” 暂时放在一边，而急迫期待与之匹配的第7个括号 “)” 出现。 获得了第3个括号 “[”，此时第2个括号 “(” 暂时放在一边，而急迫期待与之匹配的第4个括号 “]” 出现。第3个括号的期待得到满足，消解之后，第2个括号的期待匹配又成为当前最急迫的任务。 以此类推，可见该处理过程与栈的思想吻合。 实现括号匹配的算法的思想如下： 初始设置一个空栈，顺序读入括号。 若是左括号直接入栈。 如果是右括号，则分为如下几种情况： 栈空，表明没有可以和这个右括号匹配的元素，返回false。 栈不空，从栈中弹出元素，查看弹出括号是否与该右括号匹配。若不匹配，则返回false。 最后，判断栈是否为空，若栈不空表明栈中还有左括号未得到匹配，返回false，若栈空，表明所有括号都得到了匹配，返回true。 123456789101112131415161718192021// 匹配括号bool Matching(char str[])&#123; stack&lt;char&gt; S; //初始化栈 char val; //用于记录栈中弹出的元素。 for (int i = 0; i &lt; strlen(str); i++)&#123; //遍历字符串 if (str[i] == &#x27;(&#x27; || str[i] == &#x27;[&#x27; || str[i] == &#x27;&#123;&#x27;)&#123; //遇到左括号直接入栈 S.push(str[i]); &#125; else&#123; if (S.empty())&#123; // 如果不是左括号，并且此时栈中没有可以和右括号匹配的元素，则匹配失败 return false; &#125; val = S.top(); S.pop(); if ((str[i] == &#x27;)&#x27; &amp;&amp; val != &#x27;(&#x27;) || (str[i] == &#x27;]&#x27; &amp;&amp; val != &#x27;[&#x27;) || (str[i] == &#x27;&#125;&#x27; &amp;&amp; val != &#x27;&#123;&#x27;)) return false; //匹配失败，返回false &#125; &#125; //最后，倘若循环走完了，栈中还有左括号没有匹配成功，则说明不符合 return S.empty();&#125; 此算法的时间复杂度与空间复杂度均取决于字符串的长度，所以都为O(n)。 栈在表达式求值中的应用 表达式求值是程序设计语言编译中一个最基本的问题，它的实现是栈应用的一个典型范例。中缀表达式不仅依赖运算符的优先级，而且还要处理括号。后缀表达式的运算符在操作数后面，在后缀表达式中已考虑了运算符的优先级，没有括号，只有操作数和运算符。中缀表达式 A+B∗(C−D)−E/FA+B * (C-D)-E/FA+B∗(C−D)−E/F 所对应的后缀表达式为 ABCD−∗+EF/−ABCD-*+EF/-ABCD−∗+EF/−。 通过后缀表示计算表达式值的过程: 顺序扫描表达式的每一项，然后根据它的类型做如下相应操作:若该项是操作数，则将其压入栈中；若该项是操作符&lt;op&gt;&lt;op&gt;&lt;op&gt;,则连续从栈中退出两个操作数 Y 和 X ，形成运算指令X&lt;op&gt;YX&lt;op&gt;YX&lt;op&gt;Y，并将计算结果重新压入栈中。当表达式的所有项都扫描并处理完后,栈顶存放的就是最后的计算结果。 下面给出后缀表达式 ABCD−∗+EF/−ABCD-*+EF/-ABCD−∗+EF/− 通过栈求值的过程。 注意：在上图中，当遇到操作运算符时，设先出栈的数为A，后出栈的数为B，在A与B进行运算时，应为 B&lt;op&gt;AB &lt;op&gt; AB&lt;op&gt;A。 由以上分析我们可以得知，当我们知道一个中缀表达式对应的后缀表达式之后，表达式求值的过程就会变的十分简单。所以我们接下来主要讨论的问题就是如何将中缀表达式转换成后缀表达式。 我们给出中缀表达式转换为后缀表达式的具体步骤： 扫描中缀表达式，遇到操作数。直接加入后缀表达式（输出或者使用数组存储都可以）。 遇到运算符或界限符，若栈空则直接入栈。否则分为以下两种情况： 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 &quot; ( &quot; 或者栈空则停止。之后再把当前运算符入栈。 遇到界限符。遇到 &quot; ( &quot; 直接入栈；遇到 &quot; ) &quot; 则依次弹出栈内的运算符并加入后缀表达式，直到弹出 &quot; ( &quot; 为止。注意：&quot; ( &quot; 直接弹出即可，不需要加入后缀表达式。 按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。 我们给出中缀表达式转换为后缀表达式的代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465string expression; //用于输入中缀表达式stack&lt;char&gt; op_stack; //用于存储运算符的栈vector&lt;string&gt; suffix_vec; //用于存储后缀表达式//获取两个符号的优先级，返回1表示op1的优先级大于等于op2，返回0表示op1小于op2int GetPriority(char op1,char op2)&#123; if(op1==&#x27;*&#x27; || op1==&#x27;/&#x27;) return 1; else if(op1==&#x27;+&#x27;||op1==&#x27;-&#x27;)&#123; if(op2==&#x27;*&#x27; || op2==&#x27;/&#x27;)&#123; return 0; &#125;else if(op2==&#x27;+&#x27;||op2==&#x27;-&#x27;)&#123; return 1; &#125; &#125; return -1; //其他字符不合法，返回-1&#125;//中缀转后缀表达式void InfixToSuffix(string s)&#123; string num = &quot;&quot;; //用于拼接多位数 string op =&quot;&quot;; //用于转换字符类型的操作符 for(int i=0;i&lt;s.length();i++)&#123; if(s[i]&gt;=&#x27;0&#x27; &amp;&amp; s[i]&lt;=&#x27;9&#x27;)&#123;//遇到操作数。直接加入后缀表达式 num+=s[i]; //先进行多位数的拼接处理 if(i == s.length()-1 || s[i+1]&lt;&#x27;0&#x27; || s[i+1]&gt;&#x27;9&#x27;)&#123; suffix_vec.push_back(num); num = &quot;&quot;; &#125; &#125;else if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27; || s[i]==&#x27;*&#x27; || s[i]==&#x27;/&#x27; || s[i]==&#x27;(&#x27; || s[i]==&#x27;)&#x27;)&#123; if(op_stack.empty())&#123;//栈空则直接入栈 op_stack.push(s[i]); &#125;else&#123; if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27; || s[i]==&#x27;*&#x27; || s[i]==&#x27;/&#x27;)&#123;//遇到运算符,依次弹出栈中优先级高于或等于当前运算符的所有运算符 while (!op_stack.empty() &amp;&amp; op_stack.top()!=&#x27;(&#x27; &amp;&amp; GetPriority(op_stack.top(),s[i])==1)&#123;//若碰到 &quot;(&quot; 或者栈空则停止 op = op_stack.top(); suffix_vec.push_back(op); //将运算符转换为string op_stack.pop(); &#125; op_stack.push(s[i]);//之后再把当前运算符入栈 &#125;else&#123; if(s[i]==&#x27;(&#x27;)&#123; op_stack.push(s[i]); &#125;else&#123;// s[i] == &#x27;)&#x27; , 依次弹出栈内的运算符并加入后缀表达式，直到弹出 &quot;(&quot; 为止。 while (op_stack.top()!=&#x27;(&#x27;)&#123;//直到弹出 &quot; ( &quot; 为止。 op = op_stack.top(); op_stack.pop(); suffix_vec.push_back(op); //将运算符转换为string &#125; op_stack.pop(); //将 ( 出栈 &#125; &#125; &#125; &#125;else&#123; cout&lt;&lt;&quot;输入表达式格式错误&quot;&lt;&lt;endl; break; &#125; &#125; //将最终栈中的运算符输出 while (!op_stack.empty())&#123; op = op_stack.top(); op_stack.pop(); suffix_vec.push_back(op); //将运算符转换为string &#125;&#125; 注意：在上述代码中，其中得到的后缀表达式使用了vector类型的容器进行存放，并且进行了一个多位数拼接的处理。拼接多位数的思想即为：先将扫描到的数字保存，不立即存储至后缀表达式，而是直到扫描到的数字的下一个字符是运算符（说明此时这个数字已经处理完毕），才加入后缀表达式。 在得到了后缀表达式之后，我们只需要根据我们之前分析的思路，扫描后缀表达式，并通过一个栈来存储计算结果。每当遇到操作符便从栈中弹出两个运算数，进行求值后再入栈，最后栈顶元素即为最终表达式的值，编码如下： 1234567891011121314151617181920212223242526int GetValue(int x,int y,string op)&#123; int res; if(op==&quot;+&quot;) res = x+y; else if (op==&quot;-&quot;) res= x-y; else if (op==&quot;*&quot;) res= x*y; else if (op==&quot;/&quot;) res= x/y; return res;&#125;//通过得到的后缀表达式进行求值void Calculator()&#123; stack&lt;int&gt; s; for(auto it=suffix_vec.begin();it != suffix_vec.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; //将存储的后缀表达式进行输出 if(*it==&quot;+&quot;||*it==&quot;-&quot;||*it==&quot;*&quot;||*it==&quot;/&quot;)&#123; int a = s.top(); s.pop(); int b = s.top(); s.pop(); int val = GetValue(b,a,*it); //从栈中弹出两个数字进行运算 s.push(val); //将运算结果入栈 &#125;else&#123;//如果是数字则直接入栈 int num = stoi(*it); //将string转换为int s.push(num); &#125; &#125; cout&lt;&lt;endl&lt;&lt;s.top()&lt;&lt;endl; //输出最后结果&#125; 栈在递归中的应用 递归是一种重要的程序设计方法。简单地说，若在一个函数、过程或数据结构的定义中又应用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。 它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。但在通常情况下，它的效率并不是太高。 我们以斐波那契数列为例，其定义为 ： 这就是递归的一个典型例子，用程序实现时如下: 123456789int Fib(int n)&#123; if(n==0) return 0; else if(n==1) return 1; else return Fib(n-1) + Fib(n-2);&#125;//我们输出前十项：0 1 1 2 3 5 8 13 21 34 必须注意递归模型不能是循环定义的，其必须满足下面的两个条件: 递归表达式（递归体）。 边界条件（递归出口）。 在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很多重复的计算。下面以n=5为例，列出递归调用执行过程，如下图所示。 显然，在递归调用的过程中，Fib(3)被计算了2次，Fib(2)被计算了3次。Fib(1)被调用了5次，Fib(0)被调用了3次。所以，递归的效率低下，但优点是代码简单，容易理解。可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。 队列在层次遍历中的应用 在信息处理中有一大类问题需要逐层或逐行处理。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，待当前层或当前行处理完毕，就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。下面用二叉树层次遍历的例子，说明队列的应用。 该过程的简单描述如下: 根结点入队。 若队空（所有结点都已处理完毕)，则结束遍历；否则重复步骤3。 队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子, 则将右孩子入队，返回步骤2。 队列在计算机系统中的应用 队列在计算机系统中的应用非常广泛，以下仅从两个方面来简述队列在计算机系统中的作用:第一个方面是解决主机与外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。 对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，由于速度不匹配，若直接把输出的数据送给打印机打印显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。 对于第二个方面，CPU(即中央处理器，它包括运算器和控制器）资源的竞争就是一个典型的例子。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把 CPU分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又使CPU能够正常运行。 栈和队列的比较","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"跟Alon学数据结构(入门)-第2章 线性表","slug":"跟Alon学数据结构(入门)-第2章 线性表","date":"2021-08-23T02:43:35.000Z","updated":"2021-10-05T07:56:55.794Z","comments":true,"path":"2021/08/23/跟Alon学数据结构(入门)-第2章 线性表/","link":"","permalink":"https://alonscholar.github.io/2021/08/23/%E8%B7%9FAlon%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%85%A5%E9%97%A8)-%E7%AC%AC2%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表 线性表、栈、队列、串和数组都属于线性结构。 线性结构的基本特点是除第一个元素无直接前驱，最后一个元素无直接后继之外，其他每个数据元素都有一个前驱和后继。线性表是最基本且最常用的一种线性结构， 同时也是其他数据结构的基础， 尤其单链表，是贯穿整个数据结构课程的基本技术。 线性表的定义和特点 线性表：由n(n≥0)n(n≥0)n(n≥0)个数据特性相同的元素构成的有限序列。 空表：线性表中元素个数为0时，称为空表。 对于非空的线性表或线性结构， 其特点是： 存在唯一的一个被称作 ＂第一个＂ 的数据元素； 存在唯一的一个被称作＂ 最后一个＂ 的数据元素； 除第一个之外， 结构中的每个数据元素均只有一个前驱； 除最后一个之外，结构中的每个数据元素均只有一个后继。 线性表的类型定义 线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，而且可以进行插入和删除等操作。下面给出线性表的抽象数据类型定义： 123456789101112131415ADT List&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n&gt;=0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 基本操作： InitList(&amp;L); //初始化表。构造一个空的线性表L，分配内存空间。 DestroyList(&amp;L); //销毁操作。销毁线性表，并释放线性表L所占用的内存空间。 ClearList(&amp;L); //清空操作。将L重置为空表。 ListInsert(&amp;L,i,e); //插入操作。在表L中的第i个位置上插入指定元素e。 ListDelete(&amp;L,i,&amp;e); //删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。 LocateElem(L,e); //按值查找操作。在表L中查找具有给定关键字值的元素。 GetE1em(L,i); //按位查找操作。获取表L中第i个位置的元素的值。 Length(L); //求表长。返回线性表L的长度，即L中数据元素的个数。 PrintList(L); //输出操作。按前后顺序输出线性表L的所有元素值。 Empty(L); //判空操作。若L为空表，则返回true，否则返回false。&#125;ADT List 注： 抽象数据类型仅是一个模型的定义，并不涉及模型的具体实现，因此这里描述中所涉及的参数不必考虑具体数据类型。在实际应用中，数据元素可能有多种类型，到时可根据具体需要选择使用不同的数据类型。 上述抽象数据类型中给出的操作只是基本操作，由这些基本操作可以构成其他较复杂的操作。 对于不同的应用， 基本操作的接口可能不同。 由抽象数据类型定义的线性表， 可以根据实际所采用的存储结构形式， 进行具体的表示和实现。 线性表的顺序表示和实现 线性表的顺序存储表示 线性表的顺序存储又称顺序表。 顺序存储表示 ： 用一组地址连续的存储单元依次存储线性表中的数据元素（这种表示也称作线性表的顺序存储结构或顺序映像），从而使得逻辑上相邻的两个元素在物理位置上也相邻。 假设线性表L存储的起始位置为LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如下图所示： 注意：线性表中的元素的位序是从1开始的，而数组中元素的下标是从0开始的。 线性表的顺序存储结构是一种随机存取的存储结构，即通过首地址和元素序号可以在O(1) 时间内找到指定的元素。 由于线性表的长度可变，且所需最大存储空间随问题的不同而不同，在C语言中通常使用动态分配的一维数组表示线性表 : 1234567// －－－－－ 顺序表的存储结构－－－－－#define MAXSIZE 100 //顺序表可能达到的最大长度typedef int ElemType; //顺序表存储数据的类型,类型可以是int、float、char...typedef struct &#123; ElemType *elem; //存储空间的基地址 int length; //当前长度&#125; SqList; //顺序表的结构类型为SqList 顺序表中基本操作的实现 一、顺序表初始化 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。 将表的当前长度设为0。 123456bool InitList(SqList &amp;L)&#123; L.elem = new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if(!L.elem) return false; //存储分配失败退出 L.length=0; return true;&#125; 二、顺序表取值 判断指定的位置序号 i 值是否合理 (1≤i≤L.length1≤i≤L.length1≤i≤L.length), 若不合理，则返回false。 若 i 值合理，则将第 i 个数据元素 L.elem[i-1] 赋给参数 e, 通过 e 返回第 i 个数据元素的传值。 12345bool GetElem(SqList L,int i,ElemType &amp;e)&#123; // 时间复杂度 O(1) if(i&lt;1 || i&gt;L.length) return false; //如果越界，则返回false e = L.elem[i-1]; // i是位序，elem[i-1] 单元存储第 i 个数据元素 return true;&#125; 三、顺序表的按值查找 从第一个元素起，依次和 e 相比较，若找到与 e 相等的元素 L.elem[i]，则查找成功，返回该元素的序号 i+1 (数组下标从 0 开始)。 若查遍整个顺序表都没有找到，则查找失败， 返回0。 12345int LocateElem(SqList L,ElemType e)&#123; for(int i=0;i&lt;L.length;i++) if(L.elem[i]==e) return i+1; //查找成功，返回序号 i+1 return 0; //查找失败，返回0&#125; 最好时间复杂度：O(1)。查找元素在第一个，仅需比较一次。 最坏时间复杂度：O(n)。查找元素在最后一个，需比较n次。 平均时间复杂度：由平均查找长度公式： ASL=∑i=1npiCiASL=\\sum\\limits_{i=1}^np_iC_iASL=i=1∑n​pi​Ci​，以及在这里每个元素的查找概率相等pi=1/np_i=1/npi​=1/n。得 ASL=1n∑i=1ni=n+12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^ni = \\frac{n+1}{2}ASL=n1​i=1∑n​i=2n+1​。由此可见，顺序表按值查找的平均时间复杂度为O(n)。 四、顺序表插入元素 判断插入位置序号 i 值是否合理 (1≤i≤L.length+11≤i≤L.length+11≤i≤L.length+1)，若不合理，则返回false。 判断顺序表的存储空间是否已满，若满则返回 false。 将第L.length个至第 i 个位置的元素依次向后移动一个位置，空出第 i 个位置(i=L.length+1 时无需移动）。 将要插入的新元素e放入第i个位置。 表长加1。 12345678910bool ListInsert(SqList &amp;L,int i,ElemType e)&#123; //在顺序表L中第i个位置之前插入新的元素e if(i&lt;1 || i&gt;L.length+1) return false; //i值不合法 if(L.length==MAXSIZE) return false; //当前存储空间已满 for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; //插入位置及之后的元素后移 L.elem[i-1]=e; //将新元素e放入第l个位置 L.length++; //表长加1 return true;&#125; 最好时间复杂度： 在表尾插入（即 i=L.length+1），元素后移语句将不执行，时间复杂度为O(1)； 最坏时间复杂度： 在表头插入（即 i=1），元素后移语句将执行n次，时间复杂度为O(n)； 平均时间复杂度： 假设 pi(pi=1/(n+1))p_i(p_i=1/(n+1))pi​(pi​=1/(n+1))，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为：∑i=1n+1pi(n−i+1)=∑i=1n+11n+1(n−i+1)=1n+1∑i=1n+1(n−i+1)=1n+1n(n+1)2=n2\\sum\\limits_{i=1}^{n+1}p_i(n-i+1)=\\sum\\limits_{i=1}^{n+1}\\frac {1} {n+1}(n-i+1)=\\frac {1} {n+1}\\sum\\limits_{i=1}^{n+1}(n-i+1)=\\frac {1} {n+1}\\frac {n(n+1)} {2}=\\frac {n} {2}i=1∑n+1​pi​(n−i+1)=i=1∑n+1​n+11​(n−i+1)=n+11​i=1∑n+1​(n−i+1)=n+11​2n(n+1)​=2n​ 因此，线性表插入算法的平均时间复杂度为O(n) 。 五、顺序表删除元素 判断删除位置 i 值是否合理 (1≤i≤L.length1≤i≤L.length1≤i≤L.length), 若不合理，则返回false。 将第i+1个至第L.length个的元素依次向前移动一个位置(i = L.length时无需移动）。 表长减1。 1234567bool ListDelete(SqList &amp;L,int i)&#123; //在顺序表L中删除第i个元素 if(i&lt;1||i&gt;L.length) return false; //i的值不合法 for(int j=i;j&lt;L.length;j++) //将第i+1个位置后的元素前移 L.elem[j-1] = L.elem[j]; L.length--; //表长减1 return true;&#125; 最好时间复杂度： 删除表尾元素（即 i=L.length），无须移动元素，时间复杂度为O(1)； 最坏时间复杂度： 删除表头元素(即 i= 1)，需移动除第一个元素外的所有元素，时间复杂度为O(n)。 平均时间复杂度： 假设pi(pi=1/n)p_i (p_i= 1/n)pi​(pi​=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为: ∑i=1npi(n−i)=∑i=1n1n(n−i)=1n∑i=1n(n−i)=1nn(n−1)2=n−12\\sum\\limits_{i=1}^{n}p_i(n-i)=\\sum\\limits_{i=1}^{n}\\frac {1} {n}(n-i)=\\frac{1}{n}\\sum\\limits_{i=1}^{n}(n-i)=\\frac {1} {n}\\frac {n(n-1)} {2}=\\frac {n-1} {2}i=1∑n​pi​(n−i)=i=1∑n​n1​(n−i)=n1​i=1∑n​(n−i)=n1​2n(n−1)​=2n−1​ 因此,线性表删除算法的平均时间复杂度为O(n)。 线性表的链式表示和实现 链式存储结构的特点：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的），存放数据元素的结点至少包括两个域（数据域、指针域），指针域中存储的信息称作指针或链。n个结点链接成一个链表，即为线性表的链式存储结构。 单链表的定义和表示 当链表的每个结点中只包含一个指针域，又称线性链表或单链表。 首元结点：即链表中存储第一个数据元素的结点。 最后一个结点的指针为NULL。 头结点：是在首元素结点之前附设的一个结点，其指针指向首元结点。其数据域可以不存储任何信息。 头指针：指向链表中的第一个结点的存储位置。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。 是否带头结点 链表为空时的情况（L为头指针） 单链表的逻辑状态表示 不带头结点 L == NULL 带头结点 L -&gt; next == NULL 由上述可见，单链表可由头指针唯一确定，在C语言中可用 “结构指针&quot; 来描述： 123456//－－－－－ 单链表的存储结构－－－－－typedef int ElemType; //顺序表存储数据的类型,类型可以是int、float、char...typedef struct LNode&#123; ElemType data; //结点的数据域 struct LNode *next; //结点的指针域&#125;LNode,*LinkList; //LinkList 为指向结构体 LNode 的指针类型 注： 为了提高程序的可读性，在此对同一结构体指针类型起了两个名称，LinkList与 LNode* , 两者本质上是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode* 定义指向单链表中任意结点的指针变量。 利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。 单链表的基本操作的实现 一、 单链表的初始化 生成新结点作为头结点，用头指针L 指向头结点。 头结点的指针域置空。 12345bool InitList(LinkList &amp;L)&#123; L = new LNode; //生成新结点作为头结点， 用头指针L指向头结点 L-&gt;next = NULL; //头结点的指针域置空 return true;&#125; 二、单链表的取值 用指针p指向首元结点，用 j 做计数器初值赋为1。 从首元结点开始依次顺着链域 next 向下访问，只要指向当前结点的指针 p 不为空(NULL), 并且没有到达序号为 i 的结点，则循环执行以下操作： p指向下一个结点； 计数器 j 相应加1。 退出循环时， 如果指针p为空， 或者计数器 j 大于 i, 说明指定的序号 i 值不合法（i 大于表长n或 i 小于等于0), 取值失败返回NULL; 否则取值成功， 此时 j=i 时，p所指的结点就是要找的第 i 个结点，返回该结点。 1234567891011LNode *GetElem(LinkList L, int i)&#123; int j = 1; //计数器j初值赋为1 LNode *p = L-&gt;next; //初始化，p指向首元结点 if (i == 0) return L; // 如果i=0，则返回头结点 if (i &lt; 0) return NULL; while (p &amp;&amp; j &lt; i)&#123; p = p-&gt;next; //p指向下一个结点 j++; //计数器j相应加1 &#125; return p; //返回第i个结点的指针，若i大于表长则返回NULL&#125; 最好时间复杂度：O(1)。i=0或i=1，查找元素为头结点或者是首元结点，仅需比较一次。 最坏时间复杂度：O(n)。查找元素不存在，需比较n次。 平均时间复杂度：假设每个元素的查找概率相等pi=1/np_i=1/npi​=1/n。得 ASL=1n∑i=1n(i−1)=n−12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^n(i-1) = \\frac{n-1}{2}ASL=n1​i=1∑n​(i−1)=2n−1​。由此可见，顺序表按值查找的平均时间复杂度为O(n)。 三、单链表的按值查找 用指针p指向首元结点 。 从首元结点开始依次顺着链域next向下查找， 只要指向当前结点的指针p不为空， 并且p所指结点的数据域不等于给定值e, 则循环执行以下操作： p指向下一个结点 。 返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL 。 1234567LNode *LocateElem(LinkList L, ElemType e)&#123; LNode *p = L-&gt;next; //初始化，p指向首元结点 while (p &amp;&amp; p-&gt;data != e)&#123; //顺链域向后扫描，直到p为空或p所指结点的数据域等于e p = p-&gt;next; //p指向下一个结点 &#125; return p; //查找成功返回值为e的结点地址p, 查找失败p为NULL&#125; 平均时间复杂度：该算法与按序号查找类似，与待查找的值 e 相关，复杂度为 O(n)。 四、单链表的插入 在单链表中要插入元素，只需更改各结点的指针域即可，需要进行如下图的操作： 将值为e的新结点插入到表的第 i 个结点的位置上，即插入到结点 ai−1a_{i-1}ai−1​与aia_iai​之间。 查找结点 ai−1a_{i-1}ai−1​ 并由指针p指向该结点 。 生成一个新结点*s 。 将新结点*s 的数据域置为 e 。 将新结点*s 的指针域指向结点aia_iai​。 将结点 *p 的指针域指向新结点 *s 。 1234567891011bool ListInsert(LinkList &amp;L, int i, ElemType e)&#123;//在带头结点的单链表L中第i个位置插入值为e的新结点 //获取i-1位置的元素 LNode *p = GetElem(L, i - 1); if(!p) return false;//说明输入的位置不合法 //此时p指向第i-1位置的元素 LNode *s = new LNode; //生成新结点*s s-&gt;data = e; //将结点*s的数据域置为e s-&gt;next = p-&gt;next; //将结点*s的指针域指向结点ai p-&gt;next = s; //将结点*p的指针域指向结点*s return true;&#125; 平均时间复杂度：与顺序表的插入操作相比，复杂度仍为 O(n)，但是省略了顺序表移动元素的步骤，只需要从头到尾比较一遍链表即可。注意，头插法可以到达O(1)的时间复杂度。 五、单链表的删除 在单链表中要删除元素，只需更改各结点的指针域即可，需要进行如下图的操作： 删除单链表的第 i 个结点aia_iai​。 查找结点 ai−1a_{i-1}ai−1​ 并由指针p指向该结点 。 临时保存待删除结点 aia_iai​ 的地址在 q 中，以备释放。 将结点 *p 的指针域指向 aia_iai​ 的直接后继结点 。 释放结点aia_iai​的空间 。 12345678bool ListDelete(LinkList &amp;L, int i)&#123; //在带头结点的单链表L中，删除第i个元素 LNode *p = GetElem(L, i - 1); //找到第i-1位置的结点 if(!p || !p-&gt;next) return false; //删除位置不合理 LNode *q = p-&gt;next; //临时保存被删结点的地址以备释放 p-&gt;next = q-&gt;next; //改变删除结点前驱结点的指针域 free(q); //释放删除结点的空间 return true;&#125; 平均时间复杂度：类似于插入算法，删除算法时间复杂度亦为 O(n)； 六、创建单链表 (1) 前插法 创建一个只有头结点的空链表。 根据待创建链表包括的元素个数n, 循环n次执行以下操作： 生成一个新结点 *p; 输入元素值赋给新结点*p 的数据域； 将新结点 *p 插入到头结点之后。 12345678910void CreateList_H(LinkList &amp;L,int n)&#123; L = new LNode; L-&gt;next = NULL; //先建立一个带头结点的空链表 for(int i=0;i&lt;n;i++)&#123; LNode *p = new LNode; //生成新结点*p cin&gt;&gt;p-&gt;data; //输入元素值赋给新结点*p的数据域 p-&gt;next = L-&gt;next; //将新结点*p插人到头结点之后 L-&gt;next = p; &#125;&#125; (2) 后插法 创建一个只有头结点的空链表。 尾指针 r 初始化， 指向头结点。 根据创建链表包括的元素个数n, 循环n次执行以下操作： 生成一个新结点*p; 输入元素值赋给新结点*p 的数据域； 将新结点 *p 插入到尾结点 *r 之后； 尾指针 r 指向新的尾结点 *p。 123456789101112void CreateList_R(LinkList &amp;L,int n)&#123; L = new LNode; L-&gt;next = NULL; //先建立一个带头结点的空链表 LNode *p, *r = L; //r用于记录表尾结点 for(int i=0;i&lt;n;i++)&#123; p = new LNode; //生成新结点*p cin&gt;&gt;p-&gt;data; //输入元素值赋给新结点*p的数据域 p-&gt;next = NULL; //将新结点*p插人尾结点*r之后 r-&gt;next = p; r = p; //r指向新的尾结点*p &#125;&#125; 循环链表 循环链表(CircularLinked List)：是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他结点，下图所示为单链的循环链表。类似地，还可以有多重链的循环链表。 循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL或p-&gt;next!=NULL，而循环单链表的判别条件为p!=L或p-&gt;next!=L。 若在循环链表中设立尾指针而不设立头指针，可使一些操作简化。如将两个线性表进行合并，仅需将第一个表的尾指针指向第二个表的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。 循环双链表： 由循环单链表的定义不难推出循环双链表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点，如下图所示。 在循环双链表L中，某结点*p为尾结点时，p-&gt;next==L; 当循环双链表为空表时，其头结点的prior域和next域都等于L。 双向链表 单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。 为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next,分别指向其前驱结点和后继结点，如下图所示。 在C/C++语言中可描述如下： 1234567// - - - - -双向链表的存储结构－－－－－typedef int ElemType; //顺序表存储数据的类型,类型可以是int、float、char...typedef struct DuLNode&#123; ElemType data; //数据域 struct DuLNode *prior; //直接前驱 struct DuLNode *next; //直接后继&#125;DuLNode,*DuLinkList; 在双向链表中， 有些操作（如 ListLength、GetElem 和 LocateElem 等）仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针，下图分别显示了插入和删除结点时指针修改的情况。 在插入结点时需要修改四个指针，在删除结点时需要修改两个指针。两者的时间复杂度均为 O(n)。 一、双向链表的插入 12345678910111213bool ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e)&#123; DuLNode *p = GetElem_DuL(L,i-1); //确定第i-1个元素的位置 if(!p) return false; //插入位置不合理 DuLNode *s = new DuLNode; //生成新结点*s s-&gt;data = e; //将结点*s数据域置为e //执行插入操作 s-&gt;next = p-&gt;next; //对应上图2.10的第一步 if(p-&gt;next!=NULL) //倘若不是最后一个结点 p-&gt;next-&gt;prior = s; //对应上图2.10的第二步 s-&gt;prior = p; //对应上图2.10的第三步 p-&gt;next = s; //对应上图2.10的第四步 return true;&#125; 二、双向链表的删除 12345678910bool ListDelete_Dul(DuLinkList &amp;L,int i)&#123; DuLNode *p = GetElem_DuL(L,i-1); //确定第i-1个元素的位置 if(!p || !p-&gt;next) return false; //删除位置不合理 DuLNode *q = p-&gt;next; //将p指向第i个位置的元素 if(q-&gt;next!=NULL) q-&gt;next-&gt;prior = p; //对应上图2.11的第一步 p-&gt;next = q-&gt;next; //对应上图2.11的第二步 free(q); return true;&#125; 单链表、循环链表和双向链表的比较 顺序表和链表的比较","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"跟Alon学数据结构(入门)-第1章 绪论","slug":"跟Alon学数据结构(入门)-第1章 绪论","date":"2021-08-22T14:43:35.000Z","updated":"2021-10-05T08:01:05.091Z","comments":true,"path":"2021/08/22/跟Alon学数据结构(入门)-第1章 绪论/","link":"","permalink":"https://alonscholar.github.io/2021/08/22/%E8%B7%9FAlon%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%85%A5%E9%97%A8)-%E7%AC%AC1%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"绪论 早期的计算机主要用于数值计算，现在，计算机主要用于非数值计算，包括处理字符、表格和图像等具有一定结构的数据。这些数据内容存在着某种联系，只有分清楚数据的内在联系，合理地组织数据，才能对它们进行有效的处理，设计出高效的算法。如何合理地组织数据、高效地处理数据，这就是 “数据结构” 主要研究的问题。本章简要介绍有关数据结构的基本概念和算法分析方法。 数据结构的研究内容 数据的各种逻辑结构和物理结构，以及他们之间的相应关系。 对每种结构定义相适应的各种运算。 设计出相应的算法。 分析算法的效率。 基本概念和术语 数据、数据对象、数据元素和数据项 名词 解释 数据 (Data) 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。（整数、实数、字符串、图形、图像、声音及动画…） 数据对象 (Data Object) 是性质相同的数据元素的集合，是数据的一个子集。 数据元素(Data Element) 是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。 在有些情况下，数据元素也称为元素、记录等。数据元素用于完整地描述一个对象，如一名学生记录，图中的一个顶点等。 数据项 (Data Item) 是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。 数据结构 数据结构 (Data Structure) 是相互之间存在一种或多种特定关系的数据元素的集合。 数据结构包括逻辑结构和存储结构两个层次。 逻辑结构 数据的逻辑结构有两个要素：一是数据元素；二是关系。 逻辑结构分为四种类型：集合结构，线性结构，树形结构，图形结构。 类型 简述 图片 集合结构 数据元素同属一个集合，单个数据元素之间没有任何关系。 线性结构 类似于线性关系，线性结构中的数据元素之间是一对一的关系。 树结构 树形结构中的数据元素之间存在一对多的关系。（各元素及元素关系所组成图形类似于树状图）。 图结构 数据元素之间是多对多的关系。 存储结构 物理结构又叫存储结构，分为两种，一种是顺序存储结构，一种是链式存储结构。 类型 简述 图片 顺序存储结构 顺序存储结构是把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的。之前学习的数组就是一种顺序存储结构。 链式存储结构 链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。根据指针找出相邻元素的位置。 数据类型和抽象数据类型 类型 描述 数据类型 一般包括整型、实型、字符型等原子类型外，还有数组、结构体和指针等结构类型。 抽象数据类型 抽象数据类型 (Abstract Data Type, ADT) 一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合。如C语言中的结构体以及 C++、Java中的类。 算法和算法分析 算法的定义及特性 算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。 一个算法必须满足以下五个重要特性。 特性 描述 有穷性 一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。 确定性 对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性， 使算法的执行者或阅读者都能明确其含义及如何执行。 可行性 算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。 输入 一个算法有零个或多个输入。 输出 一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有意义。 评价算法优劣的基本标准 名称 描述 正确性 在合理的数据输入下，能够在有限的运行时间内得到正确的结果。 可读性 一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。 健壮性 当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。 高效性 高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。 算法的时间复杂度 衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。 因为事后统计法的缺点很明显，需要将算法实现等等，所以我们通常采用事前分析估算法。 问题规模和语句频度 问题规模 是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。 语句频度(FrequencyCount)是一条语句的重复执行的次数。 一个算法的执行时间大致上等于其所有语句执行时间的总和， 而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。 12345678// 例：求两个n阶矩阵的乘积算法。i记录行号，j记录列号for(i=1;i&lt;=n;i++) //频度为 n+1 for(j=1;j&lt;=n;j++) //频度为 n*(n+1) &#123; c[i][j] = 0; //频度为 n*n for(k=1;k&lt;=n;k++) //频度为 n*n*(n+1) c[i][j] = c[i][j]+a[i][k]*b[k][j]; //频度为 n*n*n &#125; 该算法中所有语句频度之和， 是矩阵阶数n的函数， 用 f(n)表示之。换句话说， 上例算法的执行时间与f(n)成正比。 f(n)=2n3+3n2+2n+1f(n)=2n^3+3n^2+2n+1f(n)=2n3+3n2+2n+1 算法的时间复杂度定义 ​ 当算法比较复杂时，我们往往不能通过所有语句频度之和来测量算法的时间复杂度。所以我们这里提出了基本语句的概念，所谓 “基本语句” 指的是算法中重复执行次数和算法的执行时间成正比的语句， 它对算法运行时间的贡献最大。 ​ 如上述代码中，因为 lim⁡n→∞f(n)/n3=lim⁡n→∞(2n3+3n2+2n+1)/n3=2\\lim\\limits_{n\\to\\infty}f(n)/n^3 = \\lim\\limits_{n\\to\\infty}(2n^3+3n^2+2n+1)/n^3=2n→∞lim​f(n)/n3=n→∞lim​(2n3+3n2+2n+1)/n3=2，所以我们称 f(n) 和 n3n^3n3是同阶的，我们用“O”来表示数量级，记作 T(n)=O(f(n))=O(n3)T(n)=O(f(n))=O(n^3)T(n)=O(f(n))=O(n3)。 ​ 随问题规模n的增大，算法执行时间的增长率和 f(n)的增长率相同，称做算法的渐近时间复杂度， 简称时间复杂度(TimeComplexity)。 算法的时间复杂度分析举例 ​ 分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句， 计算基本语句的频度得到问题规模n的某个函数 f(n), 取其数量级用符号&quot;O&quot;表示即可。具体计算数量级时， 可以遵循以下定理。 定理1.1 若 f(n)=amnm+am−1nm−1+…+a1n+a0f(n)=a_mn^m+a_{m-1}n^{m-1}+…+a_1n+a_0f(n)=am​nm+am−1​nm−1+…+a1​n+a0​。 是一个m次多项式， 则T(n)=O(nm)T(n)=O(n^m)T(n)=O(nm)。 123456789101112131415161718192021// 举例说明如何求非递归算法的时间复杂度// --------- O(1) --------------&#123;x++;s=0;&#125; for(i=0;i&lt;10000;i++)&#123;x++;s=0;&#125; //时间复杂度均为O(1)// --------- O(n) --------------for(i=0;i&lt;n;i++)&#123;x++;s=0;&#125; //问题规模随着n的增加而增加,T(n)=O(n)// --------- O(n*n) -------------x=0;y=0; // O(1)for(k=1;k&lt;=n;k++) // O(n+1) x++; // O(n)for(i=1;i&lt;=n;i++) // O(n+1) for(j=1;j&lt;=n;j++) // O(n*(n+1)) y++; // O(n*n)// --------- O(n*n*n) -------------x=1;for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 常见的时间复杂度：O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n)O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(2^n)O(1)&lt;O(log2​n)&lt;O(n)&lt;O(nlog2​n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n) 最好、最坏和平均时间复杂度 最好时间复杂度是指在最好情况下，算法的时间复杂度。 最坏时间复杂度 是指在最坏情况下，算法的时间复杂度。 平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法计算量的加权平均值。 通常情况下，只讨论算法的最坏时间复杂度。 算法的空间复杂度 关于算法的存储空间需求，类似于算法的时间复杂度，我们采用渐近空间复杂度(SpaceComplexity)作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n的函数，记作：S(n)=O(f(n)) 空间复杂度只需要分析辅助变量所占的额外空间。 12345678910111213// 数组逆序，将一维数组a中的n个数逆序存放到原数组中。// 算法 1 ，仅需要另外借助一个变量t， 与问题规模n大小无关，所以其空间复杂度为O(1)。for(i=0;i&lt;n/2;i++)&#123; t=a[i]; a[i]=a[n-i-1]; a[n-i-1]=t;&#125;// 算法 2 ，需要另外借助一个大小为n的辅助数组b, 所以其空间复杂度为O(n)。for(i=0;i&lt;n;i++) b[i] = a[n-i-1];for(i=0;i&lt;n;i++) a[i] = b[i];","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}