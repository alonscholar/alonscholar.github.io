{"meta":{"title":"AlonScholar","subtitle":"","description":"","author":"Alon Scholar","url":"https://alonscholar.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-08-21T07:08:46.426Z","updated":"2021-08-21T07:03:58.223Z","comments":false,"path":"/404.html","permalink":"https://alonscholar.github.io/404.html","excerpt":"","text":""},{"title":"推荐书籍","date":"2021-08-21T15:38:24.017Z","updated":"2021-08-21T15:38:24.017Z","comments":false,"path":"books/index.html","permalink":"https://alonscholar.github.io/books/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2021-08-22T06:47:16.825Z","updated":"2021-08-22T06:47:16.825Z","comments":false,"path":"about/index.html","permalink":"https://alonscholar.github.io/about/index.html","excerpt":"","text":"基本信息： 赵鑫 / 男 / 22 / 党员 现 在 地： 山东泰安 手 机 号： 15288923500 Q Q： 2530394412 邮 箱： 2530394412@qq.com 工作经验： 一年 证 书： 计算机二级、蓝桥杯省二、英语四级 GitHub： https://github.com/alonscholar 个人网站： https://alonscholar.github.io/ 求职意向 期望职位： JAVA开发工程师 期望薪资： 7000-11000 教育背景 山东科技大学泰山科技学院 2018.09-2022.06 计算机科学与技术 实习经历 公司： 山东鑫超网络科技有限公司 职位： JAVA开发工程师 时间： 2021.01-2021.02 个人作品 名称： 在线教学系统 简介： 本项目使用了Vue+SpringCloud搭建，并使用阿里云Oss存储以及视频点播服务，另外还实现了手机号验证码注册和登录等功能，线上地址：http://www.zyczx.top/。 名称： 大数据疫情实时观测 简介： 本项目实现了展示新冠疫情的各地区的新增人数，累计确诊、累计治愈、累计死亡等情况。并使用了现代科技化的界面设计，以及echarts图标数据展示，线上地址：http://yq.zyczx.top/ 名称： 个人网站 简介： 本项目是基于Hexo框架实现的个人网站，其中包括了个人所记录的学习笔记以及前沿技术知识。其中还包括自己的GitHub所发布的项目，https://alonscholar.github.io/ 技能清单 以下均为我熟练使用的技能： 编程语言：Java、Js、Vue、Python、C/C++ 前端开发：熟悉element-ui设计、Bootstrap使用、vue的基本框架vue-admin-template、nuxt等。熟练Html+Css+Js的网页设计，了解微信小程序，会使用NodeJs以及Echarts图表，Ajax以及axios传递请求等等。 后端开发：熟悉并掌握了SpringBoot、SpringCloud、MyBatis-plus等Java框架，了解SpringSecurity、Shiro安全框架，会使用SpringMVC基本框架以及Servlet,Jsp相关技术。并会使用Redis进行缓存处理，EasyPoi实现表格上传与导出… 其他：数据库熟练使用Mysql，了解SqlServer，会使用基本的Linux命令，以及Nginx配置反向代理与负载均衡，学习过Docker，Nacos配置服务中心，懂得一些算法设计知识，会使用Git版本控制工具。 以下是我接触并了解的技能： GoLang（学习中）、Netty、Kubernetes、RabbitMQ等等 自我评价 &emsp;&emsp;我是一个热爱技术热爱编程的人，大学四年自学编程，做过很多小项目（黄金矿工、坦克大战、超级玛丽游戏等等），上架了3个网站，其中在线教学是开发给老师与学生使用，并获得了一些好评。同时我也是一个热爱分享技术的人，在CSDN也发布过很多文章，同时拥有自己的个人网站：https://alonscholar.github.io/，在我的个人网站中，我会分享很多自己学过的技术知识等等。 &emsp;&emsp;我希望在以后的工作中，深度上能学习掌握更多关于JAVA开发的高级知识及数据结构算法；广度上能扩宽自己的技术栈，如前端、后端、混合开发以及其他比较新潮有趣的技术等；高度上希望经过未来几年的职业生涯发展，能成为架构师级的技术专家。"},{"title":"友情链接","date":"2021-08-21T15:35:41.282Z","updated":"2021-08-21T15:35:41.282Z","comments":false,"path":"links/index.html","permalink":"https://alonscholar.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-08-21T07:09:04.359Z","updated":"2021-08-21T07:03:58.225Z","comments":false,"path":"categories/index.html","permalink":"https://alonscholar.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-21T07:09:12.025Z","updated":"2021-08-21T07:03:58.227Z","comments":false,"path":"tags/index.html","permalink":"https://alonscholar.github.io/tags/index.html","excerpt":"","text":""},{"title":"GitHub仓库","date":"2021-08-21T15:45:56.821Z","updated":"2021-08-21T15:45:56.821Z","comments":false,"path":"repository/index.html","permalink":"https://alonscholar.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构(严蔚敏)-第5章 树和二叉树","slug":"数据结构(严蔚敏)-第5章 树和二叉树","date":"2021-08-31T05:43:35.000Z","updated":"2021-09-05T08:10:30.861Z","comments":true,"path":"2021/08/31/数据结构(严蔚敏)-第5章 树和二叉树/","link":"","permalink":"https://alonscholar.github.io/2021/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC5%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"树和二叉树 树结构是一类重要的非线性数据结构。直观来看，树是以分支关系定义的层次结构。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示。树在计算机领域中也得到广泛应用，尤以二叉树最为常用。如在操作系统中，用树来表示文件目录的组织结构，在编译系统中，用树来表示源程序的语法结构，在数据库系统中，树结构也是信息的重要组织形式之一。 树和二叉树的定义 树的定义 树(Tree)是n(n≥0)个结点的有限集，它或为空树(n=0)；或为非空树，对于非空树T： 有且仅有一个称之为根的结点； 除根结点以外的其余结点可分为 m(m&gt;0）个互不相交的有限集 T1,T2,…,TmT_1,T_2,…,T_mT1​,T2​,…,Tm​，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。 如，在下图中，(a)是只有一个根结点的树；(b)是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集：T1={B,E,F,K,L},T2={C,G},T3={D,H,I,J,M}。T_1=\\{B,E, F, K, L\\}, T_2=\\{C,G\\},T_3=\\{D, H, I, J, M\\}。T1​={B,E,F,K,L},T2​={C,G},T3​={D,H,I,J,M}。T1、T2T_1、T_2T1​、T2​和T3T_3T3​都是根A的子树，且本身也是一棵树。例如T1T_1T1​，其根为B，其余结点分为两个互不相交的子集： T11={E,K,L},T12={F}T_{11}=\\{E,K,L\\},T_{12}=\\{F\\}T11​={E,K,L},T12​={F}。T11T_{11}T11​和T12T_{12}T12​都是B的子树。而T11T_{11}T11​中E是根，{K}和{L}是E的两棵互不相交的子树，其本身又是只有一个根结点的树。 显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下几个性质: 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。 树中所有结点可以有零个或多个后继。 树中的结点数等于所有结点的度数加1。 度为m的树中第i层上至多有mi−1m^{i-1}mi−1个结点(i≥1)(i ≥1)(i≥1)。 高度为h的m叉树至多有(mh−1)/(m−1)(m^h-1)/(m-1)(mh−1)/(m−1)个结点。 具有n个结点的m叉树的最小高度为[log⁡m(n(m−1)+1)][\\log_m {(n(m-1)+1)}][logm​(n(m−1)+1)]。 树适合于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在n个结点的树中有n-1条边。而树中每个结点与其下一层的零个或多个结点（即其子女结点）有直接关系。 树的基本术语 名词 解释 结点 树中的一个独立单元。包含一个数据元素及若干指向其子树的分支。 结点的度 结点拥有的子树数称为结点的度。如上图(b)中，A的度为3，C度为1，F度为0。 树的度 树的度是树内各结点度的最大值。 叶子 度为 0 的结点称为叶子或终端结点。 非终端结点 度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。 双亲和孩子 结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。如上图(b)中，B的双亲为A，B的孩子有E和F。 兄弟 同一个双亲的孩子之间互称兄弟。例如上图(b)中，H、I 和 J 互为兄弟。 祖先 从根到该结点所经分支上的所有结点。例如上图(b)中，M 的祖先为 A 、 D 和H。 子孙 以某结点为根的子树中的任一结点都称为该结点的子孙。例如上图(b)中，B 的子孙为E、K、 L 和F。 层次 结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加 1。 堂兄弟 双亲在同一层的结点互为堂兄弟。例如，结点 G 与E 、 F、 H 、 I 、 J互为堂兄弟。 树的深度 树中结点的最大层次称为树的深度或高度。如上图(b)中，树的深度为4。 有序树和无序树 如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。 路径和路径长度 树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的,而路径长度是路径上所经过的边的个数。由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。 森林 森林是m (m≥0）棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树。 二叉树的定义 二叉树(Binary Tree)是n(n≥0)个结点所构成的集合，它或为空树(n=0); 或为非空树，对于非空树T: 有且仅有一个称之为根的结点； 除根结点以外的其余结点分为两个互不相交的子集T1T_1T1​和T2T_2T2​, 分别称为T的左子树和右子树，且T1T_1T1​和T2T_2T2​本身又都是二叉树。 二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点： 二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于2 的结点）； 二叉树的子树有左右之分，其次序不能任意颠倒。 二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如下图所示。 树和二叉树的抽象数据类型定义 根据树的结构定义，加上树的一组基本操作就构成了树的抽象数据类型定义： 1234567891011121314151617181920ADT Tree&#123; 数据对象D：D 是具有相同特性的数据元素的集合。 数据关系R：若 D 为空集，则称为空树；其余略。 基本操作P： InitTree(&amp;T); //构造空树T。 DestroyTree(&amp;T); //销毁树T。 CreateTree(&amp;T,definition); //按definition构造树T。 ClearTree(&amp;T); //将树T清为空树。 TreeEmpty(T); //若 T 为空树，则返回 true, 否则 false。 TreeDepth(T); //返回T的深度。 Root(T); //返回T的根。 Value(T,cur_e); //返回 cur_e 的值。 Assign(T,cur_e,value); //结点 cur_e 赋值为 value。 Parent(T,cur_e); //若 cur_e是 T 的非根结点，则返回它的双亲，否则函数值为“空”。 LeftChild(T,cur_e); //若 cur_e是T 的非叶子结点，则返回它的最左孩子，否则返回“空”。 RightSibling(T,cur_e); //若 cur_e 有右兄弟，则返回它的右兄弟，否则函数值为“空”。 InsertChild(&amp;T,p,i,c); //插入c为T中p指结点的第i棵子树。 DeleteChild(&amp;T,p,i); //删除T中 p 所指结点的第i棵子树。 TraverseTree(T); //按某种次序对T的每个结点访问一次。&#125;ADT Tree 二叉树的抽象数据类型定义如下： 12345678910111213141516171819202122232425ADT BinaryTree&#123; 数据对象D：D 是具有相同特性的数据元素的集合。 数据关系R：若 D=∮，则R=∮，称BinaryTree为空二叉树；其余略。 基本操作P： InitBiTree(&amp;T); //构造空二叉树T。 DestroyBiTree(&amp;T); //销毁二叉树T。 CreateBiTree(&amp;T,definition); //按definition构造二叉树T。 ClearBiTree(&amp;T); //将二叉树T清为空树。 BiTreeEmpty(T); //若T为空二叉树，则返回true, 否则false。 BiTreeDepth(T); //返回T的深度。 Root(T); //返回T的根。 Value(T,e); //返回e的值。 Assign(T,&amp;e,value); //结点e赋值为value。 Parent(T,e); //若e是T的非根结点，则返回它的双亲，否则返回“空”。 LeftChild(T,e); //返回e的左孩子。若e无左孩子，则返回“空”。 RightChild(T,e); //返回e的右孩子。若e无右孩子，则返回“空”。 LeftSibling(T, e); //返回e的左兄弟。若e是T的左孩子或无左兄弟，则返回 “空”。 RightSibling(T,e); //返回e的右兄弟。若e是T的右孩子或无右兄弟，则返回 “空”。 InsertChild(&amp;T,p,LR,c); //根据LR为0或1,插入c为T中p所指结点的左或右子树。p所指结点的原有左或右子树则成为c的右子树。 DeleteChild(&amp;T, p, LR); //根据LR为0或1, 删除T中p所指结点的左或右子树。 PreOrderTraverse(T); //先序遍历T, 对每个结点访问一次。 InOrderTraverse(T); //中序遍历T, 对每个结点访问一次。 PostOrderTraverse(T); //后序遍历T, 对每个结点访问一次。 LevelOrderTraverse(T); //层序遍历T, 对每个结点访问一次。&#125;ADT BinaryTree 二叉树的性质和存储结构 几种特殊的二叉树 满二叉树 一棵高度为h，且含有2h−12^h-12h−1个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点，如图(a)所示。 可以对满二叉树的结点进行连续编号，约定编号从根结点起，自上而下，自左至右。由此可引出完全二叉树的定义。 完全二叉树 高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树，如图(b)所示。 其特点如下: 若i≤⌊n/2⌋i≤\\lfloor {n/2}\\rfloori≤⌊n/2⌋，则结点 i 为分支结点，否则为叶子结点。 叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。 若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征)。 按层序编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于 i 的结点均为叶子结点。 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。 二叉排序树 左子树上所有结点的关键字均小于根结点的关键字;右子树上的所有结点的关键字均大于根结点的关键字;左子树和右子树又各是一棵二叉排序树。 平衡二叉树 树上任一结点的左子树和右子树的深度之差不超过1。 二叉树的性质 二叉树具有下列重要特性： 性质1：在二叉树的第i层上至多有2i−12^{i-1}2i−1个结点(i≥1)。 性质2：深度为k的二叉树至多有2k−12^{k}-12k−1个结点(k≥1)。 性质3：对任何一棵二叉树T, 如果其终端结点数为n0n_0n0​，度为2的结点数为n2n_2n2​，则n0=n2+1n_0=n_2+1n0​=n2​+1。 性质4：具有n(n&gt;0)个结点的完全二叉树的高(深)度为⌈log⁡2(n+1)⌉\\lceil \\log_2 (n+ 1)\\rceil⌈log2​(n+1)⌉或⌊log⁡2n⌋+1\\lfloor \\log_2n \\rfloor+1⌊log2​n⌋+1。 性质5：对完全二叉树按从上到下、从左到右的顺序依次编号1,2,…, n，则有以下关系: 当i&gt;1时，结点 i 的双亲的编号为⌊i/2⌋\\lfloor i/2\\rfloor⌊i/2⌋，即当 i 为偶数时，其双亲的编号为i/2，它是双亲的左孩子;当 i 为奇数时，其双亲的编号为(i−1)/2(i- 1)/2(i−1)/2，它是双亲的右孩子。 当2i≤n时，结点 i 的左孩子编号为2i，否则无左孩子。 当2i+1≤n时，结点 i 的右孩子编号为2i+1，否则无右孩子。 结点 i 所在层次（深度）为⌊log2i⌋+1\\lfloor log_2i\\rfloor+ 1⌊log2​i⌋+1。 二叉树的存储结构 类似线性表，二叉树的存储结构也可采用顺序存储和链式存储两种方式。 顺序存储结构 顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排在这组单元中。 对于完全二叉树，只要从根起按层序存储即可，依次自上而下、自左至右存储结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组中下标为i-1的分量中。 对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中，如下图所示，图中以&quot;0&quot;表示不存在此结点。 由此可见，这种顺序存储结构仅适用于完全二叉树。因为，在最坏的情况下，一个深度为K且只有K个结点的单支树（树中不存在度为2的结点）却需要长度为2k−12^k-12k−1的一维数组。这造成了存储空间的极大浪费， 所以对于一般二叉树，更适合采取下面的链式存储结构。 链式存储结构 设计不同的结点结构可构成不同形式的链式存储结构。由二叉树的定义得知，二叉树的结点由一个数据元素和分别指向其左、 右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域：数据域和左、 右指针域，如下图(b)所示。有时，为了便于找到结点的双亲，还可在结点结构中增加一个指向其双亲结点的指针域，如图 ( c ) 所示。 利用上图中两种结点结构所得的二叉树的存储结构分别称为二叉链表和三叉链表，如下图所示。链表的头指针指向二叉树的根结点。 在不同的存储结构中，实现二叉树的操作方法也不同，如找结点x的双亲, 在三叉链表中很容易实现，而在二叉链表中则需从根指针出发巡查。由此，在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需进行何种操作。在下一节的二叉树遍历及其应用的算法均采用以下定义的二叉链表形式实现。 12345// －－－－ 二叉树的二叉链表存储表示 －－－－typedef struct BiTNode&#123; TElemType data; //结点数据域 struct BiTNode *lchild,*rchild; //左右孩子指针&#125;BiTNode,*BiTree; 遍历二叉树和线索二叉树 在二叉树的一些应用中，常常要求在树中查找具有某种特征的结点，或者是对树中的全部结点逐一进行处理，这就提出了一个遍历二叉树的问题。线索二叉树是在第一次遍历时将结点的前驱、后继信息存储下来，便于再次遍历二叉树。 遍历二叉树 遍历二叉树(traversing binary tree)是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。 假如使用L、D、R分别表示遍历左子树、访问根结点和遍历右子树，且限定先左后右，则有我们常使用的4种遍历。我们使用下述表格进行说明： 名称 操作 先(根)序遍历 (DLR) 若二叉树不为空：(1) 访问根结点；(2) 先序遍历左子树；(3) 先序遍历右子树。 中(根)序遍历 (LDR) 若二叉树不为空：(1) 中序遍历左子树；(2) 访问根结点；(3) 中序遍历右子树。 后(根)序遍历 (LRD) 若二叉树不为空：(1) 后序遍历左子树；(2) 后序遍历右子树；(3) 访问根结点。 层次遍历(BFS) 按照从上到下、从左至右的顺序按层次遍历。 接下来，我们会围绕上图所示的二叉树来介绍二叉树的先中后序遍历，并给出相关算法描述。我们首先来看一下各种不同的遍历所得到的输出顺序。 类型 遍历结果 先序遍历 - + a * b - c d / e f 中序遍历 a + b * c - d - e / f 后序遍历 a b c d - * + e f / - 层次遍历 - + / a * e f b - c d 从遍历结果来看，先中后序遍历的结果所对应的恰好为表达式的前缀表示（波兰式）、中缀表示和后缀表示（逆波兰式）。 我们通过下图来具体了解一下先中后序遍历算法的递归执行过程。向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历的过程中访问结点时输出的信息。 只要沿着虚线从1出发到2结束，将沿途所见的三角形(或圆形或方形)内的字符记下，便得到遍历二叉树的先序（或中序或后序）序列。例如在下图中，沿虚线游走可以分别得到先序序列为ABDEC、中序序列为DBEAC、后序序列为DEBCA。 下面我们给出先中后序遍历算法的递归与非递归实现，与层次遍历的代码实现。 先序遍历 先序遍历遵循&quot;根左右&quot;的思想，即先访问根结点，然后是左子树和右子树。我们使用递归可以很轻松的实现其遍历的操作。 下面给出先序遍历的递归算法实现： 123456789void PreOrder(BiTree T)&#123; if (T!=NULL) //若二叉树非空 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; //访问根结点 PreOrder(T-&gt;lchild); //先序遍历左子树 PreOrder(T-&gt;rchild); //先序遍历右子树 &#125;&#125; 根据先序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树为空时，再访问它的右子树。因此先序遍历非递归的实现步骤及代码如下： 访问结点P，并将结点P入栈; 判断结点P的左孩子是否为空; 若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P; 若不为空，则将P的左孩子置为当前的结点P; 直到P为NULL并且栈为空，则遍历结束。 1234567891011121314151617void PreOrder2(BiTree T)&#123; stack&lt;BiTree&gt; s; BiTree P = T; while (P || !s.empty()) //直到P为NULL并且栈空，则遍历结束 &#123; if(P)&#123; //若当前结点非空 cout&lt;&lt;P-&gt;data&lt;&lt;&quot; &quot;; //访问当前结点 s.push(P); //将当前结点入栈 P = P-&gt;lchild; //将P的左孩子置为当前结点P &#125;else&#123; //若当前结点为空 P = s.top(); s.pop(); //取栈顶元素并进行出栈操作 P = P-&gt;rchild; //将栈顶元素的右孩子置为当前结点P &#125; &#125;&#125; 中序遍历 中序遍历遵循&quot;左根右&quot;的思想，即先访问左子树，然后是根结点和右子树。 下面给出中序遍历的递归算法实现： 123456789void InOrder(BiTree T)&#123; if (T != NULL) //若二叉树非空 &#123; InOrder(T-&gt;lchild); //中序遍历左子树 cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; //访问根结点 InOrder(T-&gt;rchild); //中序遍历右子树 &#125;&#125; 根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问输出，然后按相同的规则访问其右子树。因此中序遍历非递归的实现步骤及代码如下： 对于任一结点P： 若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理； 若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子； 直到P为NULL并且栈为空，则遍历结束。 1234567891011121314151617void InOrder2(BiTree T)&#123; stack&lt;BiTree&gt; s; BiTree P = T; while (P || !s.empty()) //直到P为NULL并且栈空，则遍历结束 &#123; if(P)&#123; //若当前结点非空 s.push(P); //将当前结点入栈 P = P-&gt;lchild; //将P的左孩子置为当前结点P &#125;else&#123; //若当前结点为空 P = s.top(); s.pop(); //取栈顶元素并进行出栈操作 cout&lt;&lt;P-&gt;data&lt;&lt;&quot; &quot;; //访问栈顶结点 P = P-&gt;rchild; //将当前的P置为栈顶结点的右孩子 &#125; &#125;&#125; 后序遍历 后序遍历遵循&quot;左右根&quot;的思想，即先访问左子树，然后是右子树和根结点。 下面给出后序遍历的递归算法实现： 123456789void PostOrder(BiTree T)&#123; if (T != NULL) //若二叉树非空 &#123; PostOrder(T-&gt;lchild); //后序遍历左子树 PostOrder(T-&gt;rchild); //后序遍历右子树 cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; //访问根结点 &#125;&#125; 后序遍历的非递归实现是三种遍历方法中最难的。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。 后序非递归遍历算法的思路分析:从根结点开始，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，但是此时不能出栈并访问，因为如果其有右子树，还需按相同的规则对其右子树进行处理。直至上述操作进行不下去，若栈顶元素想要出栈被访问，要么右子树为空，要么右子树刚被访问完（此时左子树早已访问完)，这样就保证了正确的访问顺序。 123456789101112131415161718192021222324void PostOrder2(BiTree T)&#123; stack&lt;BiTree&gt; s; BiTree P = T; //当前结点 BiTree r = NULL; //记录最近访问的一个结点，即前一次访问的结点 while (P || !s.empty()) &#123; if(P)&#123; s.push(P); P = P-&gt;lchild; &#125;else&#123; P = s.top(); //读取栈顶元素 if(P-&gt;rchild&amp;&amp;P-&gt;rchild!=r)&#123; //若右子树存在，且未被访问过 P = P-&gt;rchild; s.push(P); P = P-&gt;lchild; &#125;else&#123; //结点右子树不存在或右子树刚刚被访问 s.pop(); cout&lt;&lt;P-&gt;data&lt;&lt;&quot; &quot;; r = P; //记录最近被访问过的结点 P = NULL; &#125; &#125; &#125; &#125; 层次遍历 要进行层次遍历，需要借助一个队列。下面给出层次遍历的算法实现： 先将二叉树根结点入队，然后出队，访问出队结点。 若它有左子树，则将左子树根结点入队; 若它有右子树，则将右子树根结点入队。 然后出队，访问出队结点……如此反复，直至队列为空。 123456789101112131415161718// 广度优先void BFS(BiTree T)&#123; queue&lt;BiTree&gt; q; q.push(T); //先将二叉树根结点入队 BiTree tree; while (!q.empty()) //若队列非空 &#123; tree = q.front(); //取队头元素 cout&lt;&lt;tree-&gt;data&lt;&lt;&quot; &quot;; //访问出队结点 q.pop(); //出队 if(tree-&gt;lchild)&#123; //若它有左子树，则将左子树根结点入队; q.push(tree-&gt;lchild); &#125; if(tree-&gt;rchild)&#123; //若它有右子树，则将右子树根结点入队。 q.push(tree-&gt;rchild); &#125; &#125;&#125; 无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含 n 个结点的二叉树，其时间复杂度均为 O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为 n, 则空间复杂度也为 O(n)。 由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。 因为先序遍历的顺序是&quot;根左右&quot;，由此可以确定，在先序序列中第一个结点一定是二叉树的根结点。另外，中序遍历的顺序是&quot;左根右&quot;，根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。 同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，进而得到一棵二叉树。 例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。 首先，由先序序列可知A为二叉树的根结点。中序序列中A之前的BC为左子树的中序序列,EDGHFI为右子树的中序序列。然后由先序序列可知B是左子树的根结点,D是右子树的根结点。以此类推，就能将剩下的结点继续分解下去，最后得到的二叉树如下图©所示。 二叉树遍历算法的应用 “遍历” 是二叉树各种操作的基础，假设访问结点的具体操作不仅仅局限于输出结点数据域的值，而把 &quot;访问 &quot; 延伸到对结点的判别、计数等其他操作，可以解决一些关于二叉树的其他实际问题。如果在遍历过程中生成结点， 这样便可建立二叉树的存储结构。 创建二叉树的存储结构——二叉链表 为简化问题，设二叉树中结点的元素均为一个单字符。假设按先序遍历的顺序建立二叉链表，T 为指向根结点的指针，对于给定的一个字符序列， 依次读入字符， 从根结点开始， 递归创建二叉树。 扫描字符序列， 读入字符ch。 如果ch是一个 “#” 字符， 则表明该二叉树为空树，即T为NULL; 否则执行以下操作： 申请一个结点空间T; 将ch赋给T-&gt;data; 递归创建T的左子树； 递归创建T的右子树； 1234567891011void CreateBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch==&#x27;#&#x27;) T = NULL; //递归结束， 建空树 else&#123; T = new BiTNode; //生成根结点 T-&gt;data = ch; //根结点数据域置为 ch CreateBiTree(T-&gt;lchild); //递归创建左子树 CreateBiTree(T-&gt;rchild); //递归创建右子树 &#125;&#125; 如我们给出先序序列：12#46###3#5##，可建立出如下二叉链表结构。 复制二叉树 复制二叉树就是利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。根据二叉树的特点， 复制步骤如下： 如果是空树， 递归结束， 否则执行以下操作： 申请一个新结点空间，复制根结点； 递归复制左子树； 递归复制右子树。 1234567891011void Copy(BiTree T,BiTree &amp;NewT)&#123; if(T==NULL)&#123; NewT=NULL; return; &#125;else&#123; NewT = new BiTNode; NewT-&gt;data = T-&gt;data; //复制根结点 Copy(T-&gt;lchild,NewT-&gt;lchild); //递归复制左子树 Copy(T-&gt;rchild,NewT-&gt;rchild); //递归复制右子树 &#125;&#125; 计算二叉树的深度 如果是空树， 递归结束， 深度为0, 否则执行以下操作： 递归计算左子树的深度记为m; 递归计算右子树的深度记为n; 如果 m 大于 n, 二叉树的深度为 m+1, 否则为 n+1。 12345678int Depth(BiTree T)&#123; if(T==NULL) return 0; //如果是空树，深度为0，递归结束 else&#123; int m = Depth(T-&gt;lchild); //递归计算左子树的深度 int n = Depth(T-&gt;rchild); //递归计算右子树的深度 return m&gt;n?(m+1):(n+1); //返回最大子树深度+1 &#125;&#125; 统计二叉树中结点的个数 如果是空树，则结点个数为 0; 否则，结点个数为左子树的结点个数加上右子树的结点个数再加上 1 。 12345int NodeCount(BiTree T)&#123; if(T==NULL) return 0; else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;&#125; 线索二叉树 遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继。 传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在任一序列中的前驱或后继。我们可以利用上二叉树中所有结点的空指针，通过不同的遍历方式， 使这些空指针来存放其前驱或后继结点。 这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。 注： 在含n个结点的二叉树中，有n+1个空指针。 这是因为每个叶结点有2个空指针，每个度为1的结点有1个空指针，空指针总数为2n0+n12n_0 + n_12n0​+n1​，又n0=n2+1n_0 = n_2 + 1n0​=n2​+1，所以空指针总数为n0+n1+n2+1=n+1n_0+ n_1+n_2+1 =n+1n0​+n1​+n2​+1=n+1。 我们规定： 若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。如下图所示，还需增加两个标志域标识指针域是指向左（右）孩子还是指向前驱（后继)。 其中，标志域的含义如下： 线索二叉树的存储结构描述如下: 123456typedef struct ThreadNode&#123; char data; //数据元素，可以是任意其他类型，这里采用char。 int ltag=0, rtag=0; //左、右线索标志，0表示指向孩子结点，1表示指向线索。初始化为0。 struct ThreadNode *lchild, *rchild; //左、右孩子指针。&#125; ThreadNode, *ThreadTree; 这里提出一些相关名词概念： 名词 解释 线索链表 以上面这种结点结构构成的二叉链表作为二叉树的存储结构。 线索 指向结点前驱和后继的指针。 线索二叉树 加上线索的二叉树，称之为线索二叉树 (Threaded Binary Tree)。 线索化 对二叉树以某种次序遍历使其变为线索二叉树的过程。 由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索， 而前驱或后继的信息只有在遍历时才能得到， 因此线索化的过程即为在遍历的过程中修改空指针的过程，可用递归算法。对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树，包括先序线索二叉树、中序线索二叉树和后序线索二叉树。以下我们将分别介绍三种序列实现的线索二叉树，以及代码实现。 中序线索二叉树 为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，而指针p指向当前访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就将它指向pre；检查pre的右指针是否为空，若为空就将它指向p，由此记录下遍历过程中访问结点的先后关系。如下图所示。 以结点p为根的子树中序线索化： 如果p非空，左子树递归线索化。 如果p的左孩子为空，则给p加上左线索，将其ltag置为1，让p的左孩子指针指向pre(前驱)； 如果pre的右孩子为空，则给pre加上右线索，将其rtag置为1，让pre的右孩子指针指向p(后继)； 将pre指向刚访问过的结点p，即pre=p。 右子树递归线索化。 123456789101112131415161718192021222324252627282930313233ThreadNode *pre;//中序遍历对二叉树线索化的递归算法void InThreading(ThreadTree p)&#123; if (p) &#123; InThreading(p-&gt;lchild); //左子树递归线索化 if (!p-&gt;lchild) //如果左子树为空 &#123; p-&gt;ltag = 1; p-&gt;lchild = pre; &#125; if (pre &amp;&amp; !pre-&gt;rchild) //此处需要判断第一次pre是否为空的情况。 &#123; pre-&gt;rtag = 1; //给pre加上右线索 pre-&gt;rchild = p; //pre的右孩子指针指向p (后继） &#125; pre = p; //保持pre指向p的前驱 InThreading(p-&gt;rchild); //右子树递归线索化 &#125;&#125;//调用此方法完成线索化void CreateInThread(ThreadTree T)&#123; if (T != NULL) &#123;//完成线索化后，pre指向中序遍历的最后一个结点。所以还需要对最后一个结点进行处理。 InThreading(T); pre-&gt;rchild = NULL; pre-&gt;rtag = 1; &#125;&#125; 在二叉树的线索链表上也可以添加一个头结点，并令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；同时，令二叉树中序序列中第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。如下图所示： 带头结点的二叉树中序线索化: 123456789101112131415//带头结点的中序线索化二叉树，相当于双向线索链表void InOrderThreading(ThreadTree Head,ThreadTree T)&#123; Head-&gt;ltag = 0; Head-&gt;rtag = 1; Head-&gt;rchild = Head; //初始化时右指针指向自己 if(!T) Head-&gt;lchild = Head; //若树为空，则左指针也指向自己 else&#123; Head-&gt;lchild = T; //头结点的左孩子指向根 pre = Head; //pre 初值指向头结点，可完成中序线索第一个结点指向头结点的功能 InThreading(T); //中序线索化二叉树 pre-&gt;rchild = Head; //线索化完，pre指向中序遍历的最后一个结点，最后一个结点rchild域的指针指向头结点 pre-&gt;rtag = 1; //pre的右标记为1 Head-&gt;rchild = pre; //头结点的rchild域的指针指向中序遍历时访问的最后一个结点 &#125;&#125; 对于线索二叉树的遍历，不能再像普通二叉树的遍历一样，因为会导致死循环。线索二叉树进行遍历时，需要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。 所以我们需要找到序列的第一个结点，以及序列的下一个结点（以不带头结点的线索化为例）。 1）查找p指针所指结点的前驱: 若p-&gt;ltag为1，则p的左链指示其前驱； 若p-&gt;ltag为0，则说明p有左子树，结点的前驱是遍历左子树时最后访问的一个结点（左子树中最右下的结点）。 2）查找p指针所指结点的后继: 若p-&gt;rtag为1，则p的右链指示其后继； 若p-&gt;rtag为0，则说明p有右子树。右子树访问的第一个结点就是下一个结点，即右子树中最左下的结点。 由以上的想法我们给出不含头结点的中序线索二叉树的中序遍历的算法： 12345678910111213141516//求中序线索二叉树中中序序列下的第一个结点ThreadNode* Firstnode(ThreadNode *p)&#123; while (p-&gt;ltag==0) //最左下结点 p = p-&gt;lchild; return p;&#125;//求中序线索二叉树中结点p在中序序列下的后继ThreadNode* Nextnode(ThreadNode *p)&#123; if(p-&gt;rtag==0) return Firstnode(p-&gt;rchild); else return p-&gt;rchild; //rtag==1 直接返回后继线索&#125;//中序线索二叉树的中序遍历void InOrder(ThreadNode *T)&#123; for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p)) cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;ltag&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;rtag&lt;&lt;endl;&#125; 先序线索二叉树 先序线索二叉树的思想类似，再先序遍历的基础上对二叉树进行线索化。构建出来的先序线索二叉树如下图所示。先序序列为ABCDF，其中将C的左链域指向前驱B，右链域指向后继D；结点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继F；结点F无左孩子，将左链域指向前驱D，无右孩子，也无后继故置空。 以结点p为根的子树先序线索化： 如果p非空，进行如下操作。 如果p的左孩子为空，则给p加上左线索，将其ltag置为1，让p的左孩子指针指向pre(前驱)； 如果pre不为空，并且pre的右孩子为空，则给pre加上右线索，将其rtag置为1，让pre的右孩子指针指向p(后继)； 将pre指向刚访问过的结点p，即pre=p。 若左指针不是线索，左子树递归线索化。 若右指针不是线索，右子树递归线索化。 12345678910111213141516171819202122232425262728293031323334ThreadNode *pre;//先序遍历对二叉树线索化的递归算法void PreThreading(ThreadTree p)&#123; if (p) &#123; if (!p-&gt;lchild) //如果左子树为空 &#123; p-&gt;ltag = 1; //给p加上左线索 p-&gt;lchild = pre; //p的左孩子指针指向pre (前驱） &#125; if (pre &amp;&amp; !pre-&gt;rchild) //此处需要判断第一次pre是否为空的情况。 &#123; pre-&gt;rtag = 1; //给pre加上右线索 pre-&gt;rchild = p; //pre的右孩子指针指向p (后继） &#125; pre = p; //保持pre指向p的前驱 if(p-&gt;ltag==0) //若p的左指针不是线索，再进行递归 PreThreading(p-&gt;lchild); //左子树递归线索化 if(p-&gt;rtag==0) //若p的右指针不是线索，再进行递归 PreThreading(p-&gt;rchild); //右子树递归线索化 &#125;&#125;//调用此方法完成线索化void CreatePreThread(ThreadTree T)&#123; if (T != NULL) &#123;//完成线索化后，pre指向先序遍历的最后一个结点。所以还需要对最后一个结点进行处理。 PreThreading(T); pre-&gt;rchild = NULL; pre-&gt;rtag = 1; &#125;&#125; 在先序线索二叉树中查找 1）查找p指针所指结点的前驱: 若p-&gt;ltag为1，则p的左链域指示其前驱； 若p-&gt;ltag为0，则说明p有左子树。此时p的前驱有两种情况：若*p是其双亲的左孩子，则其前驱为其双亲结点；否则应是其双亲的左子树上先序遍历最后访问到的结点。 2）查找p指针所指结点的后继: 若p-&gt;rtag为1，则p的右链指示其后继； 若p-&gt;rtag为0，则说明p有右子树。按先序遍历的规则可知，*p的后继必为其左子树根（若存在）或右子树根。 先序线索二叉树的先序遍历的算法实现： 123456789101112131415161718//求先序线索二叉树中结点p在先序序列下的后继ThreadNode* Nextnode(ThreadNode *p)&#123; if(p-&gt;rtag==1)&#123; return p-&gt;rchild; //rtag==1 直接返回后继线索 &#125; else&#123; if(p-&gt;lchild)&#123; //若存在左子树，则下一个后继为左子树根 return p-&gt;lchild; &#125; return p-&gt;rchild; //没有左子树，下一个后继为右子树根 &#125;&#125;//先序线索二叉树的先序遍历void PreOrder(ThreadNode *T)&#123; //先序遍历的第一个结点为根结点 for(ThreadNode *p=T;p!=NULL;p=Nextnode(p)) cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;ltag&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;rtag&lt;&lt;endl;&#125; 后序线索二叉树 后序线索二叉树的过程:后序序列为CDBFA，结点C无左孩子，也无前驱故置空，无右孩子，将右链域指向后继D；结点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继B；结点F无左孩子，将左链域指向前驱B，无右孩子，将右链域指向后继A，得到的后序线索二叉树如下图所示。 后序线索化的代码如下： 1234567891011121314151617181920//后序遍历对二叉树线索化的递归算法void PostThreading(ThreadTree p)&#123; if (p) &#123; PostThreading(p-&gt;lchild); //左子树递归线索化 PostThreading(p-&gt;rchild); //右子树递归线索化 if (!p-&gt;lchild) //如果左子树为空 &#123; p-&gt;ltag = 1; //给p加上左线索 p-&gt;lchild = pre; //p的左孩子指针指向pre (前驱） &#125; if (pre &amp;&amp; !pre-&gt;rchild) //此处需要判断第一次pre是否为空的情况。 &#123; pre-&gt;rtag = 1; //给pre加上右线索 pre-&gt;rchild = p; //pre的右孩子指针指向p (后继） &#125; pre = p; //保持pre指向p的前驱 &#125;&#125; 在后序线索二叉树中查找 1）查找p指针所指结点的前驱: 若p-&gt;ltag为1，则p的左链指示其前驱； 若p-&gt;ltag为0，当p-&gt;rtag也为0时，则p的右链指示其前驱。若-&gt;ltag为0，而p-&gt;rtag为1时，则p的左链指示其前驱。 2）查找p指针所指结点的后继情况比较复杂，分以下情况讨论： 若*p是二叉树的根， 则其后继为空； 若*p是其双亲的右孩子， 则其后继为双亲结点； 若 *p是其双亲的左孩子， 且 *p没有右兄弟， 则其后继为双亲结点； 若 *p是其双亲的左孩子，且 *p有右兄弟，则其后继为双亲的右子树上按后序遍历列出的第一个结点（ 即右子树中 “最左下” 的叶结点）。 可见在后序线索二叉树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。这里不再进行阐述。 树和森林 树的存储结构 树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍3种常用的存储结构。 双亲表示法 这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。 双亲表示法的存储结构描述如下: 123456789#define MAX_TREE_SIZE 100 //树中最多结点树typedef struct&#123; //树的结点定义 ElemType data; //数据元素 int parent; //双亲位置域&#125;PTNode;typedef struct&#123; //树的类型定义 PTNode nodes[MAX_TREE_SIZE]; //所有结点数组 int n; //结点数&#125;PTree; 该存储结构利用了每个结点(根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。 孩子表示法 孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表(叶子结点的孩子链表为空表)。不仅如此，还可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起。如下图所示(对应的树为双亲表示法的树)。 孩子兄弟法 孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容:结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点)，如下图所示(对应的树为双亲表示法的树)。 孩子兄弟表示法的存储结构描述如下: 12345// ---- 树的二叉链表（孩子-兄弟）存储表示 ----typedef struct CSNode&#123; ElemType data; struct CSNode *firstchild,*nextsibling; //第一个孩子和右兄弟指针&#125;CSNode,*CSTree; 这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。 森林与二叉树的转换 由于二叉树和树都可以用二叉链表作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树，可以找到唯一的一棵二叉树与之对应。从物理结构上看，它们的二叉链表是相同的，只是解释不同而已。 树转换成二叉树 从树的二叉链表表示的定义可知，任何一棵和树对应的二叉树，其根结点的右子树必空。这是因为根结点没有兄弟，所以对应的二叉树没有右子树。 树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称&quot;左孩子右兄弟&quot;。 森林转换成二叉树 将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子树……以此类推,就可以将森林转换为二叉树。 二叉树转换成森林 二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树,应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。 树和森林的遍历 树的遍历 如下图中所展示的树来说明一下相关的几种树遍历。 类型 描述 遍历序列 先根遍历 先访问树的根结点，然后依次先根遍历根的每棵子树。 ABEFCDG 后根遍历 先依次后根遍历每棵子树，然后访问根结点。（对应其转换成二叉树的中序遍历） EFBCGDA 层次遍历 按层序依次访问各结点。 ABCDEFG 森林的遍历 按照森林和树相互递归的定义，可得到森林的两种遍历方法。 类型 描述 遍历序列 先序遍历森林 ① 访问森林中第一棵树的根结点。② 先序遍历第一棵树中根结点的子树森林。③ 先序遍历除去第一棵树之后剩余的树构成的森林。 ABCDEFGHIJ 中序遍历森林 ① 中序遍历森林中第一棵树的根结点的子树森林。② 访问第一棵树的根结点。③ 中序遍历除去第一棵树之后剩余的树构成的森林。 BCDAFEHJIG 当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和中序遍历即为其对应二叉树的先序和中序遍历。 树与二叉树的应用 二叉排序树(BST) 二叉排序树的定义 二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树： 若左子树非空，则左子树上所有结点的值均小于根结点的值。 若右子树非空，则右子树上所有结点的值均大于根结点的值。 左、右子树也分别是一棵二叉排序树。 根据二叉排序树的定义，左子树结点值 &lt; 根结点值 &lt; 右子树结点值，所以对二叉排序树进行中序遍历，可以得到一个递增的有序序列。例如，下图所示二叉排序树的中序遍历序列为1 2 3 4 6 8。 二叉排序树的在c++中的定义与普通二叉树一样： 12345// ---- 二叉排序树的定义 ----typedef struct BSTNode&#123; int data; //这里我们使用int类型，也可以使用其它类型 BSTNode *lchild,*rchild; //定义左子树与右子树指针&#125;BSTNode,*BiTree; 二叉排序树的查找 二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。 二叉排序树的非递归查找算法: 12345678BSTNode* BST_Search(BiTree T,int key)&#123; while (T!=NULL &amp;&amp; key!=T-&gt;data) //当树空或等于根结点值，结束循环 &#123; if(key&lt;T-&gt;data) T = T-&gt;lchild; //小于，在左子树查找 else T = T-&gt;rchild; //大于，在右子树查找 &#125; return T;&#125; 二叉排序树的递归算法实现： 12345678BSTNode* BST_Search2(BiTree T,int key)&#123; if(T==NULL || key == T-&gt;data) //当树空或等于根结点值，结束递归 return T; if(key&lt;T-&gt;data) return BST_Search2(T-&gt;lchild,key); //值小于根结点，在左子树查找 else return BST_Search2(T-&gt;rchild,key); //值大于根结点，在右子树查找&#125; 二叉排序树的插入 插入结点的过程如下: 若原二叉排序树为空，则直接插入结点; 否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。 插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。 如下图所示，在一个二叉排序树中依次插入结点28和结点58，虚线表示的边是其查找的路径。 二叉排序树插入操作的算法描述如下: 123456789101112131415//若插入成功返回true，插入失败返回falsebool BST_Insert(BiTree &amp;T,int key)&#123; if(T==NULL)&#123; //若递归到根结点为空，则说明可以插入 T=(BiTree)malloc(sizeof(BSTNode)); T-&gt;data = key; T-&gt;lchild = T-&gt;rchild = NULL; return true; &#125;else if(key==T-&gt;data)&#123; //若树中存在相同关键字的结点，插入失败 return false; &#125;else if(key&lt;T-&gt;data)&#123; //若值小于结点，插入到其左子树 return BST_Insert(T-&gt;lchild,key); &#125;else&#123; //若值大于结点，插入到其右子树 return BST_Insert(T-&gt;rchild,key); &#125;&#125; 二叉排序树的构造 从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。设查找的关键字序列为{45,24,53,45,12,24}\\{45,24,53,45,12,24\\}{45,24,53,45,12,24}，则生成的二叉排序树如下图所示。 构造二叉排序树的算法描述如下: 123456789void Creat_BST(BiTree &amp;T,int keys[],int n)&#123;//keys是关键字序列，n表示其长度 T = NULL; //初始时T为空树 int i = 0; while (i&lt;n) &#123; //依次将每个关键字插入到二叉排序树中 BST_Insert(T,keys[i]); i++; &#125;&#125; 二叉排序树的删除 在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理: 若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱)，这样就转换成了第一或第二种情况。 下图显示了在3种情况下分别删除结点45,78,78的过程。 二叉排序树的删除算法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243bool BST_Delete(BiTree &amp;T,int key)&#123; BSTNode *z = BST_Search(T,key); //通过要删除的结点的值找到该结点 if(z==NULL) //若要删除的结点不存在，删除失败 return false; if(z-&gt;lchild==NULL &amp;&amp; z-&gt;rchild==NULL)&#123;//若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。 z = NULL; free(z); &#125;else if(z-&gt;lchild==NULL &amp;&amp; z-&gt;rchild!=NULL)&#123;//若结点z只有一棵右子树,让右子树代替z的位置 BSTNode *p = z-&gt;rchild; z-&gt;data = p-&gt;data; z-&gt;lchild = p-&gt;lchild; z-&gt;rchild = p-&gt;rchild; free(p); &#125;else if(z-&gt;rchild==NULL &amp;&amp; z-&gt;lchild!=NULL)&#123;//若结点z只有一棵左子树,让左子树代替z的位置 BSTNode *p = z-&gt;lchild; z-&gt;data = p-&gt;data; z-&gt;lchild = p-&gt;lchild; z-&gt;rchild = p-&gt;rchild; free(p); &#125;else&#123;//结点z有左、右两棵子树，则令z的直接后继替代z //1. 先找到z的右孩子的最下面的左孩子，即为右孩子的最小的那个(是z的直接后继) BSTNode *left = z-&gt;rchild; while (left-&gt;lchild != NULL)&#123; left = left-&gt;lchild; &#125; //2. 将右孩子的最下面的左孩子的数据赋给node z-&gt;data = left-&gt;data; //3. 处理这个直接后继结点，因为是最后的一个左孩子肯定没有左孩子， //所以如果该结点有右孩子，就将右孩子赋予改结点。否则将该结点置为NULL if (left-&gt;rchild != NULL)&#123; BSTNode *p = left-&gt;rchild; left-&gt;data = p-&gt;data; left-&gt;lchild = p-&gt;lchild; left-&gt;rchild = p-&gt;rchild; free(p); &#125; else&#123; left = NULL; free(left); &#125; &#125; return true;&#125; 二叉排序树的查找效率分析 从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树，如下图所示。 在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增加为元素个数n。 补充知识点： 等概率情况下，上图(a)查找成功的平均查找长度为：ASLa=(1+2×2+3×4＋4×3)/10=2.9ASL_a= (1 +2×2+3×4＋4×3)/10= 2.9ASLa​=(1+2×2+3×4＋4×3)/10=2.9 上图(b)查找成功的平均查找长度为：ASLb=(1+2＋3＋4＋5＋6＋7＋8+9+10)/10=5.5ASL_b=(1+2＋3＋4＋5＋6＋7＋8+9+ 10)/10= 5.5ASLb​=(1+2＋3＋4＋5＋6＋7＋8+9+10)/10=5.5 类型 从查找过程分析 从维护分析 适用情况 二叉排序树 查找效率取决于树的高度。输入序列决定了判定树的形态，故判定树不唯一，查找时间复杂度最好为O(log2n)O(log_2n)O(log2​n)，最坏为O(n)O(n)O(n)。 无须移动结点，只需修改指针即可完成插入和删除操作，平均执行时间为O(log2n)O(log_2n)O(log2​n)。 动态查找表 二分查找 判定树唯一，查找时间复杂度为O(log2n)O(log_2n)O(log2​n)。 二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的代价是O(n)。 静态查找表 平衡二叉树 平衡二叉树的定义 为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树(Balanced Binary Tree)，简称平衡树。 平衡因子：结点左子树与右子树的高度差。 平衡二叉树：平衡二叉树结点的平衡因子的值只可能是 -1、0或1。 平衡二叉树的插入 二叉排序树保证平衡的基本思想如下： 每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。 若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A。 再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。 注意： 每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。 平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况： LL平衡旋转(右单旋转) 由于在结点 A 的左孩子的左子树插入了新结点，导致A的平衡因子由1增至2，需要一次向右的旋转操作。右旋之后，B变为根结点，A变为B的右子树，B的原右子树按照大小次序，应作为A的左子树。 RR平衡旋转(左单旋转) 由于在结点 A 的右孩子的右子树插入了新结点，导致A的平衡因子由-1减至-2，需要一次向左的旋转操作。左旋之后，B变为根结点，A变为B的左子树，B的原左子树按照大小次序，应作为A的右子树。 LR平衡旋转(先左后右双旋转) 由于在结点 A 的左孩子的右子树插入了新结点，导致A的平衡因子由1增至2，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置。 RL平衡旋转(先右后左双旋转) 由于在结点 A 的右孩子的左子树插入了新结点，导致A的平衡因子由-1减至-2，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置。 平衡二叉树的查找 在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。因此平衡二叉树的平均查找长度为O(log2n)O(log_2n)O(log2​n)。 哈夫曼树和哈夫曼编码 哈夫曼树的基本概念 哈夫曼(Huffman)树又称最优树，是一类带权路径长度最短的树，在实际中有广泛的用途。 哈夫曼树的定义，涉及路径、路径长度、权等概念，下面先给出这些概念的定义，然后再介绍哈夫曼树。 名词 定义 路径 从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。 路径长度 路径上的分支数目称作路径长度。 树的路径长度 从树根到每一结点的路径长度之和。 权 赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。 结点的带权路径长度 从该结点到树根之间的路径长度与结点上权的乘积。 树的带权路径长度 树中所有叶子结点的带权路径长度之和，通常记作WPL=∑k=1nwklkWPL=\\sum\\limits_{k=1}^nw_kl_kWPL=k=1∑n​wk​lk​。 哈夫曼树 带权路径长度 WPL 最小的二叉树称做最优二叉树或哈夫曼树。 例如，下图中所示的3棵二叉树，都含4个叶子结点a、b、c 、d, 分别带权7、5、2、4，它们的带权路径长度分别为： 其中c树的WPL最小，可以验证，它恰好为哈夫曼树。 哈夫曼树的构造算法 给定n个权值分别为w1,w2,...,wnw_1,w_2,..., w_nw1​,w2​,...,wn​的结点，构造哈夫曼树的算法描述如下: 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。 从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 重复步骤2）和3)，直至F中只剩下一棵树为止。 从上述构造过程中可以看出哈夫曼树具有如下特点: 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。 构造过程中共新建了n-1个结点（双分支结点)，因此哈夫曼树的结点总数为2n-1。 每次构造都选择 2 棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。 例如，权值{7,5,2,4}\\{7,5,2,4\\}{7,5,2,4}的哈夫曼树的构造过程如下图所示。 哈夫曼算法的实现： 初始化：首先动态申请 2n 个单元；然后循环 2n-1 次，从 1 号单元开始，依次将 1 至 2n-1 所有单元中的双亲、左孩子、右孩子的下标都初始化为0; 最后再循环n次，输入前n个单元中叶子结点的权值。 创建树：循环 n-1 次，通过 n-1 次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为0且权值最小的两个树根结点 s1 和 s2；删除是指将结点 s1 和 s2 的双亲改为非0；合并就是将 s1 和 s2 的权值和作为一个新结点的权值依次存入到数组的第 n+1 之后的单元中，同时记录这个新结点左孩子的下标为 s1， 右孩子的下标为 s2。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//这里使用数组的方式顺序存储哈夫曼树，前n个位置存储了叶子结点，后n-1个位置存储了非叶子结点。//---- 哈夫曼树的存储表示 ----typedef struct&#123; int weight; //结点的权值 int parent,lchild,rchild; //结点的双亲、左孩子和右孩子的下标&#125;HTNode,*HuffmanTree; //动态分配数组存储哈夫曼树//选择两个其双亲域为0 且权值最小的结点，并返回它们在 HT 中的序号 sl和 s2void Select(HuffmanTree &amp;HT,int n,int &amp;s1,int &amp;s2)&#123; int min = Infinite; //找出最小值的下标 for(int i=1;i&lt;=n;i++)&#123; if(HT[i].parent==0 &amp;&amp; HT[i].weight&lt;min)&#123; s1 = i; min = HT[i].weight; &#125; &#125; min = Infinite; //找出值第二小的下标 for(int i=1;i&lt;=n;i++)&#123; if(HT[i].parent==0 &amp;&amp; HT[i].weight&lt;min &amp;&amp; i!=s1)&#123; s2 = i; min = HT[i].weight; &#125; &#125;&#125;void CreateHuffmanTree(HuffmanTree &amp;HT,int n)&#123; if(n&lt;=1) return; int m = 2*n-1; //n个叶子结点的哈夫曼树共有2n-1个结点。 HT = new HTNode[m+1]; //0号单元不用，动态分配m+1个单元。 for(int i=1;i&lt;=m;i++)&#123; //初始化1~m号单元 HT[i].parent = 0; HT[i].lchild = 0; HT[i].rchild = 0; &#125; for(int i=1;i&lt;=n;i++) //输入前n个单元中叶子结点的权值 cin&gt;&gt;HT[i].weight; //-------- 创建哈夫曼树 -------- for(int i=n+1;i&lt;=m;i++)&#123; int s1,s2; //在 HT[k] (k在1到i-1之间) 中选择两个其双亲域为0且权值最小的结点，并返回它们在 HT 中的序号 sl和 s2 Select(HT,i-1,s1,s2); HT[s1].parent = HT[s2].parent = i; //将两个最小的结点的父结点设置为下标i HT[i].lchild = s1; //将HT[i]的左孩子下标设置为s1 HT[i].rchild = s2; //将HT[i]的右孩子下标设置为s2 HT[i].weight = HT[s1].weight+HT[s2].weight; //HT[i]的权值为两个孩子权值之和 &#125;&#125; 哈夫曼编码 为了引出哈夫曼编码的思想，我们先说明一些概念： 名词 解释 固定长度编码 对每个字符用相等长度的二进制位表示。 可变长度编码 允许对不同字符用不等长的二进制位表示。 前缀编码 在一个编码方案中，没有一个编码是另一个编码的前缀。 光看上面的概念不是很好理解，我们来举例说明一下这些概念。 如a,b,c,d四个字符，我们若用二进制表示，可以表示为：a-&gt;00，b-&gt;01，c-&gt;10，d-&gt;11。这些字符编码的二进制位都相等，所以我们称其为固定长度编码。 倘若在一篇文章中，a出现了10次，b出现了6次，而c和d各只出现了2次，这时候我们再使用固定长度编码就变得不太聪明了。因为a出现的次数最多，我们完全可以使其用一个更短的编码如0表示，而b出现次数第二多，我们用1表示，c使用10，d使用11。这样我们得到的编码从整体上来说，就变得更短，压缩数据的效果就越好。这便是可变长度编码。 从上面介绍的可变长度编码可以观察出一些问题，就是解码的时候有多种可能性。比如01101，我们可以解码成adab也可以解码成abcb。这种情况的出现是因为b-&gt;1是c-&gt;10，d-&gt;11的前缀，所以我们解码得到的结果不唯一，这样显然是不行的，我们需要确保编码与解码的准确性。所以在一个编码方案中，当任一个编码都不是其他任何编码的前缀时，我们称为前缀编码。 了解到上面的概念后，我们来提出哈夫曼树实现哈夫曼编码的思路： 哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串， 该二进制串就称为哈夫曼编码。 由哈夫曼树得到哈夫曼编码很简单，我们将每个字符当作一个独立的结点，其权值为它出现的频度，然后构造哈夫曼树。将每个左分支置为0，右分支置为1，从根结点到叶子结点(该字符)的路径即为该字符的哈夫曼编码。 在构造好哈夫曼树之后，求哈夫曼编码编码的主要思想是：依次以叶子为出发点，向上回溯至根结点为止。 回溯时走左分支则生成代码0，走右分支则生成代码1。 根据哈夫曼树求哈夫曼编码的算法实现： 由哈夫曼树的构造算法得知，前n个元素记录的为叶子结点，后n-1个元素记录的为组件出来的父结点。所以我们遍历前n个叶子结点。 记录叶子结点的下标，和其父结点的下标，然后回溯判断子结点是父结点的左孩子还是右孩子，左孩子输出0，右孩子输出1。 循环上述操作，不断更新孩子结点和父结点的下标，直到结点的父结点下标为0，表示已经到根结点，停止循环。 1234567891011121314151617181920//在这里我们定义哈夫曼树的时候多加一个字符型的data域，用于记录结点是哪个字符。void CreateHuffmanCode(HuffmanTree HT,int n)&#123; int start; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;HT[i].data&lt;&lt;&#x27;:&#x27;; start = i; //从叶子结点开始 int p = HT[start].parent; //p为父结点的下标 while (p!=0)//当p的下标为0时结束，哈夫曼树下标从1开始记录 &#123; if(HT[p].lchild==start)&#123;//判断原子结点是父结点的左孩子还是右孩子 cout&lt;&lt;&#x27;0&#x27;&lt;&lt;&#x27; &#x27;; //左孩子输出0 &#125;else&#123; cout&lt;&lt;&#x27;1&#x27;&lt;&lt;&#x27; &#x27;; //右孩子输出1 &#125; start = p; //更新子结点 p = HT[p].parent; //更新父结点 &#125; cout&lt;&lt;endl; &#125;&#125; 由上述算法得到的哈夫曼编码为倒序输出的结果，因为是从叶子结点从下往上输出的，可以使用栈来逆转顺序，也可以使用容器或数组来存储哈夫曼编码的结果，此处不在阐述。 文件的编码和译码 (1) 编码：有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符c，在哈夫曼编码表HC中找到此字符，将字符c转换为编码表中存放的编码串。 (2) 译码：依次读入文件的二进制码，从哈夫曼树的根结点出发，读到0走左孩子，读到1走右孩子，一旦到达叶子结点将其数据输出即可。 树的应用—并查集","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构(严蔚敏)-第4章 串、数组和广义表","slug":"数据结构(严蔚敏)-第4章 串、数组和广义表","date":"2021-08-28T05:43:35.000Z","updated":"2021-08-31T00:01:26.443Z","comments":true,"path":"2021/08/28/数据结构(严蔚敏)-第4章 串、数组和广义表/","link":"","permalink":"https://alonscholar.github.io/2021/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC4%E7%AB%A0%20%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/","excerpt":"","text":"串、数组和广义表 计算机上的非数值处理的对象大部分是字符串数据， 字符串一般简称为串。串是一种特殊的线性表， 其特殊性体现在数据元素是一个字符， 也就是说， 串是一种内容受限的线性表。由于现今使用的计算机硬件结构是面向数值计算的需要而设计的， 在处理字符串数据时比处理整数和浮点数要复杂得多。而且， 在不同类型的应用中， 所处理的字符串具有不同的特点， 要有效地实现字符串的处理， 就必须根据具体情况使用合适的存储结构。多维数组和广义表可以看成是线性表的一种扩充， 即线性表的数据元素自身又是一个数据结构。 串的定义 串(string)(或字符串）是由零个或多个字符组成的有限序列， 一般记为：s=&quot;a1a2...an&quot;(n≥0)s=&quot;a_1a_2...a_n&quot; (n≥0)s=&quot;a1​a2​...an​&quot;(n≥0) s是串的名，用双引号括起来的字符序列是串的值； ai(1≤i≤n)a_i(1≤i≤n)ai​(1≤i≤n)可以是字母、数字或其他字符； 串中字符的数目n称为串的长度。零个字符的串称为空串(null string) , 其长度为零。 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。 通常称字符在序列中的序号为该字符在串中的位置。 子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。 称两个串是相等的， 当且仅当这两个串的值相等。 由一个或多个空格组成的串 &quot; &quot; 称为空格串 (blank string，请注意：此处不是空串）， 其长度为串中空格字符的个数。 我们用符号 &quot;ϕ&quot;&quot; \\phi &quot;&quot;ϕ&quot; 来表示空串。 串的类型定义、存储结构及其运算 串的抽象类型定义 串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。 然而，串的基本操作和线性表有很大差别。在串的基本操作中，通常以 “串的整体” 作为操作对象，如查找某个子串，插入一个子串，删除一个子串等等。 下面给出串的抽象数据类型定义： 123456789101112131415161718ADT String&#123; 数据对象：D=&#123;ai|ai∈CharacterSet,i=1,2,...,n,n&gt;=0&#125; 数据关系：Rl=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 基本操作： StrAssign(&amp;T, chars); //赋值操作。把串T赋值为chars。 StrCopy(&amp;T,S); //复制操作。由串S复制得到串T。 StrEmpty(S); //判空操作。若S为空串，则返回true，否则返回false。 StrCompare(S,T);//比较操作。若S&gt;T, 则返回值&gt;0;若S=T，则返回值=0; 若S&lt;T，则返回值&lt;0。 StrLength(S); //求串长。返回串S的元素个数。 SubString(&amp;Sub,S,pos,len); //求子串。用Sub返回串S的第pos个字符起长度为len的子串。 Concat(&amp;T,S1,S2); //串联接。用T返回由S1和S2联接而成的新串。 Index(S,T); //定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置;否则返回值为0。 ClearString(&amp;S); //清空操作。将S清为空串。 DestroyString(&amp;S); //销毁串。将串S销毁。 Replace(&amp;S,T,V); //用V替换主串S中出现的所有与T相等的不重叠的子串。 StrInsert(&amp;S,pos,T); //在串 S 的第 pos 个字符之前插人串 T。 StrDelete(&amp;S,pos,len); //从串 S 中删除第 pos 个字符起长度为 len 的子串。&#125;ADT String 串的存储结构 与线性表类似， 串也有两种基本存储结构：顺序存储和链式存储。但考虑到存储效率和算法的方便性， 串多采用顺序存储结构。 串的顺序存储 类似于线性表的顺序存储结构， 用一组地址连续的存储单元存储串值的字符序列。 按照预定义的大小， 为每个定义的串变量分配一个固定长度的存储区， 则可用定长数组如下描述： 1234567// －－－－－ 串的定长顺序存储结构－－－－－#define MaxLen 255 //串的最大长度typedef struct&#123; char ch[MaxLen]; //存储串的一维数组 int length; //串的当前长度&#125;SString; 这种定义方式是静态的， 在编译时刻就确定了串空间的大小。 而多数情况下， 在操作中串值长度的变化较大， 这样为串变量设定固定大小的空间不合理。 因此最好是根据实际需要， 在程序执行过程中动态地分配和释放字符数组空间。 在C语言中，存在一个称之为 “堆”（Heap） 的自由存储区，并用malloc ()和free ()函数来完成动态存储管理。利用 malloc() 为每个新产生的串分配一块实际串长所需的存储空间，若分配成功,则返回一个指向起始地址的指针，作为串的基地址，这个串由ch 指针来指示；若分配失败，则返回NULL。已分配的空间可用free()释放掉。 123456// －－－－－ 串的堆式顺序存储结构 －－－－－typedef struct&#123; char *ch; //若是非空串， 则按串长分配存储区， 否则 ch 为 NULL int length; //串的当前长度&#125;HString; 串的链式存储 类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。下图(a)是结点大小为4(即每个结点存放4个字符）的链表，图(b)是结点大小为1的链表。 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上 “#” 或其他的非串值字符（通常 “#” 不属于串的字符集，是一个特殊的符号）。 为了便于进行串的操作，当以链表存储串值时，除头指针外， 还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。定义如下： 1234567891011// －－－－－ 串的链式存储结构 －－－－－#define CHUNKSIZE 80 //可由用户定义的块大小typedef struct Chunk&#123; char ch[CHUNKSIZE]; struct Chunk *next;&#125;Chunk;typedef struct&#123; Chunk *head,*tail; //串的头和尾指针 int length; //串的当前长度&#125;LString; 在链式存储方式中，结点大小的选择直接影响着串处理的效率。存储密度小（如结点大小为1时），运算处理方便，然而，存储占用量大。如果在串处理过程中需进行内、 外存交换的话， 则会因为内外存交换操作过多而影响处理的总效率。 应该看到，串的字符集的大小也是一个重要因素。 一般来说，字符集小，则字符的机内编码就短，这也影响串值存储方式的选取。 串的模式匹配算法 子串的定位运算通常称为串的模式匹配或串匹配。此运算的应用非常广泛，比如在搜索引擎、拼写检查、 语言翻译、数据压缩等应用中， 都需要进行串匹配。 串的模式匹配设有两个字符串S和T, 设S为主串，也称正文串；设T为子串，也称为模式串。在主串S中查找与模式T相匹配的子串，如果匹配成功， 确定相匹配的子串中的第一个字符在主串S中出现的位置。 著名的模式匹配算法有BF算法和KMP算法， 下面详细介绍这两种算法。 一、BF算法 最简单直观的模式匹配算法是 BF (Brute-Force) 暴力匹配算法。 模式匹配不一定是从主串的第一个位置开始， 可以指定主串中查找的起始位置 pos。如果采用字符串顺序存储结构， 可以写出不依赖于其他串操作的匹配算法。 BF算法的主要思想为：从主串S的第一个字符起，与模式 T 的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起，重新和模式的字符比较；以此类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为与模式T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为零。 下面展示了模式 T=&quot;abcac&quot;和主串S的匹配过程，每次匹配失败后，都把模式 T 后移一位。 BF算法的步骤如下： 分别利用计数指针 i 和 j 指示主串 S 和模式 T 中当前正待比较的字符位置， i 初值为pos, j 初值为0。 如果两个串均未比较到串尾，即 i 和 j 均分别小于S和T的长度时，则循环执行以下操作： S[i] 和T[i] 比较，若相等，则i和j分别指示串中下个位置， 继续比较后续字符； 若不等，指针后退重新开始匹配， 从主串的下一个字符 (i=i-j+1) 起再重新和模式的第一个字符(j=0) 比较。 如果 j == T.length, 说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号 (i-T.length + 1); 否则称匹配不成功，返回0。 注意：我们上述图片展示的字符串下标是从1开始的，而我们的算法步骤分析和算法实现下标是从0开始的，最后返回值是序号(序号下标从1开始)。若想要返回值为字符串下标，则只需要当匹配成功时，返回 i - T.length ；匹配失败时，返回 -1 即可。 BF算法的代码实现： 1234567891011121314151617int Index_BF(string S,string T,int pos)&#123; int i = pos,j = 0; //在此我们的下标从0开始。 while (j&lt;T.length() &amp;&amp; i&lt;S.length()) &#123; if(S[i] == T[j])&#123; i++; j++; &#125;else&#123; i = i - j + 1; j = 0; &#125; &#125; if(j==T.length())&#123; //说明模式串匹配完了最后一个字符 return i - T.length() + 1; //返回的为匹配首字母在主串中的序号 &#125;else&#123; return 0; &#125;&#125; 最好情况的时间复杂度：每趟不成功的匹配都发生在模式串的第一个字符与主串中相应字符的比较。例如，S=“aaaaaba”，T=“ba”。设主串的长度为n, 子串的长度为m, 假设从主串的第i个位置开始与模式串匹配成功，则在前 i-1 趟匹配中字符总共比较了 i-1 次；若第 i 趟成功的字符比较次数为 m, 则总比较次数为 i - 1 + m。 对于成功匹配的主串， 其起始位置由 1 到 n-m+1, 假定这 n - m+1 个起始位置上的匹配成功概率相等，则最好的情况下匹配成功的平均比较次数为: ∑i=1n−m+1pi(i−1+m)=1n−m+1∑i=1n−m+1i−1+m=12(n+m)\\sum\\limits_{i=1}^{n-m+1}p_i(i-1+m)=\\frac {1} {n-m+1}\\sum\\limits_{i=1}^{n-m+1}i-1+m=\\frac{1}{2}(n+m)i=1∑n−m+1​pi​(i−1+m)=n−m+11​i=1∑n−m+1​i−1+m=21​(n+m) 即最好情况下的平均时间复杂度是 O(n + m)。 最坏情况的时间复杂度：每趟不成功的匹配都发生在模式串的最后一个字符与主串中相应字符的比较。例如，S=“aaaaaab”，T=“aab”。假设从主串的第 i 个位置开始与模式串匹配成功，则在前 i - 1 趟匹配中字符总共比较了 (i-1)*m 次；若第 i 趟成功的字符比较次数为m，则总比较次数 i * m。因此最坏情况下匹配成功的平均比较次数为：∑i=1n−m+1pi(i∗m)=1n−m+1∑i=1n−m+1i∗m=12m∗(n−m+2)\\sum\\limits_{i=1}^{n-m+1}p_i(i*m)=\\frac {1} {n-m+1}\\sum\\limits_{i=1}^{n-m+1}i*m=\\frac{1}{2}m*(n-m+2)i=1∑n−m+1​pi​(i∗m)=n−m+11​i=1∑n−m+1​i∗m=21​m∗(n−m+2) 即最坏情况下的平均时间复杂度是 O(n × m)。 二、KMP算法 这种改进算法是由 Knuth 、 Morris 和 Pratt 同时设计实现的， 因此简称 KMP 算法。 此算法相比于BF(暴力)算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。此算法可以在**O(n + m)**的时间数量级上完成串的模式匹配操作。 那么KMP是如何消除了主串指针的回溯问题呢？ 我们来分析一下下面介绍的情况： 我们可知，在上图中当主串A与模式B发生了失配时，若按照BF算法的执行情况，那么下一次比较时 i 指针会指向下一个元素，即B元素。j 指针会重新回到起点，即模式的A元素。显然这是没有必要的！倘若我们人为的去观测此字符串，那么我们会很自然的去选择让模式串的首位置A元素去匹配主串的第四个A元素。这样就完成了匹配。这便为KMP算法的精华所在。如下图所示： 至此，匹配成功。 由此可以看出，每次匹配失败后模式串移动的距离不一定是 1，某些情况下一次可移动多个位置，这就是 KMP 模式匹配算法。 那么如何判断匹配失败后模式串向后移动的距离呢？ 每次模式匹配失败后，计算模式串向后移动的距离是 KMP 算法中的核心部分。 其实，匹配失败后模式串移动的距离和主串没有关系，只与模式串本身有关系。 例如，我们将前面的模式串 B 改为 “ABCAE”，则在第一次模式匹配失败，由于匹配失败位置模式串中字符 ‘E’ 前面有两个字符 ‘A’，因此，第二次模式匹配应改为如下图所示的位置： 我们可以这样理解：因为模式串B在失配后前面的子串&quot;ABCA&quot;有一个相等的最大前后缀A，故进行下一次匹配时，可跳过此公共的最大前后缀A，直接让模式串的第2个元素B去与主串的下一个字符进行比较。 因此，我们可以给每个模式串配备一个数组（例如 next[]），用于存储模式串中每个字符对应指针 j 重定向的位置（也就是存储模式串的数组下标），比如 j=3，则表示该字符匹配失败后指针 j 指向模式串中第 3 个字符。 补充： 前缀字符串：指的是位于模式串起始位置的字符串，例如模式串 “ABCD”，则 “A”、“AB”、“ABC” 以及 “ABCD” 都属于前缀字符串； 后缀字符串：指的是位于串结尾处的字符串，还拿模式串 “ABCD” 来说，“D”、“CD”、“BCD” 和 “ABCD” 为后缀字符串。 模式串中各字符对应 next 值的计算方式是，取该字符前面的字符串（不包含自己），其前缀字符串和后缀字符串相同字符的最大个数再 +1 就是该字符对应的 next 值。 注意，模式串中第一个字符对应的值为 0，第二个字符对应 1 ，这是固定不变的。 我们给出模式串&quot;ABCAE&quot; 中，各字符对应的 next 值 ： 模式串 A B C A E next[]： 0 1 1 1 2 从上图可以看出，当字符 ‘E’ 匹配失败时，指针 j 指向模式串数组中第 2 个字符，即 ‘B’，同之前讲解的匹配思路不谋而合。 为了加深理解，我们再给出模式串&quot;abaabcac&quot;中，各字符对应的next值： j 1 2 3 4 5 6 7 8 模式串 a b a a b c a c next[j]： 0 1 1 2 2 3 1 2 下面给出KMP算法的代码实现： (1) 代码实现next数组构造。 我们首先明确一点，i 指向的是后缀表达式的末尾位置，j 指向的是前缀表达式的末尾位置。同时，指针j同样也表示现已经匹配的最大前后缀长度。 1234567891011121314151617181920// 通过模式串t获取其next数组void get_next(char *t, int *next)&#123; int i = 0, j = -1; next[0] = -1; while (i &lt; strlen(t)) &#123; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl; if (j == -1 || t[i] == t[j]) &#123; i++; j++; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125;&#125; (2) 代码实现KMP算法。 123456789101112131415161718192021//根据模式串的next数组返回模式串在主串中出现的下标(从0开始),若没有出现返回-1int kmp(char *s,char *t)&#123; int len = strlen(t); int next[len] = &#123;0&#125;; get_next(t, next); int i =0,j=0; int n = strlen(s),m = strlen(t); while (i&lt;n &amp;&amp; j&lt;m) &#123; if(j==-1 || s[i]==t[j])&#123; i++; j++; &#125;else&#123; j = next[j]; &#125; &#125; if(j&gt;=m) return i-j; return -1;&#125; 数组 数组的类型定义 数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受 n(n≥1) 个线性关系的约束，每个元素在 n 个线性关系中的序号i1,i2,…,ini_1,i_2,…,i_ni1​,i2​,…,in​称为该元素的下标，可以通过下标访问该数据元素。因为数组中每个元素处于 n(n≥1) 个关系中，故称该数组为 n 维数组。数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。 一维数组可以看成是一个线性表，二维数组可以看成数据元素是线性表的线性表。下图所示的二维数组可以看成是一个线性表。 数组一旦被定义， 它的维数和维界就不再改变。 因此， 除了结构的初始化和销毁之外， 数组只有存取元素和修改元素值的操作。 抽象数据类型数组可形式地定义为： 1234567891011ADT Array&#123; 数据对象：ji=0,...,bi-1,i=1,2,...,n, D = &#123;aj_1j_2...j_n | n(&gt;0)称为数组的维数，bi是数组第i维的长度， ji是数组元素的第j维的下标，aj_1j_2...j_n∈ElemSet&#125; 数据关系：R=&#123;R1,R2,...,Rn&#125; 基本操作： InitArray(&amp;A,boundi,...,boundn);//若维数n和各维长度合法，则构造相应的数组A,返回OK。 DestroyArray(&amp;A); //销毁数组A。 Value(A,&amp;e,index1,...,indexn);//若各下标不超界,则e赋值为所指定的A的元素值,返回OK。 Assign(&amp;A,e,index1,...,indexn);//若下标不超界,则将e的值赋给所指定的A的元素,返回OK。&#125;ADT Array 数组的顺序存储 由于数组一般不做插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。 因此，采用顺序存储结构表示数组比较合适。 存储方式 说明 图片表示 以列序为主序 假设每个数据元素占 L 个存储单元， 则二维数组 A[0…m-1, 0…n-1] (即下标从 0 开始， 共有m行n列) 中任一元素aija_{ij}aij​的存储位置可由下式确定：Loc(i,j)=Loc(0,0)+(i+j*m)L。 以行序为主序 假设每个数据元素占 L 个存储单元， 则二维数组 A[0…m-1, 0…n-1] (即下标从 0 开始， 共有m行n列) 中任一元素aija_{ij}aij​的存储位置可由下式确定：Loc(i,j)=Loc(0,0)+(n*i+j)L。 LOC(i,j)是aija_{ij}aij​的存储位置；LOC(0, 0) 是 a00a_{00}a00​的存储位置， 即二维数组 A 的起始存储位置，也称为基地址或基址。 特殊矩阵的压缩存储 压缩存储:指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是为了节省存储空间。 特殊矩阵:指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上(下）三角矩阵、对角矩阵等。 特殊矩阵的压缩存储方法:找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。 对称矩阵 若对一个n阶方阵A[ 1…n ] [ 1…n]中的任意一个元素ai,ja_{i,j}ai,j​,都有ai,j=aj,i(1≤i,j≤n)a_{i,j}= a_{j,i} ( 1≤i,j ≤n)ai,j​=aj,i​(1≤i,j≤n)，则称其为对称矩阵。对于一个n阶方阵，其中的元素可以划分为3个部分，即上三角区、主对角线和下三角区，如下图所示。 对于n阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将对称矩阵A [ 1…n ] [ 1…n]存放在一维数组B[n (n+1)/2]中，即元素ai,ja_{i,j}ai,j​存放在bkb_kbk​中。只存放下三角部分(含主对角）的元素。 在数组B中，前面的元素顺序为：a1,1,a2,1,a2,2,a3,1,a3,2,a3,3...a_{1,1},a_{2,1},a_{2,2},a_{3,1},a_{3,2},a_{3,3}...a1,1​,a2,1​,a2,2​,a3,1​,a3,2​,a3,3​... 压缩过后，元素ai,ja_{i,j}ai,j​在数组B中的下标 k=1＋2+…+(i -1)+j-1=i(i-1)/2+j-1(数组下标从0开始)。 因此，元素下标之间的对应关系如下: 对称矩阵的压缩存储代码实现： 12345678910111213141516171819202122232425262728// 将对称矩阵压缩为一维矩阵存储int* compress(int arr[4][4])&#123; int size = sizeof(arr[0]) / sizeof(arr[0][0]); int length = size * (1 + size) / 2; int *a; a = new int[length]; int i = 0; int index = 0; while (i&lt;size) &#123; for(int j=0;j&lt;=i;j++)&#123; a[index++] = arr[i][j]; &#125; i++; &#125; return a;&#125;// 将压缩后的一维数组，转换对应的二维数组的值int transfrom(int arr[],int i,int j)&#123; int k; if(i&gt;=j)&#123;//下对角区和主对角线元素 k = i*(i-1)/2+j-1; &#125;else&#123;//上对角区元素 k = j*(j-1)/2+i-1; &#125; return arr[k];&#125; 三角矩阵 下三角矩阵中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次，故可以将下三角矩阵A[ 1…n ] [ 1…n]压缩存储在B[n(n+1)/2+1]中。 上三角矩阵中，下三角区的所有元素均为同一常量。只需存储主对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储在B[n(n+1)/2+1]中。 矩阵类型 元素下标对应关系 内存中压缩存储形式 下三角矩阵 上三角矩阵 下面以下三角矩阵压缩存储为例，给出代码实现： 1234567891011121314151617181920212223242526272829303132// 将三角矩阵压缩为一维矩阵存储int *compress(int arr[4][4])&#123; int size = sizeof(arr[0]) / sizeof(arr[0][0]); int length = size * (1 + size) / 2; int *a; a = new int[length + 1]; int i = 0; int index = 0; while (i &lt; size) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[index++] = arr[i][j]; &#125; i++; &#125; a[length] = 0; return a;&#125;// 将压缩后的一维数组，转换对应的二维数组的值int transfrom(int arr[],int i,int j)&#123; int k; int n = 4; if(i&gt;=j)&#123;//下对角区和主对角线元素 k = i*(i-1)/2+j-1; &#125;else&#123;//上对角区元素 k = n*(n+1)/2; &#125; return arr[k];&#125; 三对角矩阵 三对角矩阵也称带状矩阵。对于n阶方阵A中的任一元素ai,ja_{i,j}ai,j​，当∣i−j∣&gt;1|i -j|&gt;1∣i−j∣&gt;1时，有ai,j=0(1≤i,j≤n)a_{i,j}=0 (1≤i, j ≤n)ai,j​=0(1≤i,j≤n)，则称为三对角矩阵，如下图所示。在三对角矩阵中，所有非零元素都集中在以主对角线为中心的3条对角线的区域，其他区域的元素都为零。 三对角矩阵A也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且 a1,1a_{1,1}a1,1​存放于B[0]中，其存储形式如下图所示。 由此可以计算矩阵A中3条对角线上的元素ai,j(1≤i,j≤n,∣i一j∣≤1)a_{i,j}(1≤i, j≤n,|i一 j|≤1)ai,j​(1≤i,j≤n,∣i一j∣≤1)在一维数组B中存放的下标为k=2i+j−3k= 2i+j-3k=2i+j−3。 反之,若已知三对角线矩阵中某元素ai,ja_{i,j}ai,j​存放于一维数组B的第k个位置,则可得i=[(k+1)/3+1],j=k–2i+3i=[(k+1)/3+1],j=k –2i+3i=[(k+1)/3+1],j=k–2i+3。 稀疏矩阵 矩阵中非零元素的个数t，相对矩阵元素的个数s来说非常少，即s&gt;&gt;t的矩阵称为稀疏矩阵。例如，一个矩阵的阶为100×100，该矩阵中只有少于100个非零元素。 若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元组(行标，列标，值)，如下图所示。然后再按照某种规律存储这些三元组。稀疏矩阵压缩存储后便失去了随机存取特性。 稀疏矩阵的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536void compress(int arr[5][4], int row, int col)&#123; int num = 0; //用于统计数组中不为0的个数 for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(arr[i][j]!=0)&#123; num++; &#125; &#125; &#125; int sparse[num+1][3]; //定义稀疏数组 //系数数组的第一行记录 行号，列号，总共元素个数 sparse[0][0] = row; sparse[0][1] = col; sparse[0][2] = num; int n = 1; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(arr[i][j]!=0)&#123; sparse[n][0] = i; sparse[n][1] = j; sparse[n][2] = arr[i][j]; n++; &#125; &#125; &#125; cout&lt;&lt;&quot;After the matrix is compressed: &quot;&lt;&lt;endl; for(int i=0;i&lt;num+1;i++)&#123; for(int j=0;j&lt;3;j++)&#123; cout&lt;&lt;sparse[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 稀疏矩阵的三元组既可以采用数组存储，也可以采用十字链表法存储。 广义表 广义表的定义 顾名思义，广义表是线性表的推广，也称为列表。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。 广义表一般记作：LS=(a1,a2,...,an)LS=(a_1,a_2,...,a_n)LS=(a1​,a2​,...,an​) 广义表的存储结构","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构(严蔚敏)-第3章 栈和队列","slug":"数据结构(严蔚敏)-第3章 栈和队列","date":"2021-08-24T05:43:35.000Z","updated":"2021-08-29T10:46:41.083Z","comments":true,"path":"2021/08/24/数据结构(严蔚敏)-第3章 栈和队列/","link":"","permalink":"https://alonscholar.github.io/2021/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC3%E7%AB%A0%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"栈和队列 栈和队列是两种重要的线性结构。从数据结构角度看， 栈和队列也是线性表， 其特殊性在于栈和队列的基本操作是线性表操作的子集， 它们是操作受限的线性表， 因此， 可称为限定性的数据结构。但从数据类型角度看，它们是和线性表不相同的两类重要的抽象数据类型。 栈和队列的定义和特点 栈的定义和特点 栈(Stack)是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作，如下图所示。 栈顶(Top)。 线性表允许进行插入删除的那一端。 表尾端。 栈底(Bottom)。固定的，不允许进行插入和删除的另一端。 表头端。 空栈。不含任何元素的空表。 假设某个栈S=(a1,a2,a3,a4,a5)S=(a_1,a_2, a_3,a_4,a_5)S=(a1​,a2​,a3​,a4​,a5​),如上图所示，则 a1a_1a1​为栈底元素，a5a_5a5​为栈顶元素。由于栈只能在栈顶进行插入和删除操作，进栈次序依次为a1,a2,a3,a4,a5a_1,a_2, a_3,a_4,a_5a1​,a2​,a3​,a4​,a5​,而出栈次序为a5,a4,a3,a2,a1a_5,a_4, a_3,a_2,a_1a5​,a4​,a3​,a2​,a1​。由此可见，栈的操作特性可以明显地概括为后进先出(Last In First Out，LIFO)。 栈的数学性质: n个不同元素进栈，出栈元素不同排列的个数为1n+1C2nn\\frac {1} {n+1}C{^n_{2n}}n+11​C2nn​。上述公式称为卡特兰(Catalan)数，可采用数学归纳法证明，有兴趣的读者可以参考组合数学教材。 队列的定义和特点 队列(Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队;删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（First In First Out，FIFO)，如下图所示。 队头 (Front)。允许删除的一端，又称队首。 队尾 (Rear)。允许插入的一端。 空队列。不含任何元素的空表。 假设队列为 q=(a1,a2,a3,a4,a5)q=(a_1,a_2,a_3,a_4,a_5)q=(a1​,a2​,a3​,a4​,a5​) 。那么，a1a_1a1​ 就是队头元素， a5a_5a5​则是队尾元素。队列中的元素是按照a1,a2,a3,a4,a5a_1,a_2,a_3,a_4,a_5a1​,a2​,a3​,a4​,a5​的顺序进入的，退出队列也只能按照这个次序依次退出。 栈的表示和操作的实现 栈的类型定义 栈的基本操作除了入栈和出栈外， 还有栈的初始化、 栈空的判定，以及取栈顶元素等。下面给出栈的抽象数据类型定义： 123456789101112131415ADT Stack&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 约定an端为栈顶，a1端为栈底。 基本操作： InitStack(&amp;S) //初始化一个空栈S。 DestroyStack(&amp;S) //销毁栈，并释放栈s占用的存储空间(”&amp;”表示引用调用)。 ClearStack(&amp;S) //将S清为空栈。 StackEmpty(S) //判断一个栈是否为空，若栈S为空则返回true,否则返回false。 StackLength(S) //返回S的元素个数，即栈的长度。 GetTop(S, &amp;x) //读栈顶元素，若栈s非空，则用x返回栈顶元素。 Push(&amp;S,x) //进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;S,&amp;x) //出栈，若栈S非空，则弹出栈顶元素，并用x返回。 StackTraverse(S) //从栈底到栈顶依次对S的每个数据元素进行访问。 &#125;ADT Stack 顺序栈的表示和实现 采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。 顺序栈的定义如下： 1234567// －－－－－ 顺序栈的存储结构－ －－－－#define MAXSIZE 100 //定义栈中元素的最大个数typedef struct &#123; Elemtype data[MAXSIZE]; //存放栈中元素 int top; //栈顶指针&#125;SqStack; 下图所示为顺序栈中数据元素和栈指针之间的对应关系。 栈顶指针: S.top，初始时设置S.top=-1; 栈顶元素:S.data[S.top]。 进栈操作: 栈不满时，栈顶指针先加1，再送值到栈顶元素。 出栈操作: 栈非空时，先取栈顶元素值，再将栈顶指针减1。 栈空条件: S.top==-1; 栈满条件: S.top==MaxSize-1; 栈长:S.top+1。 下面是顺序栈常用的基本操作的实现。 一、顺序栈的初始化 为顺序栈分配一个最大容量为MaxSize的数组空间。 栈顶指针初始为-1，表示栈空。 123456789#define MaxSize 10typedef struct&#123; char data[MaxSize]; int top;&#125;SqStack;void InitStack(SqStack &amp;S)&#123; S.top = -1;&#125; 二、顺序栈判栈空、栈满 当top指针指向-1时，栈为空。 当top指针指向MaxSize-1时，栈为满。因为数组下标从0开始。 123456bool StackEmpty(SqStack S)&#123; return S.top == -1;&#125;bool StackFull(SqStack S)&#123; return S.top == MaxSize-1;&#125; 三、顺序栈的入栈 判断栈是否满， 若满则返回false。 栈顶指针加1，将新元素压入栈顶 。 123456789bool Push(SqStack &amp;S,char val)&#123; if(StackFull(S))&#123; cout&lt;&lt;&quot;stack is full!&quot;&lt;&lt;endl; return false; &#125;else&#123; S.data[++S.top] = val; return true; &#125;&#125; 四、顺序栈的出栈 判断栈是否空，若空则返回false。 栈顶元素出栈，栈顶指针减1。 123456789bool Pop(SqStack &amp;S,char &amp;val)&#123; if(StackEmpty(S))&#123; cout&lt;&lt;&quot;stack is empty!&quot;&lt;&lt;endl; return false; &#125;else&#123; val = S.data[S.top--]; return true; &#125;&#125; 五、取顺序栈的栈顶元素 判断栈是否空，若空则返回false。 因为栈顶指针指向的就是栈顶元素的位置，所以返回S.data[S.top]的元素即可。 123456789bool GetTop(SqStack &amp;S,char &amp;val)&#123; if(StackEmpty(S))&#123; cout&lt;&lt;&quot;stack is empty!&quot;&lt;&lt;endl; return false; &#125;else&#123; val = S.data[S.top]; return true; &#125;&#125; 链栈的表示和实现 采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead 指向栈顶元素，如下图所示。 链栈的定义如下： 123456// －－－－－ 链栈的存储结构－－－－－typedef struct LinkNode&#123; Elemtype data; //数据域 struct LinkNode *next; //指针域&#125;*LinkStack; 由于栈的主要操作是在栈顶插入和删除， 显然以链表的头部作为栈顶是最方便的， 而且没必要像单链表那样为了操作方便附加一个头结点。 下面给出链栈部分操作的实现。 一、链栈的初始化 链栈的初始化操作就是构造一个空栈， 因为没必要设头结点，所以直接将栈顶指针置空即可。 1234void InitStack(LinkStack &amp;S)&#123; S=NULL;&#125; 二、链栈的入栈 为入栈元素 e 分配空间， 用指针 p 指向。 将新结点数据域置为e。 将新结点插入栈顶。 修改栈顶指针为 p。 1234567void Push(LinkStack &amp;S,char e)&#123; p = new LinkNode; //p定义全局变量 ，LinkNode *p; p-&gt;data = e; p-&gt;next = S; S = p;&#125; 链栈入栈过程如下图所示： 三、链栈的出栈 判断栈是否为空 ，若空则返回false。 将栈顶元素赋给e。 临时保存栈顶元素的空间， 以备释放。 修改栈顶指针， 指向新的栈顶元素。 释放原栈顶元素的空间。 123456789bool Pop(LinkStack &amp;S,char &amp;e)&#123; if(S==NULL) return false; e = S-&gt;data; p = S; S = S-&gt;next; free(p); return true;&#125; 链栈的出栈过程如下图所示： 四、取链栈的栈顶元素 判断栈是否为空 ，若空则返回false。 返回栈顶指针S指向的值，用e进行保存。 123456789bool GetTop(LinkStack S,char &amp;e)&#123; if(S!=NULL) &#123; e = S-&gt;data; return true; &#125; return false;&#125; 共享栈 利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示。 两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空;仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满。当0号栈进栈时top0 先加1再赋值，1号栈进栈时top1先减1再赋值;出栈时则刚好相反。 共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。其存取数据的时间复杂度均为O(1)，所以对存取效率没有什么影响。 队列的表示和操作的实现 队列的类型定义 队列的操作与栈的操作类似，不同的是，删除是在表的头部（即队头）进行。 下面给出队列的抽象数据类型定义： 123456789101112131415ADT Queue&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 约定a1端为队列头，an端为队列尾。 基本操作： InitQueue(&amp;Q) //初始化队列,构造一个空队列Q。 DestroyQueue(&amp;Q) //销毁队列。 ClearQueue(&amp;Q) //将Q清为空队列。 QueueEmpty(Q) //判队列空，若队列Q为空返回true，否则返回false。 QueueLength(Q) //返回Q的元素个数，即队列的长度。 GetHead(Q,&amp;x) //读队头元素，若队列Q非空，则将队头元素赋值给x。 EnQueue(&amp;Q,x) //入队，若队列Q未满，将x加入，使之成为新的队尾。 DeQueue(&amp;Q,&amp;x) //出队，若队列Q非空，删除队头元素，并用x返回。 QueueTraverse(Q) //从队头到队尾，依次对Q的每个数据元素访问。 &#125;ADT Queue 循环队列—队列的顺序表示和实现 和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变量 front 和 rear 分别指示队列头元素及队列尾元素的位置（后面分别称为头指针和尾指针）。 队列的顺序存储结构表示如下： 1234567// －－－－－ 队列的顺序存储结构－ －－－－#define MAXSIZE 100 //队列可能达到的最大长度typedef struct &#123; Elemtype data[MAXSIZE]; //存放队列元素 int front,rear; //队头指针和队尾指针&#125;SqQueue; 在此约定：初始化创建空队列时，令 front = rear = 0 , 每当插入新的队列尾元素时，尾指针 rear 增1; 每当删除队列头元素时，头指针 front 增1。因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置，如下图所示。 初始状态（队空条件): Q.front == Q.rear == 0。 进队操作: 队不满时，先送值到队尾元素，再将队尾指针加1。 出队操作: 队不空时，先取队头元素值，再将队头指针加1。 思考： 能否用Q.rear==MaxSize作为队列满的条件呢? 答：显然不能，如上图(d)所示，队列中仅有两个元素，但仍满足该条件。这时候入队出现“上溢出” ，但这种溢出并不是真正的溢出，在data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。 怎么解决这种 “假溢出” 问题呢？一个巧妙的办法就是将顺序队列变为一个环状的空间，如下图所示，称之为循环队列。 初始时: Q.front = Q.rear = 0。 队首指针进1: Q.front = (Q.front+1)%MaxSize。 队尾指针进1: Q.rear = (Q.rear+1 )%MaxSize。 队列长度: (Q.rear+MaxSize-Q.front ) %MaxSize。 新问题： 循环队列队空和队满的判断条件是什么呢？因为队空条件是 Q.front == Q.rear 。而且当入队时有可能出现上图(d)的情况，此时也有Q.front == Q.rear。 那么如何区别队满还是队空呢？ 为了区分队空还是队满的情况，给出三种处理方式进行参考： 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队头指针在队尾指针的下一位置作为队满的标志”，如上图(d2)所示。 此时队满条件为： (Q.rear+1) %MaxSize == Q.front。队空条件仍为： Q.front == Q.rear。 类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size == 0;队满的条件为Q.size == MaxSize。这两种情况都有 Q.front == Q.rear。 类型中增设tag 数据成员，以区分是队满还是队空。tag 等于0时，若因删除导致Q.front == Q.rear，则为队空; tag等于1时，若因插入导致Q.front == Q.rear，则为队满。 下面给出用第一种方法实现循环队列的操作。 一、循环队列的初始化 为队列分配一个最大容量为MaxSize的数组空间。 头指针和尾指针置为零， 表示队列为空。 1234567891011#define MaxSize 10typedef struct&#123; char data[MaxSize]; //存放队列元素 int front, rear; //队头指针和队尾指针&#125; SqQueue;void InitQueue(SqQueue &amp;Q)&#123; Q.front = Q.rear = 0;&#125; 二、求循环队列的长度 对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列，差值可能为负数，所以需要将差值加上MaxSize, 然后与MaxSize求余。 123int QueueLength(SqQueue Q)&#123; return (Q.rear - Q.front + MaxSize)%MaxSize;&#125; 三、循环队列的入队 判断队列是否满，若满则返回false。 将新元素插入队尾。 队尾指针加1。 1234567891011bool enQueue(SqQueue &amp;Q, char val)&#123; if (isFull(Q)) // 队满 (Q.rear + 1) % MaxSize == Q.front; &#123; cout &lt;&lt; &quot;queue is full!&quot; &lt;&lt; endl; return false; &#125; Q.data[Q.rear] = val; Q.rear = (Q.rear+1) % MaxSize; return true;&#125; 四、循环队列的出队 判断队列是否为空， 若空则返回false。 保存队头元素。 队头指针加1。 1234567891011bool deQueue(SqQueue &amp;Q, char &amp;val)&#123; if (isEmpty(Q)) //队空 Q.front == Q.rear; &#123; cout &lt;&lt; &quot;queue is empty!&quot; &lt;&lt; endl; return false; &#125; val = Q.data[Q.front]; Q.front = (Q.front+1) % MaxSize; return true;&#125; 五、取循环队列的队头元素 判断队列是否为空， 若空则返回false。 返回队头元素。 1234567bool GetHead(SqQueue Q,char &amp;val)&#123; if(isEmpty(Q))&#123; return false; &#125; val = Q.data[Q.front]; return true;&#125; 链队—队列的链式表示和实现 队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同)。队列的链式存储如下图所示。 这里和线性表的单链表一样， 为了操作方便起见，给链队添加一个头结点， 并令头指针始终指向头结点。队列的链式存储结构表示如下： 12345678// －－－－－ 队列的链式存储结构－－－－－typedef struct LinkNode&#123; //链式队列结点 ElemType data; struct LinkNode *next;&#125;LinkNode;typedef struct&#123; //链式队列 LinkNode *front,*rear; //队列的队头和队尾指针&#125;LinkQueue; 链队的操作即为单链表插入和删除操作的特殊情况， 只是需进一步修改尾指针或头指针。下面给出链队初始化、 入队、 出队等操作的实现。 链队的基本操作实现如下。 一、链队的初始化 生成新结点作为头结点， 队头和队尾指针指向此结点。 头结点的指针域置空。 1234void InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode)); Q.front-&gt;next = NULL;&#125; 二、链队的入队 为入队元素分配结点空间，用指针s指向。 将新结点数据域置为val。 将新结点插入到队尾 。 修改队尾指针为s。 1234567void enQueue(LinkQueue &amp;Q,char val)&#123; LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode)); s-&gt;data = val; s-&gt;next = NULL; Q.rear-&gt;next = s; Q.rear = s;&#125; 链队的入队即为普通单链表的尾插法，可理解为向尾部插入一个元素，这里不再画图阐述，请读者自行脑补。 三、链队的出队 判断队列是否为空，若空则返回false。 临时保存队头元素的空间，以备释放。 修改队头指针，指向下一个结点。 判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值， 指向头结点。 释放原队头元素的空间。 1234567891011121314bool deQueue(LinkQueue &amp;Q,char &amp;val)&#123; if(isEmpty(Q))&#123; cout&lt;&lt;&quot;Queue is Empty!&quot;&lt;&lt;endl; return false; &#125; LinkNode *p = Q.front-&gt;next; val = p-&gt;data; Q.front-&gt;next = p-&gt;next; if(Q.rear == p) //判断出队元素是否为最后一个元素，细心点，不要遗漏。 Q.rear = Q.front; free(p); return true;&#125; 链队的出队可理解为从单链表中将第一个元素(首元结点)删除的过程，值得注意的是，链队出队操作时还要考虑当队列中最后一个元素被删后，队列尾指针也丢失了，因此需对队尾指针重新赋值（指向头结点）。 四、取链队的队头元素 判断队列是否为空，若空则返回false。 返回队头元素。 12345bool GetHead(LinkQueue Q)&#123; if(isEmpty(Q)) return false; return Q.front-&gt;next-&gt;data;&#125; 双端队列 双端队列是指允许两端都可以进行入队和出队操作的队列，如下图所示。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。 在双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。 输出受限的双端队列 ： 允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列，如下图所示。 输入受限的双端队列 ： 允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列,如下图所示。 若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。 栈和队列的实际应用 栈在进制转换中的应用 想一下，我们在十进制转为其他进制的时候的做法，除取余数法，大致过程如下图所示： 每次除以进制d，然后取余，最后将余数从下至上排列即为d进制数。这刚好符合了栈的特性，每次将取余的数入栈，最后依次出栈，这样刚好将取余的数反过来输出了，这样就实现了十进制转换为d进制数。在这里我们简单实现一个十进制转八进制的函数： 123456789101112131415void conversion(int N)&#123; //对于任意一个非负十进制数，打印输出与其等值的八进制数 stack&lt;int&gt; stack; //这里采用c++内置的栈。 while (N) &#123; stack.push(N%8); N/=8; &#125; while (!stack.empty()) &#123; cout&lt;&lt;stack.top()&lt;&lt;&quot; &quot;; stack.pop(); &#125;&#125; 显然， 该算法的时间和空间复杂度均为 O(log8n)O(log_8n)O(log8​n)。 栈在括号匹配中的应用 假设表达式中允许包含两种括号:圆括号和方括号，其嵌套的顺序任意即 ([]())( []( ) )([]()) 或 [([][])][([][])][([][])] 等均为正确的格式，[)])[)])[)])或 ([())([())([()) 或 (()](()](()] 均为不正确的格式。 考虑下列括号序列： 分析： 计算机接收第1个括号 “[” 后，期待与之匹配的第8个括号 “]” 出现。 获得了第2个括号 “(”，此时第1个括号 “[” 暂时放在一边，而急迫期待与之匹配的第7个括号 “)” 出现。 获得了第3个括号 “[”，此时第2个括号 “(” 暂时放在一边，而急迫期待与之匹配的第4个括号 “]” 出现。第3个括号的期待得到满足，消解之后，第2个括号的期待匹配又成为当前最急迫的任务。 以此类推，可见该处理过程与栈的思想吻合。 实现括号匹配的算法的思想如下： 初始设置一个空栈，顺序读入括号。 若是左括号直接入栈。 如果是右括号，则分为如下几种情况： 栈空，表明没有可以和这个右括号匹配的元素，返回false。 栈不空，从栈中弹出元素，查看弹出括号是否与该右括号匹配。若不匹配，则返回false。 最后，判断栈是否为空，若栈不空表明栈中还有左括号未得到匹配，返回false，若栈空，表明所有括号都得到了匹配，返回true。 12345678910111213141516171819202122232425262728293031323334// 匹配括号bool Matching(char s[])&#123; LiStack S = (LiStack)malloc(sizeof(LiStack)); //初始化栈 S-&gt;next = NULL; char val; //用于记录栈中弹出的元素。 for (int i = 0; i &lt; strlen(s); i++) //遍历字符串 &#123; //cout&lt;&lt;s[i]&lt;&lt;endl; if (s[i] == &#x27;(&#x27; || s[i] == &#x27;[&#x27; || s[i] == &#x27;&#123;&#x27;) //遇到左括号直接入栈 &#123; PushStack(S, s[i]); &#125; else &#123; if (isEmpty(S)) &#123; // 如果不是左括号，并且此时栈中没有可以和右括号匹配的元素，则匹配失败 return false; &#125; PopStack(S, val); if ((s[i] == &#x27;)&#x27; &amp;&amp; val == &#x27;(&#x27;) || (s[i] == &#x27;]&#x27; &amp;&amp; val == &#x27;[&#x27;) || (s[i] == &#x27;&#125;&#x27; &amp;&amp; val == &#x27;&#123;&#x27;)) &#123; // 此情况说明匹配成功，进入判断下一个括号 &#125; else &#123; return false; &#125; &#125; &#125; //最后，倘若循环走完了，栈中还有左括号没有匹配成功，则说明不符合 return isEmpty(S);&#125; 此算法的时间复杂度与空间复杂度均取决于字符串的长度，所以都为O(n)。 栈在表达式求值中的应用 表达式求值是程序设计语言编译中一个最基本的问题，它的实现是栈应用的一个典型范例。中缀表达式不仅依赖运算符的优先级，而且还要处理括号。后缀表达式的运算符在操作数后面，在后缀表达式中已考虑了运算符的优先级，没有括号，只有操作数和运算符。中缀表达式 A+B∗(C−D)−E/FA+B * (C-D)-E/FA+B∗(C−D)−E/F 所对应的后缀表达式为 ABCD−∗+EF/−ABCD-*+EF/-ABCD−∗+EF/−。 通过后缀表示计算表达式值的过程: 顺序扫描表达式的每一项，然后根据它的类型做如下相应操作:若该项是操作数，则将其压入栈中；若该项是操作符&lt;op&gt;&lt;op&gt;&lt;op&gt;,则连续从栈中退出两个操作数 Y 和 X ，形成运算指令X&lt;op&gt;YX&lt;op&gt;YX&lt;op&gt;Y，并将计算结果重新压入栈中。当表达式的所有项都扫描并处理完后,栈顶存放的就是最后的计算结果。 下面给出后缀表达式 ABCD−∗+EF/−ABCD-*+EF/-ABCD−∗+EF/− 通过栈求值的过程。 注意：在上图中，当遇到操作运算符时，设先出栈的数为A，后出栈的数为B，在A与B进行运算时，应为 B&lt;op&gt;AB &lt;op&gt; AB&lt;op&gt;A。 由以上分析我们可以得知，当我们知道一个中缀表达式对应的后缀表达式之后，表达式求值的过程就会变的十分简单。所以我们接下来主要讨论的问题就是如何将中缀表达式转换成后缀表达式。 我们给出中缀表达式转换为后缀表达式的具体步骤： 扫描中缀表达式，遇到操作数。直接加入后缀表达式（输出或者使用数组存储都可以）。 遇到运算符或界限符，若栈空则直接入栈。否则分为以下两种情况： 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 &quot; ( &quot; 或者栈空则停止。之后再把当前运算符入栈。 遇到界限符。遇到 &quot; ( &quot; 直接入栈；遇到 &quot; ) &quot; 则依次弹出栈内的运算符并加入后缀表达式，直到弹出 &quot; ( &quot; 为止。注意：&quot; ( &quot; 直接弹出即可，不需要加入后缀表达式。 以上中缀转后缀的过程中，我们可以把 “依次弹出栈中优先级高于或等于当前运算符的所有运算符” 直接理解为当遇到 −-− 和 +++ 时，就弹出栈中运算符加入后缀表达式。因为 −-− 和 +++ 在加减乘除四个运算符中优先级就是最小的。 我们给出中缀表达式转换为后缀表达式的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960string expression; //用于输入中缀表达式stack&lt;char&gt; op_stack; //用于存储运算符的栈vector&lt;string&gt; suffix_vec; //用于存储后缀表达式//中缀转后缀表达式void InfixToSuffix(string s)&#123; string num = &quot;&quot;; //用于拼接多位数 string op =&quot;&quot;; //用于转换字符类型的操作符 for(int i=0;i&lt;s.length();i++)&#123; if(s[i]&gt;=&#x27;0&#x27; &amp;&amp; s[i]&lt;=&#x27;9&#x27;)&#123;//遇到操作数。直接加入后缀表达式 num+=s[i]; //先进行多位数的拼接处理 if(i == s.length()-1 || s[i+1]&lt;&#x27;0&#x27; || s[i+1]&gt;&#x27;9&#x27;)&#123; //cout&lt;&lt;num&lt;&lt;&quot; &quot;; suffix_vec.push_back(num); num = &quot;&quot;; &#125; &#125;else if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27; || s[i]==&#x27;*&#x27; || s[i]==&#x27;/&#x27; || s[i]==&#x27;(&#x27; || s[i]==&#x27;)&#x27;)&#123; if(op_stack.empty())&#123;//栈空则直接入栈 op_stack.push(s[i]); &#125;else&#123; if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27;)&#123;//遇到运算符,依次弹出栈中优先级高于或等于当前运算符的所有运算符 while (!op_stack.empty() &amp;&amp; op_stack.top()!=&#x27;(&#x27;)//若碰到 &quot; ( &quot; 或者栈空则停止 &#123; //cout&lt;&lt;op_stack.top()&lt;&lt;&quot; &quot;; op = op_stack.top(); suffix_vec.push_back(op); //将运算符转换为string op_stack.pop(); &#125; op_stack.push(s[i]);//之后再把当前运算符入栈 &#125;else if(s[i]==&#x27;*&#x27; || s[i]==&#x27;/&#x27;)&#123;// *和/的运算级最高，直接入栈 op_stack.push(s[i]); &#125;else&#123; if(s[i]==&#x27;(&#x27;)&#123; op_stack.push(s[i]); &#125;else&#123;// s[i] == &#x27;)&#x27; , 依次弹出栈内的运算符并加入后缀表达式，直到弹出 &quot; ( &quot; 为止。 while (op_stack.top()!=&#x27;(&#x27;)//直到弹出 &quot; ( &quot; 为止。 &#123; //cout&lt;&lt;op_stack.top()&lt;&lt;&quot; &quot;; op = op_stack.top(); suffix_vec.push_back(op); //将运算符转换为string op_stack.pop(); &#125; op_stack.pop(); //将 ( 出栈 &#125; &#125; &#125; &#125;else&#123; cout&lt;&lt;&quot;输入表达式格式错误&quot;&lt;&lt;endl; break; &#125; &#125; //将最终栈中的运算符输出 while (!op_stack.empty()) &#123; //cout&lt;&lt;op_stack.top()&lt;&lt;&quot; &quot;; op = op_stack.top(); suffix_vec.push_back(op); //将运算符转换为string op_stack.pop(); &#125;&#125; 注意：在上述代码中，其中得到的后缀表达式使用了vector类型的容器进行存放，并且进行了一个多位数拼接的处理。拼接多位数的思想即为：先将扫描到的数字保存，不立即存储至后缀表达式，而是直到扫描到的数字的下一个字符是运算符（说明此时这个数字已经处理完毕），才加入后缀表达式。 在得到了后缀表达式之后，我们只需要根据我们之前分析的思路，扫描后缀表达式，并通过一个栈来存储计算结果。每当遇到操作符便从栈中弹出两个运算数，进行求值后再入栈，最后栈顶元素即为最终表达式的值，编码如下： 12345678910111213141516//通过得到的后缀表达式进行求值void Calculator()&#123; stack&lt;int&gt; s; for(auto it=suffix_vec.begin();it != suffix_vec.end();it++)&#123; if(*it==&quot;+&quot;||*it==&quot;-&quot;||*it==&quot;*&quot;||*it==&quot;/&quot;)&#123; int a = s.top(); s.pop(); int b = s.top(); s.pop(); int val = GetValue(b,a,*it); //封装的一个方法，返回 b &lt;op&gt; a 的值 s.push(val); &#125;else&#123;//如果是数字则直接入栈 int num = stoi(*it); //将string转换为int s.push(num); &#125; &#125; cout&lt;&lt;s.top()&lt;&lt;endl;&#125; 栈在递归中的应用 递归是一种重要的程序设计方法。简单地说，若在一个函数、过程或数据结构的定义中又应用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。 它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。但在通常情况下，它的效率并不是太高。 我们以斐波那契数列为例,其定义为 ： 这就是递归的一个典型例子，用程序实现时如下: 123456789int Fib(int n)&#123; if(n==0) return 0; else if(n==1) return 1; else return Fib(n-1) + Fib(n-2);&#125;//我们输出前十项：0 1 1 2 3 5 8 13 21 34 必须注意递归模型不能是循环定义的，其必须满足下面的两个条件: 递归表达式（递归体）。 边界条件（递归出口）。 在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很多重复的计算。下面以n=5为例，列出递归调用执行过程，如下图所示。 显然，在递归调用的过程中，Fib(3)被计算了2次，Fib(2)被计算了3次。Fib(1)被调用了5次，Fib(0)被调用了3次。所以，递归的效率低下，但优点是代码简单，容易理解。可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。 队列在层次遍历中的应用 在信息处理中有一大类问题需要逐层或逐行处理。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，待当前层或当前行处理完毕，就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。下面用二叉树层次遍历的例子，说明队列的应用。 该过程的简单描述如下: 根结点入队。 若队空（所有结点都已处理完毕)，则结束遍历;否则重复步骤3。 队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队;若其有右孩子, 则将右孩子入队,返回步骤2。 队列在计算机系统中的应用 队列在计算机系统中的应用非常广泛，以下仅从两个方面来简述队列在计算机系统中的作用:第一个方面是解决主机与外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。 对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，由于速度不匹配，若直接把输出的数据送给打印机打印显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。 对于第二个方面，CPU(即中央处理器，它包括运算器和控制器）资源的竞争就是一个典型的例子。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把 CPU分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又使CPU能够正常运行。 栈和队列的比较","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构(严蔚敏)-第2章 线性表","slug":"数据结构(严蔚敏)-第2章 线性表","date":"2021-08-23T02:43:35.000Z","updated":"2021-08-29T12:38:04.070Z","comments":true,"path":"2021/08/23/数据结构(严蔚敏)-第2章 线性表/","link":"","permalink":"https://alonscholar.github.io/2021/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC2%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表 线性表、栈、队列、串和数组都属于线性结构。 线性结构的基本特点是除第一个元素无直接前驱，最后一个元素无直接后继之外，其他每个数据元素都有一个前驱和后继。线性表是最基本且最常用的一种线性结构， 同时也是其他数据结构的基础， 尤其单链表，是贯穿整个数据结构课程的基本技术。 线性表的定义和特点 线性表：由n(n≥0)n(n≥0)n(n≥0)个数据特性相同的元素构成的有限序列。 空表：线性表中元素个数为0时，称为空表。 对于非空的线性表或线性结构， 其特点是： 存在唯一的一个被称作 ＂第一个＂ 的数据元素； 存在唯一的一个被称作＂ 最后一个＂ 的数据元素； 除第一个之外， 结构中的每个数据元素均只有一个前驱； 除最后一个之外，结构中的每个数据元素均只有一个后继。 线性表的类型定义 线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，而且可以进行插入和删除等操作。下面给出线性表的抽象数据类型定义： 123456789101112131415ADT List&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n&gt;=0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 基本操作： InitList(&amp;L); //初始化表。构造一个空的线性表L，分配内存空间。 DestroyList(&amp;L); //销毁操作。销毁线性表，并释放线性表L所占用的内存空间。 ClearList(&amp;L); //清空操作。将L重置为空表。 ListInsert(&amp;L,i,e); //插入操作。在表L中的第i个位置上插入指定元素e。 ListDelete(&amp;L,i,&amp;e); //删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。 LocateElem(L,e); //按值查找操作。在表L中查找具有给定关键字值的元素。 GetE1em(L,i); //按位查找操作。获取表L中第i个位置的元素的值。 Length(L); //求表长。返回线性表L的长度，即L中数据元素的个数。 PrintList(L); //输出操作。按前后顺序输出线性表L的所有元素值。 Empty(L); //判空操作。若L为空表，则返回true，否则返回false。&#125;ADT List 注： 抽象数据类型仅是一个模型的定义，并不涉及模型的具体实现，因此这里描述中所涉及的参数不必考虑具体数据类型。在实际应用中，数据元素可能有多种类型，到时可根据具体需要选择使用不同的数据类型。 上述抽象数据类型中给出的操作只是基本操作，由这些基本操作可以构成其他较复杂的操作。 对于不同的应用， 基本操作的接口可能不同。 由抽象数据类型定义的线性表， 可以根据实际所采用的存储结构形式， 进行具体的表示和实现。 线性表的顺序表示和实现 线性表的顺序存储表示 线性表的顺序存储又称顺序表。 顺序存储表示 ： 用一组地址连续的存储单元依次存储线性表中的数据元素（这种表示也称作线性表的顺序存储结构或顺序映像），从而使得逻辑上相邻的两个元素在物理位置上也相邻。 假设线性表L存储的起始位置为LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如下图所示： 注意：线性表中的元素的位序是从1开始的，而数组中元素的下标是从0开始的。 线性表的顺序存储结构是一种随机存取的存储结构，即通过首地址和元素序号可以在O(1) 时间内找到指定的元素 由于线性表的长度可变，且所需最大存储空间随问题的不同而不同，在C语言中通常使用动态分配的一维数组表示线性表 : 123456// －－－－－ 顺序表的存储结构－－－－－#define MAXSIZE 100 //顺序表可能达到的最大长度typedef struct &#123; ElemType *elem; //存储空间的基地址，类型可以是int、float、char... int length; //当前长度&#125; SqList; //顺序表的结构类型为SqList 顺序表中基本操作的实现 一、顺序表初始化 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。 将表的当前长度设为0。 12345void InitList(SqList &amp;L)&#123; //用malloc函数申请一片连续的存储空间,malloc返回连续空间的首地址 L.data = (int *)malloc(InitSize * sizeof(int)); L.length=0;&#125; 二、顺序表取值 判断指定的位置序号 i 值是否合理 (1≤i≤L.length1≤i≤L.length1≤i≤L.length), 若不合理，则返回false。 若 i 值合理，则将第 i 个数据元素 L.elem[i-1] 赋给参数 e, 通过 e 返回第 i 个数据元素的传值。 12345bool GetElem(SqList L,int i,int &amp;e)&#123; // 时间复杂度 O(1) if(i&lt;1 || i&gt;L.length) return false; //如果越界，则返回false e = L.data[i-1]; // i是位序，elem[i-1] 单元存储第 i 个数据元素 return true;&#125; 三、顺序表的按值查找 从第一个元素起，依次和 e 相比较，若找到与 e相等的元素 L.elem[i], 则查找成功，返回该元素的序号 i+1 (数组下标从 0 开始)。 若查遍整个顺序表都没有找到，则查找失败， 返回0。 1234567int locateElem(SqList L,int e)&#123; int i; for(i=0;i&lt;L.length;i++) if(L.data[i]==e) return i+1; return 0;&#125; 最好时间复杂度：O(1)。查找元素在第一个，仅需比较一次。 最坏时间复杂度：O(n)。查找元素在最后一个，需比较n次。 平均时间复杂度：由平均查找长度公式： ASL=∑i=1npiCiASL=\\sum\\limits_{i=1}^np_iC_iASL=i=1∑n​pi​Ci​，以及在这里每个元素的查找概率相等pi=1/np_i=1/npi​=1/n。得 ASL=1n∑i=1ni=n+12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^ni = \\frac{n+1}{2}ASL=n1​i=1∑n​i=2n+1​。由此可见，顺序表按值查找的平均时间复杂度为O(n)。 四、顺序表插入元素 判断插入位置序号 x 值是否合理 (1≤x≤L.length+11≤x≤L.length+11≤x≤L.length+1), 若不合理，则返回false。 判断顺序表的存储空间是否已满，若满则返回 false。 将第L.length个至第 x 个位置的元素依次向后移动一个位置，空出第 x 个位置(x=L.length+1 时无需移动）。 将要插入的新元素e放入第x个位置。 表长加1。 12345678910111213141516/* 在x位置插入元素data x ---&gt; 位序 从顺序表最后一个到x之后都往后移动一位*/bool insertList(SqList &amp;L,int x,int data)&#123; if(x&lt;1 || x&gt;L.length+1) //x值不合法 return false; if(L.length&gt;=MaxSize) //当前存储空间已满 return false; for(int i=L.length;i&gt;=x;i--) L.data[i]=L.data[i-1]; L.data[x-1]=data; L.length++; return true;&#125; 最好时间复杂度： 在表尾插入（即x=L.length+1），元素后移语句将不执行，时间复杂度为O(1)； 最坏时间复杂度： 在表头插入（即x=1），元素后移语句将执行n次，时间复杂度为O(n)； 平均时间复杂度： 假设 pi(pi=1/(n+1))p_i(p_i=1/(n+1))pi​(pi​=1/(n+1)),是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为：∑i=1n+1pi(n−i+1)=∑i=1n+11n+1(n−i+1)=1n+1∑i=1n+1(n−i+1)=1n+1n(n+1)2=n2\\sum\\limits_{i=1}^{n+1}p_i(n-i+1)=\\sum\\limits_{i=1}^{n+1}\\frac {1} {n+1}(n-i+1)=\\frac {1} {n+1}\\sum\\limits_{i=1}^{n+1}(n-i+1)=\\frac {1} {n+1}\\frac {n(n+1)} {2}=\\frac {n} {2}i=1∑n+1​pi​(n−i+1)=i=1∑n+1​n+11​(n−i+1)=n+11​i=1∑n+1​(n−i+1)=n+11​2n(n+1)​=2n​ 因此，线性表插入算法的平均时间复杂度为O(n) 。 五、顺序表删除元素 判断删除位置 x 值是否合理 (1≤x≤L.length1≤x≤L.length1≤x≤L.length), 若不合理，则返回false。 将第x+1个至第L.length个的元素依次向前移动一个位置(x = L.length时无需移动）。 表长减1。 1234567891011bool deleteList(SqList &amp;L,int x)&#123; if(x&lt;1||x&gt;L.length) //判断i的范围是否有效 return false; int e = L.data[x-1]; for(int i=x;i&lt;L.length;i++)&#123;//将第x+1个位置后的元素前移 L.data[i-1] = L.data[i]; &#125; L.length--; printf(&quot;删除了%d位置的元素：%d\\n&quot;,x,e); return true;&#125; 最好时间复杂度： 删除表尾元素（即x=L.length），无须移动元素，时间复杂度为O(1)； 最坏时间复杂度： 删除表头元素(即 x= 1)，需移动除第一个元素外的所有元素，时间复杂度为O(n)。 平均时间复杂度： 假设pi(pi=1/n)p_i (p_i= 1/n)pi​(pi​=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为: ∑i=1npi(n−i)=∑i=1n1n(n−i)=1n∑i=1n(n−i)=1nn(n−1)2=n−12\\sum\\limits_{i=1}^{n}p_i(n-i)=\\sum\\limits_{i=1}^{n}\\frac {1} {n}(n-i)=\\frac{1}{n}\\sum\\limits_{i=1}^{n}(n-i)=\\frac {1} {n}\\frac {n(n-1)} {2}=\\frac {n-1} {2}i=1∑n​pi​(n−i)=i=1∑n​n1​(n−i)=n1​i=1∑n​(n−i)=n1​2n(n−1)​=2n−1​ 因此,线性表删除算法的平均时间复杂度为O(n)。 线性表的链式表示和实现 链式存储结构的特点：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的），存放数据元素的结点至少包括两个域（数据域、指针域），指针域中存储的信息称作指针或链。n个结点链接成一个链表，即为线性表的链式存储结构。 单链表的定义和表示 当链表的每个结点中只包含一个指针域，又称线性链表或单链表。 首元结点：即链表中存储第一个数据元素的结点。 最后一个结点的指针为NULL 头结点：是在首元素结点之前附设的一个结点，其指针指向首元结点。其数据域可以不存储任何信息。 头指针：指向链表中的第一个结点的存储位置。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。 是否带头结点 链表为空时的情况（L为头指针） 单链表的逻辑状态表示 不带头结点 L == NULL 带头结点 L -&gt; next == NULL 由上述可见，单链表可由头指针唯一确定，在C语言中可用 “结构指针&quot; 来描述： 123456//－－－－－ 单链表的存储结构－－－－－typedef struct LNode&#123; ElemType data; //结点的数据域 struct LNode *next; //结点的指针域&#125;LNode,*LinkList; //LinkList 为指向结构体 LNode 的指针类型 注： 为了提高程序的可读性，在此对同一结构体指针类型起了两个名称，LinkList与 LNode* , 两者本质上是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode* 定义指向单链表中任意结点的指针变量。 利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。 单链表的基本操作的实现 一、 单链表的初始化 生成新结点作为头结点，用头指针L 指向头结点。 头结点的指针域置空。 12345bool InitList(LinkList &amp;L)&#123; L = new LNode; //生成新结点作为头结点， 用头指针L指向头结点 L-&gt;next = NULL; //头结点的指针域置空 return true;&#125; 二、单链表的取值 用指针p指向首元结点，用 j 做计数器初值赋为1。 从首元结点开始依次顺着链域 next 向下访问，只要指向当前结点的指针 p 不为空(NULL), 并且没有到达序号为 i 的结点，则循环执行以下操作： p指向下一个结点； 计数器 j 相应加1。 退出循环时， 如果指针p为空， 或者计数器 j 大于 i, 说明指定的序号 i 值不合法（i 大于表长n或 i 小于等于0), 取值失败返回NULL; 否则取值成功， 此时 j=i 时，p所指的结点就是要找的第 i 个结点，返回该结点。 1234567891011121314151617LNode *GetElem(LinkList L, int i)&#123; int j = 1; LNode *p = L-&gt;next; if (i == 0) // 如果i=0，则返回头结点 &#123; return L; &#125; if (i &lt; 0) return NULL; while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; j++; &#125; return p; //返回第i个结点的指针，若i大于表长则返回NULL&#125; 最好时间复杂度：O(1)。i=0或i=1，查找元素为头结点或者是首元结点，仅需比较一次。 最坏时间复杂度：O(n)。查找元素不存在，需比较n次。 平均时间复杂度：假设每个元素的查找概率相等pi=1/np_i=1/npi​=1/n。得 ASL=1n∑i=1n(i−1)=n−12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^n(i-1) = \\frac{n-1}{2}ASL=n1​i=1∑n​(i−1)=2n−1​。由此可见，顺序表按值查找的平均时间复杂度为O(n)。 三、单链表的按值查找 用指针p指向首元结点 。 从首元结点开始依次顺着链域next向下查找， 只要指向当前结点的指针p不为空， 并且p所指结点的数据域不等于给定值e, 则循环执行以下操作： p指向下一个结点 。 返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL 。 123456789LNode *LocateElem(LinkList L, int e)&#123; LNode *p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != e) &#123; p = p-&gt;next; &#125; return p;&#125; 平均时间复杂度：该算法与按序号查找类似，与待查找的值 e 相关，复杂度为 O(n)。 四、单链表的插入 在单链表中要插入元素，只需更改各结点的指针域即可，需要进行如下图的操作： 将值为e的新结点插入到表的第 i 个结点的位置上，即插入到结点 ai−1a_{i-1}ai−1​与aia_iai​之间。 查找结点 ai−1a_{i-1}ai−1​ 并由指针p指向该结点 。 生成一个新结点*s 。 将新结点*s 的数据域置为 e 。 将新结点*s 的指针域指向结点aia_iai​。 将结点 *p 的指针域指向新结点 *s 。 123456789101112131415LinkList insertNode(LinkList &amp;L, int i, int e)&#123; //获取i-1位置的元素 LNode *p = GetElem(L, i - 1); if(p==NULL)&#123;//说明输入的位置不合法 cout&lt;&lt;&quot;请输入正确的位置&quot;&lt;&lt;endl; return L; &#125; //此时p直线第i-1位置的元素 LNode *s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return L;&#125; 平均时间复杂度：与顺序表的插入操作相比，复杂度仍为 O(n)，但是省略了顺序表移动元素的步骤，只需要从头到尾比较一遍链表即可。注意，头插法可以到达O(1)的时间复杂度。 五、单链表的删除 在单链表中要删除元素，只需更改各结点的指针域即可，需要进行如下图的操作： 删除单链表的第 i 个结点aia_iai​。 查找结点 ai−1a_{i-1}ai−1​ 并由指针p指向该结点 。 临时保存待删除结点 aia_iai​ 的地址在 q 中 ，以备释放。 将结点 *p 的指针域指向 aia_iai​ 的直接后继结点 。 释放结点aia_iai​的空间 。 12345678LinkList deleteNode(LinkList &amp;L, int i)&#123; LNode *p = GetElem(L, i - 1); LNode *q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); return L;&#125; 平均时间复杂度：类似于插入算法，删除算法时间复杂度亦为 O(n)； 六、创建单链表 (1) 前插法 创建一个只有头结点的空链表。 根据待创建链表包括的元素个数n, 循环n次执行以下操作： 生成一个新结点 *s; 输入元素值赋给新结点*s 的数据域； 将新结点 *s 插入到头结点之后。 1234567891011121314151617LinkList List_HeadInsert(LinkList &amp;L)&#123; L = new LNode; L-&gt;next = NULL; LNode *s; int x; scanf(&quot;%d&quot;, &amp;x); while (x != 0) //当输入0时表示不再添加元素 &#123; s = (LNode *)malloc(sizeof(LNode)); //开辟一块新的LNode区域。 s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s; scanf(&quot;%d&quot;, &amp;x); &#125; return L;&#125; (2) 后插法 创建一个只有头结点的空链表。 尾指针 r 初始化， 指向头结点。 根据创建链表包括的元素个数n, 循环n次执行以下操作： 生成一个新结点*s; 输入元素值赋给新结点*s 的数据域； 将新结点 *s 插入到尾结点 *r 之后； 尾指针 r 指向新的尾结点 *s。 1234567891011121314151617LinkList List_TailInsert(LinkList &amp;L)&#123; int x; L = (LinkList)malloc(sizeof(LNode)); LNode *s, *r = L; //r用于记录表尾结点 scanf(&quot;%d&quot;, &amp;x); while (x != 0) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s; scanf(&quot;%d&quot;, &amp;x); &#125; r-&gt;next = NULL; //表尾结点置空 return L;&#125; 循环链表 循环链表(CircularLinked List)：是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他结点，下图所示为单链的循环链表。类似地，还可以有多重链的循环链表。 循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL或p-&gt;next!=NULL,而循环单链表的判别条件为p!=L或p-&gt;next!=L 若在循环链表中设立尾指针而不设立头指针，可使一些操作简化。如将两个线性表进行合并，仅需将第一个表的尾指针指向第二个表的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。 循环双链表： 由循环单链表的定义不难推出循环双链表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点，如下图所示。 在循环双链表L中，某结点*p为尾结点时，p-&gt;next==L; 当循环双链表为空表时，其头结点的prior域和next域都等于L。 双向链表 单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。 为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next,分别指向其前驱结点和后继结点，如下图所示。 在C语言中可描述如下： 1234567// - - - - -双向链表的存储结构－－－－－typedef struct DuLNode&#123; ElemType data; //数据域 struct DuLNode *prior; //直接前驱 struct DuLNode *next; //直接后继&#125;DuLNode,*DuLinkList; 在双向链表中， 有些操作（如 ListLength、GetElem 和 LocateElem 等）仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针，下图分别显示了插入和删除结点时指针修改的情况。 在插入结点时需要修改四个指针，在删除结点时需要修改两个指针。两者的时间复杂度均为 O(n)。 一、双向链表的插入 1234567891011121314151617DLinkList insertNode(DLinkList &amp;L,int i,int val)&#123; DNode *p = getElem(L,i-1); if(p==NULL)&#123; cout&lt;&lt;&quot;插入位置不合法&quot;&lt;&lt;endl; return L; &#125; DNode *s = (DNode*)malloc(sizeof(DNode)); //开辟一个空间 s-&gt;data = val; //执行插入操作 s-&gt;next = p-&gt;next; if(p-&gt;next!=NULL) //倘若不是最后一个结点 p-&gt;next-&gt;prior = s; s-&gt;prior = p; p-&gt;next = s; return L;&#125; 二、双向链表的删除 12345678910111213DLinkList deleteNode(DLinkList &amp;L,int i)&#123; DNode *p = getElem(L,i-1); if(p==NULL)&#123; cout&lt;&lt;&quot;输入位置不合法&quot;&lt;&lt;endl; return L; &#125; DNode *q = p-&gt;next; if(q-&gt;next!=NULL) q-&gt;next-&gt;prior = p; p-&gt;next = q-&gt;next; free(q); return L;&#125; 单链表、循环链表和双向链表的比较 顺序表和链表的比较","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构(严蔚敏)-第1章 绪论","slug":"数据结构(严蔚敏)-第1章 绪论","date":"2021-08-22T14:43:35.000Z","updated":"2021-08-26T03:24:19.943Z","comments":true,"path":"2021/08/22/数据结构(严蔚敏)-第1章 绪论/","link":"","permalink":"https://alonscholar.github.io/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC1%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"绪论 早期的计算机主要用于数值计算，现在，计算机主要用于非数值计算，包括处理字符、表格和图像等具有一定结构的数据。这些数据内容存在着某种联系，只有分清楚数据的内在联系，合理地组织数据，才能对它们进行有效的处理，设计出高效的算法。如何合理地组织数据、高效地处理数据，这就是 “数据结构” 主要研究的问题。本章简要介绍有关数据结构的基本概念和算法分析方法。 数据结构的研究内容 数据的各种逻辑结构和物理结构，以及他们之间的相应关系 对每种结构定义相适应的各种运算 设计出相应的算法 分析算法的效率 基本概念和术语 数据、数据对象、数据元素和数据项 名词 解释 数据 (Data) 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。（整数、实数、字符串、图形、图像、声音及动画…） 数据对象 (Data Object) 是性质相同的数据元素的集合，是数据的一个子集。 数据元素(Data Element) 是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。 在有些情况下，数据元素也称为元素、记录等。数据元素用于完整地描述一个对象，如一名学生记录，图中的一个顶点等。 数据项 (Data Item) 是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。 数据结构 数据结构 (Data Structure) 是相互之间存在一种或多种特定关系的数据元素的集合。 数据结构包括逻辑结构和存储结构两个层次。 逻辑结构 数据的逻辑结构有两个要素：一是数据元素；二是关系。 逻辑结构分为四种类型：集合结构，线性结构，树形结构，图形结构。 类型 简述 图片 集合结构 数据元素同属一个集合，单个数据元素之间没有任何关系。 线性结构 类似于线性关系，线性结构中的数据元素之间是一对一的关系。 树结构 树形结构中的数据元素之间存在一对多的关系。（各元素及元素关系所组成图形类似于树状图）。 图结构 数据元素之间是多对多的关系。 存储结构 物理结构又叫存储结构，分为两种，一种是顺序存储结构，一种是链式存储结构。 类型 简述 图片 顺序存储结构 顺序存储结构是把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的。之前学习的数组就是一种顺序存储结构 链式存储结构 链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。根据指针找出相邻元素的位置 数据类型和抽象数据类型 类型 描述 数据类型 一般包括整型、实型、字符型等原子类型外，还有数组、结构体和指针等结构类型。 抽象数据类型 抽象数据类型 (Abstract Data Type, ADT) 一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合。如C语言中的结构体以及 C++、Java中的类。 算法和算法分析 算法的定义及特性 算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。 一个算法必须满足以下五个重要特性。 特性 描述 有穷性 一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。 确定性 对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性， 使算法的执行者或阅读者都能明确其含义及如何执行。 可行性 算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。 输入 一个算法有零个或多个输入。 输出 一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有意义。 评价算法优劣的基本标准 名称 描述 正确性 在合理的数据输入下，能够在有限的运行时间内得到正确的结果。 可读性 一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。 健壮性 当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。 高效性 高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。 算法的时间复杂度 衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。 因为事后统计法的缺点很明显，需要将算法实现等等，所以我们通常采用事前分析估算法。 问题规模和语句频度 问题规模 是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。 语句频度(FrequencyCount)是一条语句的重复执行的次数。 一个算法的执行时间大致上等于其所有语句执行时间的总和， 而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。 12345678// 例：求两个n阶矩阵的乘积算法。i记录行号，j记录列号for(i=1;i&lt;=n;i++) //频度为 n+1 for(j=1;j&lt;=n;j++) //频度为 n*(n+1) &#123; c[i][j] = 0; //频度为 n*n for(k=1;k&lt;=n;k++) //频度为 n*n*(n+1) c[i][j] = c[i][j]+a[i][k]*b[k][j]; //频度为 n*n*n &#125; 该算法中所有语句频度之和， 是矩阵阶数n的函数， 用 f(n)表示之。换句话说， 上例算法的执行时间与f(n)成正比。 f(n)=2n3+3n2+2n+1f(n)=2n^3+3n^2+2n+1f(n)=2n3+3n2+2n+1 算法的时间复杂度定义 ​ 当算法比较复杂时，我们往往不能通过所有语句频度之和来测量算法的时间复杂度。所以我们这里提出了基本语句的概念，所谓 “基本语句” 指的是算法中重复执行次数和算法的执行时间成正比的语句， 它对算法运行时间的贡献最大。 ​ 如上述代码中，因为 lim⁡n→∞f(n)/n3=lim⁡n→∞(2n3+3n2+2n+1)/n3=2\\lim\\limits_{n\\to\\infty}f(n)/n^3 = \\lim\\limits_{n\\to\\infty}(2n^3+3n^2+2n+1)/n^3=2n→∞lim​f(n)/n3=n→∞lim​(2n3+3n2+2n+1)/n3=2，所以我们称 f(n) 和 n3n^3n3是同阶的，我们用“O”来表示数量级，记作 T(n)=O(f(n))=O(n3)T(n)=O(f(n))=O(n^3)T(n)=O(f(n))=O(n3)。 ​ 随问题规模n的增大，算法执行时间的增长率和 f(n)的增长率相同，称做算法的渐近时间复杂度， 简称时间复杂度(TimeComplexity)。 算法的时间复杂度分析举例 ​ 分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句， 计算基本语句的频度得到问题规模n的某个函数 f(n), 取其数量级用符号&quot;O&quot;表示即可。具体计算数量级时， 可以遵循以下定理。 定理1.1 若 f(n)=amnm+am−1nm−1+…+a1n+a0f(n)=a_mn^m+a_{m-1}n^{m-1}+…+a_1n+a_0f(n)=am​nm+am−1​nm−1+…+a1​n+a0​。 是一个m次多项式， 则T(n)=O(nm)T(n)=O(n^m)T(n)=O(nm)。 123456789101112131415161718192021// 举例说明如何求非递归算法的时间复杂度// --------- O(1) --------------&#123;x++;s=0;&#125; for(i=0;i&lt;10000;i++)&#123;x++;s=0;&#125; //时间复杂度均为O(1)// --------- O(n) --------------for(i=0;i&lt;n;i++)&#123;x++;s=0;&#125; //问题规模随着n的增加而增加,T(n)=O(n)// --------- O(n*n) -------------x=0;y=0; // O(1)for(k=1;k&lt;=n;k++) // O(n+1) x++; // O(n)for(i=1;i&lt;=n;i++) // O(n+1) for(j=1;j&lt;=n;j++) // O(n*(n+1)) y++; // O(n*n)// --------- O(n*n*n) -------------x=1;for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 常见的时间复杂度：O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n)O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(2^n)O(1)&lt;O(log2​n)&lt;O(n)&lt;O(nlog2​n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n) 最好、最坏和平均时间复杂度 最好时间复杂度是指在最好情况下，算法的时间复杂度。 最坏时间复杂度 是指在最坏情况下，算法的时间复杂度。 平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法计算量的加权平均值。 通常情况下，只讨论算法的最坏时间复杂度。 算法的空间复杂度 关于算法的存储空间需求，类似于算法的时间复杂度，我们采用渐近空间复杂度(SpaceComplexity)作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n的函数，记作：S(n)=O(f(n)) 空间复杂度只需要分析辅助变量所占的额外空间。 12345678910111213// 数组逆序，将一维数组a中的n个数逆序存放到原数组中。// 算法 1 ，仅需要另外借助一个变量t， 与问题规模n大小无关，所以其空间复杂度为O(1)。for(i=0;i&lt;n/2;i++)&#123; t=a[i]; a[i]=a[n-i-1]; a[n-i-1]=t;&#125;// 算法 2 ，需要另外借助一个大小为n的辅助数组b, 所以其空间复杂度为O(n)。for(i=0;i&lt;n;i++) b[i] = a[n-i-1];for(i=0;i&lt;n;i++) a[i] = b[i];","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]}