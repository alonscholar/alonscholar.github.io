{"meta":{"title":"AlonScholar","subtitle":"","description":"","author":"Alon Scholar","url":"https://alonscholar.github.io","root":"/"},"pages":[{"title":"推荐书籍","date":"2021-08-21T15:38:24.017Z","updated":"2021-08-21T15:38:24.017Z","comments":false,"path":"books/index.html","permalink":"https://alonscholar.github.io/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-08-21T07:08:46.426Z","updated":"2021-08-21T07:03:58.223Z","comments":false,"path":"/404.html","permalink":"https://alonscholar.github.io/404.html","excerpt":"","text":""},{"title":"个人简历","date":"2021-08-22T06:47:16.825Z","updated":"2021-08-22T06:47:16.825Z","comments":false,"path":"about/index.html","permalink":"https://alonscholar.github.io/about/index.html","excerpt":"","text":"基本信息： 赵鑫 / 男 / 22 / 党员 现 在 地： 山东泰安 手 机 号： 15288923500 Q Q： 2530394412 邮 箱： 2530394412@qq.com 工作经验： 一年 证 书： 计算机二级、蓝桥杯省二、英语四级 GitHub： https://github.com/alonscholar 个人网站： https://alonscholar.github.io/ 求职意向 期望职位： JAVA开发工程师 期望薪资： 7000-11000 教育背景 山东科技大学泰山科技学院 2018.09-2022.06 计算机科学与技术 实习经历 公司： 山东鑫超网络科技有限公司 职位： JAVA开发工程师 时间： 2021.01-2021.02 个人作品 名称： 在线教学系统 简介： 本项目使用了Vue+SpringCloud搭建，并使用阿里云Oss存储以及视频点播服务，另外还实现了手机号验证码注册和登录等功能，线上地址：http://www.zyczx.top/。 名称： 大数据疫情实时观测 简介： 本项目实现了展示新冠疫情的各地区的新增人数，累计确诊、累计治愈、累计死亡等情况。并使用了现代科技化的界面设计，以及echarts图标数据展示，线上地址：http://yq.zyczx.top/ 名称： 个人网站 简介： 本项目是基于Hexo框架实现的个人网站，其中包括了个人所记录的学习笔记以及前沿技术知识。其中还包括自己的GitHub所发布的项目，https://alonscholar.github.io/ 技能清单 以下均为我熟练使用的技能： 编程语言：Java、Js、Vue、Python、C/C++ 前端开发：熟悉element-ui设计、Bootstrap使用、vue的基本框架vue-admin-template、nuxt等。熟练Html+Css+Js的网页设计，了解微信小程序，会使用NodeJs以及Echarts图表，Ajax以及axios传递请求等等。 后端开发：熟悉并掌握了SpringBoot、SpringCloud、MyBatis-plus等Java框架，了解SpringSecurity、Shiro安全框架，会使用SpringMVC基本框架以及Servlet,Jsp相关技术。并会使用Redis进行缓存处理，EasyPoi实现表格上传与导出… 其他：数据库熟练使用Mysql，了解SqlServer，会使用基本的Linux命令，以及Nginx配置反向代理与负载均衡，学习过Docker，Nacos配置服务中心，懂得一些算法设计知识，会使用Git版本控制工具。 以下是我接触并了解的技能： GoLang（学习中）、Netty、Kubernetes、RabbitMQ等等 自我评价 &emsp;&emsp;我是一个热爱技术热爱编程的人，大学四年自学编程，做过很多小项目（黄金矿工、坦克大战、超级玛丽游戏等等），上架了3个网站，其中在线教学是开发给老师与学生使用，并获得了一些好评。同时我也是一个热爱分享技术的人，在CSDN也发布过很多文章，同时拥有自己的个人网站：https://alonscholar.github.io/，在我的个人网站中，我会分享很多自己学过的技术知识等等。 &emsp;&emsp;我希望在以后的工作中，深度上能学习掌握更多关于JAVA开发的高级知识及数据结构算法；广度上能扩宽自己的技术栈，如前端、后端、混合开发以及其他比较新潮有趣的技术等；高度上希望经过未来几年的职业生涯发展，能成为架构师级的技术专家。"},{"title":"分类","date":"2021-08-21T07:09:04.359Z","updated":"2021-08-21T07:03:58.225Z","comments":false,"path":"categories/index.html","permalink":"https://alonscholar.github.io/categories/index.html","excerpt":"","text":""},{"title":"GitHub仓库","date":"2021-08-21T15:45:56.821Z","updated":"2021-08-21T15:45:56.821Z","comments":false,"path":"repository/index.html","permalink":"https://alonscholar.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-21T15:35:41.282Z","updated":"2021-08-21T15:35:41.282Z","comments":false,"path":"links/index.html","permalink":"https://alonscholar.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-21T07:09:12.025Z","updated":"2021-08-21T07:03:58.227Z","comments":false,"path":"tags/index.html","permalink":"https://alonscholar.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构(严蔚敏)-第二章 线性表","slug":"数据结构(严蔚敏)-第二章 线性表","date":"2021-08-23T02:43:35.000Z","updated":"2021-08-23T06:03:35.396Z","comments":true,"path":"2021/08/23/数据结构(严蔚敏)-第二章 线性表/","link":"","permalink":"https://alonscholar.github.io/2021/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表 线性表、栈、队列、串和数组都属于线性结构。 线性结构的基本特点是除第一个元素无直接前驱，最后一个元素无直接后继之外，其他每个数据元素都有一个前驱和后继。线性表是最基本且最常用的一种线性结构， 同时也是其他数据结构的基础， 尤其单链表，是贯穿整个数据结构课程的基本技术。 线性表的定义和特点 线性表：由n(n≥0)n(n≥0)n(n≥0)个数据特性相同的元素构成的有限序列。 空表：线性表中元素个数为0时，称为空表。 对于非空的线性表或线性结构， 其特点是： 存在唯一的一个被称作 ＂第一个＂ 的数据元素； 存在唯一的一个被称作＂ 最后一个＂ 的数据元素； 除第一个之外， 结构中的每个数据元素均只有一个前驱； 除最后一个之外，结构中的每个数据元素均只有一个后继。 线性表的类型定义 线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，而且可以进行插入和删除等操作。下面给出线性表的抽象数据类型定义： 123456789101112131415ADT List&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n&gt;=0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 基本操作： InitList(&amp;L); //初始化表。构造一个空的线性表L，分配内存空间。 DestroyList(&amp;L); //销毁操作。销毁线性表，并释放线性表L所占用的内存空间。 ClearList(&amp;L); //清空操作。将L重置为空表。 ListInsert(&amp;L,i,e); //插入操作。在表L中的第i个位置上插入指定元素e。 ListDelete(&amp;L,i,&amp;e); //删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。 LocateElem(L,e); //按值查找操作。在表L中查找具有给定关键字值的元素。 GetE1em(L,i); //按位查找操作。获取表L中第i个位置的元素的值。 Length(L); //求表长。返回线性表L的长度，即L中数据元素的个数。 PrintList(L); //输出操作。按前后顺序输出线性表L的所有元素值。 Empty(L); //判空操作。若L为空表，则返回true，否则返回false。&#125;ADT List 注： 抽象数据类型仅是一个模型的定义，并不涉及模型的具体实现，因此这里描述中所涉及的参数不必考虑具体数据类型。在实际应用中，数据元素可能有多种类型，到时可根据具体需要选择使用不同的数据类型。 上述抽象数据类型中给出的操作只是基本操作，由这些基本操作可以构成其他较复杂的操作。 对于不同的应用， 基本操作的接口可能不同。 由抽象数据类型定义的线性表， 可以根据实际所采用的存储结构形式， 进行具体的表示和实现。 线性表的顺序表示和实现 线性表的顺序存储表示 线性表的顺序存储又称顺序表。 顺序存储表示 ： 用一组地址连续的存储单元依次存储线性表中的数据元素（这种表示也称作线性表的顺序存储结构或顺序映像），从而使得逻辑上相邻的两个元素在物理位置上也相邻。 假设线性表L存储的起始位置为LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如下图所示： 注意：线性表中的元素的位序是从1开始的，而数组中元素的下标是从0开始的。 线性表的顺序存储结构是一种随机存取的存储结构，即通过首地址和元素序号可以在O(1) 时间内找到指定的元素 由于线性表的长度可变，且所需最大存储空间随问题的不同而不同，在C语言中通常使用动态分配的一维数组表示线性表 : 123456// －－－－－ 顺序表的存储结构－－－－－#define MAXSIZE 100 //顺序表可能达到的最大长度typedef struct &#123; ElemType *elem; //存储空间的基地址，类型可以是int、float、char... int length; //当前长度&#125; SqList; //顺序表的结构类型为SqList 顺序表中基本操作的实现 一、顺序表初始化 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。 将表的当前长度设为0。 12345void InitList(SeqList &amp;L)&#123; //用malloc函数申请一片连续的存储空间,malloc返回连续空间的首地址 L.data = (int *)malloc(InitSize * sizeof(int)); L.length=0;&#125; 二、顺序表取值 判断指定的位置序号 i 值是否合理 (1≤i≤L.length1≤i≤L.length1≤i≤L.length), 若不合理，则返回ERROR。 若 i 值合理，则将第 i 个数据元素 L.elem[i-1] 赋给参数 e, 通过 e 返回第 i 个数据元素的传值。 12345bool GetElem(SqList L,int i,int &amp;e)&#123; // 时间复杂度 O(1) if(i&lt;1 || i&gt;L.length) return false; //如果越界，则返回false e = L.data[i-1]; // i是位序，elem[i-1] 单元存储第 i 个数据元素 return true;&#125; 三、顺序表的按值查找 从第一个元素起，依次和 e 相比较，若找到与 e相等的元素 L.elem[i], 则查找成功，返回该元素的序号 i+1 (数组下标从 0 开始)。 若查遍整个顺序表都没有找到，则查找失败， 返回0。 1234567int locateElem(SqList L,int e)&#123; int i; for(i=0;i&lt;L.length;i++) if(L.data[i]==e) return i+1; return 0;&#125; 最好时间复杂度：O(1)。查找元素在第一个，仅需比较一次。 最坏时间复杂度：O(n)。查找元素在最后一个，需比较n次。 平均时间复杂度：由平均查找长度公式： ASL=∑i=1npiCiASL=\\sum\\limits_{i=1}^np_iC_iASL=i=1∑n​pi​Ci​，以及在这里每个元素的查找概率相等pi=1/np_i=1/npi​=1/n。得 ASL=1n∑i=1ni=n+12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^ni = \\frac{n+1}{2}ASL=n1​i=1∑n​i=2n+1​。由此可见，顺序表按值查找的平均时间复杂度为O(n)。 四、顺序表插入元素 判断插入位置序号 x 值是否合理 (1≤x≤L.length+11≤x≤L.length+11≤x≤L.length+1), 若不合理，则返回ERROR。 判断顺序表的存储空间是否已满，若满则返回 ERROR。 将第L.length个至第 x 个位置的元素依次向后移动一个位置，空出第 x 个位置(x=L.length+1 时无需移动）。 将要插入的新元素e放入第x个位置。 表长加1。 12345678910111213141516/* 在x位置插入元素data x ---&gt; 位序 从顺序表最后一个到x之后都往后移动一位*/bool insertList(SqList &amp;L,int x,int data)&#123; if(x&lt;1 || x&gt;L.length+1) //x值不合法 return false; if(L.length&gt;=MaxSize) //当前存储空间已满 return false; for(int i=L.length;i&gt;=x;i--) L.data[i]=L.data[i-1]; L.data[x-1]=data; L.length++; return true;&#125; 最好时间复杂度： 在表尾插入（即x=L.length+1），元素后移语句将不执行，时间复杂度为O(1)； 最坏时间复杂度： 在表头插入（即x=1），元素后移语句将执行n次，时间复杂度为O(n)； 平均时间复杂度： 假设 pi(pi=1/(n+1))p_i(p_i=1/(n+1))pi​(pi​=1/(n+1)),是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为：∑i=1n+1pi(n−i+1)=∑i=1n+11n+1(n−i+1)=1n+1∑i=1n+1(n−i+1)=1n+1n(n+1)2=n2\\sum\\limits_{i=1}^{n+1}p_i(n-i+1)=\\sum\\limits_{i=1}^{n+1}\\frac {1} {n+1}(n-i+1)=\\frac {1} {n+1}\\sum\\limits_{i=1}^{n+1}(n-i+1)=\\frac {1} {n+1}\\frac {n(n+1)} {2}=\\frac {n} {2}i=1∑n+1​pi​(n−i+1)=i=1∑n+1​n+11​(n−i+1)=n+11​i=1∑n+1​(n−i+1)=n+11​2n(n+1)​=2n​ 因此，线性表插入算法的平均时间复杂度为O(n) 。 五、顺序表删除元素 判断删除位置 x 值是否合理 (1≤x≤L.length1≤x≤L.length1≤x≤L.length), 若不合理，则返回ERROR。 将第x+1个至第L.length个的元素依次向前移动一个位置(x = L.length时无需移动）。 表长减1。 1234567891011bool deleteList(SqList &amp;L,int x)&#123; if(x&lt;1||x&gt;L.length) //判断i的范围是否有效 return false; int e = L.data[x-1]; for(int i=x;i&lt;L.length;i++)&#123;//将第x个位置后的元素前移 L.data[i-1] = L.data[i]; &#125; L.length--; printf(&quot;删除了%d位置的元素：%d\\n&quot;,x,e); return true;&#125; 最好时间复杂度： 删除表尾元素（即x=L.length），无须移动元素，时间复杂度为O(1)； 最坏时间复杂度： 删除表头元素(即 x= 1)，需移动除第一个元素外的所有元素，时间复杂度为O(n)。 平均时间复杂度： 假设pi(pi=1/n)p_i (p_i= 1/n)pi​(pi​=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为: ∑i=1npi(n−i)=∑i=1n1n(n−i)=1n∑i=1n(n−i)=1nn(n−1)2=n−12\\sum\\limits_{i=1}^{n}p_i(n-i)=\\sum\\limits_{i=1}^{n}\\frac {1} {n}(n-i)=\\frac{1}{n}\\sum\\limits_{i=1}^{n}(n-i)=\\frac {1} {n}\\frac {n(n-1)} {2}=\\frac {n-1} {2}i=1∑n​pi​(n−i)=i=1∑n​n1​(n−i)=n1​i=1∑n​(n−i)=n1​2n(n−1)​=2n−1​ 因此,线性表删除算法的平均时间复杂度为O(n)。 线性表的链式表示和实现 链式存储结构的特点：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的），存放数据元素的结点至少包括两个域（数据域、指针域），指针域中存储的信息称作指针或链。n个结点链接成一个链表，即为线性表的链式存储结构。 单链表的定义和表示 当链表的每个结点中只包含一个指针域，又称线性链表或单链表。 首元结点：即链表中存储第一个数据元素的结点。 最后一个结点的指针为NULL 头结点：是在首元素结点之前附设的一个结点，其指针指向首元结点。其数据域可以不存储任何信息。 头指针：指向链表中的第一个结点的存储位置。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。 是否带头结点 链表为空时的情况（L为头指针） 单链表的逻辑状态表示 不带头结点 L == NULL 带头结点 L -&gt; next == NULL 由上述可见，单链表可由头指针唯一确定，在C语言中可用 “结构指针&quot; 来描述： 123456//－－－－－ 单链表的存储结构－－－－－typedef struct LNode&#123; ElemType data; //结点的数据域 struct LNode *next; //结点的指针域&#125;LNode,*LinkList; //LinkList 为指向结构体 LNode 的指针类型 注： 为了提高程序的可读性，在此对同一结构体指针类型起了两个名称，LinkList与 LNode* , 两者本质上是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode* 定义指向单链表中任意结点的指针变量。 利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。 单链表的基本操作的实现 一、 单链表的初始化 生成新结点作为头结点，用头指针L 指向头结点。 头结点的指针域置空。 12345bool InitList(LinkList &amp;L)&#123; L = new LNode; //生成新结点作为头结点， 用头指针L指向头结点 L-&gt;next = NULL; //头结点的指针域置空 return true;&#125; 二、单链表的取值 用指针p指向首元结点，用 j 做计数器初值赋为1。 从首元结点开始依次顺着链域 next 向下访问，只要指向当前结点的指针 p 不为空(NULL), 并且没有到达序号为 i 的结点，则循环执行以下操作： p指向下一个结点； 计数器 j 相应加1。 退出循环时， 如果指针p为空， 或者计数器 j 大于 i, 说明指定的序号 i 值不合法（i 大于表长n或 i 小于等于0), 取值失败返回NULL; 否则取值成功， 此时 j=i 时，p所指的结点就是要找的第 i 个结点，返回该结点。 1234567891011121314151617LNode *GetElem(LinkList L, int i)&#123; int j = 1; LNode *p = L-&gt;next; if (i == 0) // 如果i=0，则返回头结点 &#123; return L; &#125; if (i &lt; 0) return NULL; while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; j++; &#125; return p; //返回第i个结点的指针，若i大于表长则返回NULL&#125; 最好时间复杂度：O(1)。i=0或i=1，查找元素为头结点或者是首元结点，仅需比较一次。 最坏时间复杂度：O(n)。查找元素不存在，需比较n次。 平均时间复杂度：假设每个元素的查找概率相等pi=1/np_i=1/npi​=1/n。得 ASL=1n∑i=1n(i−1)=n−12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^n(i-1) = \\frac{n-1}{2}ASL=n1​i=1∑n​(i−1)=2n−1​。由此可见，顺序表按值查找的平均时间复杂度为O(n)。 三、单链表的按值查找 用指针p指向首元结点 。 从首元结点开始依次顺着链域next向下查找， 只要指向当前结点的指针p不为空， 并且p所指结点的数据域不等于给定值e, 则循环执行以下操作： p指向下一个结点 。 返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL 。 123456789LNode *LocateElem(LinkList L, int e)&#123; LNode *p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != e) &#123; p = p-&gt;next; &#125; return p;&#125; 平均时间复杂度：该算法与按序号查找类似，与待查找的值 e 相关，复杂度为 O(n)。 四、单链表的插入 在单链表中要插入元素，只需更改各结点的指针域即可，需要进行如下图的操作： 将值为e的新结点插入到表的第 i 个结点的位置上，即插入到结点 ai−1a_i-1ai​−1与aia_iai​之间。 查找结点 ai−1a_{i-1}ai−1​ 并由指针p指向该结点 。 生成一个新结点*s 。 将新结点*s 的数据域置为 e 。 将新结点*s 的指针域指向结点aia_iai​。 将结点 *p 的指针域指向新结点 *s 。 123456789101112131415LinkList insertNode(LinkList &amp;L, int i, int e)&#123; //获取i-1位置的元素 LNode *p = GetElem(L, i - 1); if(p==NULL)&#123;//说明输入的位置不合法 cout&lt;&lt;&quot;请输入正确的位置&quot;&lt;&lt;endl; return L; &#125; //此时p直线第i-1位置的元素 LNode *s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return L;&#125; 平均时间复杂度：与顺序表的插入操作相比，复杂度仍为 O(n)，但是省略了顺序表移动元素的步骤，只需要从头到尾比较一遍链表即可。注意，头插法可以到达O(1)的时间复杂度。 五、单链表的删除 在单链表中要删除元素，只需更改各结点的指针域即可，需要进行如下图的操作： 删除单链表的第 i 个结点aia_iai​。 查找结点 ai−1a_{i-1}ai−1​ 并由指针p指向该结点 。 临时保存待删除结点 aia_iai​ 的地址在 q 中 ，以备释放。 将结点 *p 的指针域指向 aia_iai​ 的直接后继结点 。 释放结点aia_iai​的空间 。 12345678LinkList deleteNode(LinkList &amp;L, int i)&#123; LNode *p = GetElem(L, i - 1); LNode *q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); return L;&#125; 平均时间复杂度：类似于插入算法，删除算法时间复杂度亦为 O(n)； 六、创建单链表 (1) 前插法 创建一个只有头结点的空链表。 根据待创建链表包括的元素个数n, 循环n次执行以下操作： 生成一个新结点 *s; 输入元素值赋给新结点*s 的数据域； 将新结点 *s 插入到头结点之后。 1234567891011121314151617LinkList List_HeadInsert(LinkList &amp;L)&#123; L = new LNode; L-&gt;next = NULL; LNode *s; int x; scanf(&quot;%d&quot;, &amp;x); while (x != 0) //当输入0时表示不再添加元素 &#123; s = (LNode *)malloc(sizeof(LNode)); //开辟一块新的LNode区域。 s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s; scanf(&quot;%d&quot;, &amp;x); &#125; return L;&#125; (2) 后插法 创建一个只有头结点的空链表。 尾指针 r 初始化， 指向头结点。 根据创建链表包括的元素个数n, 循环n次执行以下操作： 生成一个新结点*s; 输入元素值赋给新结点*s 的数据域； 将新结点 *s 插入到尾结点 *r 之后； 尾指针 r 指向新的尾结点 *s。 1234567891011121314151617LinkList List_TailInsert(LinkList &amp;L)&#123; int x; L = (LinkList)malloc(sizeof(LNode)); LNode *s, *r = L; //r用于记录表尾结点 scanf(&quot;%d&quot;, &amp;x); while (x != 0) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s; scanf(&quot;%d&quot;, &amp;x); &#125; r-&gt;next = NULL; //表尾结点置空 return L;&#125; 循环链表 循环链表(CircularLinked List)：是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他结点，下图所示为单链的循环链表。类似地，还可以有多重链的循环链表。 循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL或p-&gt;next!=NULL,而循环单链表的判别条件为p!=L或p-&gt;next!=L 若在循环链表中设立尾指针而不设立头指针，可使一些操作简化。如将两个线性表进行合并，仅需将第一个表的尾指针指向第二个表的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。 循环双链表： 由循环单链表的定义不难推出循环双链表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点，如下图所示。 在循环双链表L中，某结点*p为尾结点时，p-&gt;next==L; 当循环双链表为空表时，其头结点的prior域和next域都等于L。 双向链表 单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。 为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next,分别指向其前驱结点和后继结点，如下图所示。 在C语言中可描述如下： 1234567// - - - - -双向链表的存储结构－－－－－typedef struct DuLNode&#123; ElemType data; //数据域 struct DuLNode *prior; //直接前驱 struct DuLNode *next; //直接后继&#125;DuLNode,*DuLinkList; 在双向链表中， 有些操作（如 ListLength、GetElem 和 LocateElem 等）仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针，下图分别显示了插入和删除结点时指针修改的情况。 在插入结点时需要修改四个指针，在删除结点时需要修改两个指针。两者的时间复杂度均为 O(n)。 一、双向链表的插入 1234567891011121314151617DLinkList insertNode(DLinkList &amp;L,int i,int val)&#123; DNode *p = getElem(L,i-1); if(p==NULL)&#123; cout&lt;&lt;&quot;插入位置不合法&quot;&lt;&lt;endl; return L; &#125; DNode *s = (DNode*)malloc(sizeof(DNode)); //开辟一个空间 s-&gt;data = val; //执行插入操作 s-&gt;next = p-&gt;next; if(p-&gt;next!=NULL) //倘若不是最后一个结点 p-&gt;next-&gt;prior = s; s-&gt;prior = p; p-&gt;next = s; return L;&#125; 二、双向链表的删除 12345678910111213DLinkList deleteNode(DLinkList &amp;L,int i)&#123; DNode *p = getElem(L,i-1); if(p==NULL)&#123; cout&lt;&lt;&quot;输入位置不合法&quot;&lt;&lt;endl; return L; &#125; DNode *q = p-&gt;next; if(q-&gt;next!=NULL) q-&gt;next-&gt;prior = p; p-&gt;next = q-&gt;next; free(q); return L;&#125; 单链表、循环链表和双向链表的比较 顺序表和链表的比较","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构(严蔚敏)-第一章 绪论","slug":"数据结构(严蔚敏)-第一章 绪论","date":"2021-08-22T14:43:35.000Z","updated":"2021-08-23T06:05:35.953Z","comments":true,"path":"2021/08/22/数据结构(严蔚敏)-第一章 绪论/","link":"","permalink":"https://alonscholar.github.io/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"绪论 早期的计算机主要用于数值计算，现在，计算机主要用于非数值计算，包括处理字符、表格和图像等具有一定结构的数据。这些数据内容存在着某种联系，只有分清楚数据的内在联系，合理地组织数据，才能对它们进行有效的处理，设计出高效的算法。如何合理地组织数据、高效地处理数据，这就是 “数据结构” 主要研究的问题。本章简要介绍有关数据结构的基本概念和算法分析方法。 数据结构的研究内容 数据的各种逻辑结构和物理结构，以及他们之间的相应关系 对每种结构定义相适应的各种运算 设计出相应的算法 分析算法的效率 基本概念和术语 数据、数据对象、数据元素和数据项 名词 解释 数据 (Data) 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。（整数、实数、字符串、图形、图像、声音及动画…） 数据对象 (Data Object) 是性质相同的数据元素的集合，是数据的一个子集。 数据元素(Data Element) 是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。 在有些情况下，数据元素也称为元素、记录等。数据元素用于完整地描述一个对象，如一名学生记录，图中的一个顶点等。 数据项 (Data Item) 是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。 数据结构 数据结构 (Data Structure) 是相互之间存在一种或多种特定关系的数据元素的集合。 数据结构包括逻辑结构和存储结构两个层次。 逻辑结构 数据的逻辑结构有两个要素：一是数据元素；二是关系。 逻辑结构分为四种类型：集合结构，线性结构，树形结构，图形结构。 类型 简述 图片 集合结构 数据元素同属一个集合，单个数据元素之间没有任何关系。 线性结构 类似于线性关系，线性结构中的数据元素之间是一对一的关系。 树结构 树形结构中的数据元素之间存在一对多的关系。（各元素及元素关系所组成图形类似于树状图）。 图结构 数据元素之间是多对多的关系。 存储结构 物理结构又叫存储结构，分为两种，一种是顺序存储结构一种是链式存储结构。 类型 简述 图片 顺序存储结构 顺序存储结构是把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的。之前学习的数组就是一种顺序存储结构 链式存储结构 链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。根据指针找出相邻元素的位置 数据类型和抽象数据类型 类型 描述 数据类型 一般包括整型、实型、字符型等原子类型外，还有数组、结构体和指针等结构类型。 抽象数据类型 抽象数据类型 (Abstract Data Type, ADT) 一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合。如C语言中的结构体以及 C++、Java中的类。 算法和算法分析 算法的定义及特性 算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。 一个算法必须满足以下五个重要特性。 特性 描述 有穷性 一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。 确定性 对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性， 使算法的执行者或阅读者都能明确其含义及如何执行。 可行性 算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。 输入 一个算法有零个或多个输入。 输出 一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有意义。 评价算法优劣的基本标准 名称 描述 正确性 在合理的数据输入下，能够在有限的运行时间内得到正确的结果。 可读性 一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。 健壮性 当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。 高效性 高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。 算法的时间复杂度 衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。 因为事后统计法的缺点很明显，需要将算法实现等等，所以我们通常采用事前分析估算法。 问题规模和语句频度 问题规模 是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。 语句频度(FrequencyCount)是一条语句的重复执行的次数。 一个算法的执行时间大致上等于其所有语句执行时间的总和， 而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。 12345678// 例：求两个n阶矩阵的乘积算法。i记录行号，j记录列号for(i=1;i&lt;=n;i++) //频度为 n+1 for(j=1;j&lt;=n;j++) //频度为 n*(n+1) &#123; c[i][j] = 0; //频度为 n*n for(k=1;k&lt;=n;k++) //频度为 n*n*(n+1) c[i][j] = c[i][j]+a[i][k]*b[k][j]; //频度为 n*n*n &#125; 该算法中所有语句频度之和， 是矩阵阶数n的函数， 用 f(n)表示之。换句话说， 上例算法的执行时间与f(n）成正比。 f(n)=2n3+3n2+2n+1f(n)=2n^3+3n^2+2n+1f(n)=2n3+3n2+2n+1$ 算法的时间复杂度定义 ​ 当算法比较复杂时，我们往往不能通过所有语句频度之和来测量算法的时间复杂度。所以我们这里提出了基本语句的概念，所谓 “基本语句” 指的是算法中重复执行次数 和算法的执行时间成正比的语句， 它对算法运行时间的贡献最大。 ​ 如上述代码中，因为 lim⁡n→∞f(n)/n3=lim⁡n→∞(2n3+3n2+2n+1)/n3=2\\lim\\limits_{n\\to\\infty}f(n)/n^3 = \\lim\\limits_{n\\to\\infty}(2n^3+3n^2+2n+1)/n^3=2n→∞lim​f(n)/n3=n→∞lim​(2n3+3n2+2n+1)/n3=2，所以我们称 f(n) 和 n3n^3n3是同阶的，我们用“O”来表示数量级，记作 T(n)=O(f(n))=O(n3)T(n)=O(f(n))=O(n^3)T(n)=O(f(n))=O(n3)。 ​ 随问题规模n的增大，算法执行时间的增长率和 f(n)的增长率相同，称做算法的渐近时间复杂度， 简称时间复杂度(TimeComplexity)。 算法的时间复杂度分析举例 ​ 分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语 句， 计算基本语句的频度得到问题规模n的某个函数 f(n), 取其数量级用符号&quot;O&quot;表示即可。具体计算数量级时， 可以遵循以下定理。 定理1.1 若 f(n)=amnm+am−1nm−1+…+a1n+a0f(n)=a_mn^m+a_{m-1}n^{m-1}+…+a_1n+a_0f(n)=am​nm+am−1​nm−1+…+a1​n+a0​。 是一个m次多项式， 则T(n)=O(nm)T(n)=O(n^m)T(n)=O(nm)。 123456789101112131415161718192021// 举例说明如何求非递归算法的时间复杂度// --------- O(1) --------------&#123;x++;s=0;&#125; for(i=0;i&lt;10000;i++)&#123;x++;s=0;&#125; //时间复杂度均为O(1)// --------- O(n) --------------for(i=0;i&lt;n;i++)&#123;x++;s=0;&#125; //问题规模随着n的增加而增加,T(n)=O(n)// --------- O(n*n) -------------x=0;y=0; // O(1)for(k=1;k&lt;=n;k++) // O(n+1) x++; // O(n)for(i=1;i&lt;=n;i++) // O(n+1) for(j=1;j&lt;=n;j++) // O(n*(n+1)) y++; // O(n*n)// --------- O(n*n*n) -------------x=1;for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 常见的时间复杂度：O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n)O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(2^n)O(1)&lt;O(log2​n)&lt;O(n)&lt;O(nlog2​n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n) 最好、最坏和平均时间复杂度 最好时间复杂度是指在最好情况下，算法的时间复杂度。 最坏时间复杂度 是指在最坏情况下，算法的时间复杂度。 平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法计算量的加权平均值。 通常情况下，只讨论算法的最坏时间复杂度。 算法的空间复杂度 关千算法的存储空间需求，类似于算法的时间复杂度，我们采用渐近空间复杂度(SpaceComplexity)作为算法所需存储空间的扯度，简称空间复杂度，它也是问题规模n的函数，记作：S(n)=O(f(n)) 空间复杂度只需要分析辅助变量所占的额外空间。 12345678910111213// 数组逆序，将一维数组a中的n个数逆序存放到原数组中。// 算法 1 ，仅需要另外借助一个变量t， 与问题规模n大小无关，所以其空间复杂度为0(1)。for(i=0;i&lt;n/2;i++)&#123; t=a[i]; a[i]=a[n-i-1]; a[n-i-1]=t;&#125;// 算法 2 ，需要另外借助一个大小为n的辅助数组b, 所以其空间复杂度为O(n)。for(i=0;i&lt;n;i++) b[i] = a[n-i-1];for(i=0;i&lt;n;i++) a[i] = b[i];","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]}