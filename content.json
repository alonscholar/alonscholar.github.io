{"meta":{"title":"AlonScholar","subtitle":"","description":"","author":"Alon Scholar","url":"https://alonscholar.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-08-21T07:08:46.426Z","updated":"2021-08-21T07:03:58.223Z","comments":false,"path":"/404.html","permalink":"https://alonscholar.github.io/404.html","excerpt":"","text":""},{"title":"个人简历","date":"2021-08-22T06:47:16.825Z","updated":"2021-08-22T06:47:16.825Z","comments":false,"path":"about/index.html","permalink":"https://alonscholar.github.io/about/index.html","excerpt":"","text":"基本信息： 赵鑫 / 男 / 22 / 党员 现 在 地： 山东泰安 手 机 号： 15288923500 Q Q： 2530394412 邮 箱： 2530394412@qq.com 工作经验： 一年 证 书： 计算机二级、蓝桥杯省二、英语四级 GitHub： https://github.com/alonscholar 个人网站： https://alonscholar.github.io/ 求职意向 期望职位： JAVA开发工程师 期望薪资： 7000-11000 教育背景 山东科技大学泰山科技学院 2018.09-2022.06 计算机科学与技术 实习经历 公司： 山东鑫超网络科技有限公司 职位： JAVA开发工程师 时间： 2021.01-2021.02 个人作品 名称： 在线教学系统 简介： 本项目使用了Vue+SpringCloud搭建，并使用阿里云Oss存储以及视频点播服务，另外还实现了手机号验证码注册和登录等功能，线上地址：http://www.zyczx.top/。 名称： 大数据疫情实时观测 简介： 本项目实现了展示新冠疫情的各地区的新增人数，累计确诊、累计治愈、累计死亡等情况。并使用了现代科技化的界面设计，以及echarts图标数据展示，线上地址：http://yq.zyczx.top/ 名称： 个人网站 简介： 本项目是基于Hexo框架实现的个人网站，其中包括了个人所记录的学习笔记以及前沿技术知识。其中还包括自己的GitHub所发布的项目，https://alonscholar.github.io/ 技能清单 以下均为我熟练使用的技能： 编程语言：Java、Js、Vue、Python、C/C++ 前端开发：熟悉element-ui设计、Bootstrap使用、vue的基本框架vue-admin-template、nuxt等。熟练Html+Css+Js的网页设计，了解微信小程序，会使用NodeJs以及Echarts图表，Ajax以及axios传递请求等等。 后端开发：熟悉并掌握了SpringBoot、SpringCloud、MyBatis-plus等Java框架，了解SpringSecurity、Shiro安全框架，会使用SpringMVC基本框架以及Servlet,Jsp相关技术。并会使用Redis进行缓存处理，EasyPoi实现表格上传与导出… 其他：数据库熟练使用Mysql，了解SqlServer，会使用基本的Linux命令，以及Nginx配置反向代理与负载均衡，学习过Docker，Nacos配置服务中心，懂得一些算法设计知识，会使用Git版本控制工具。 以下是我接触并了解的技能： GoLang（学习中）、Netty、Kubernetes、RabbitMQ等等 自我评价 &emsp;&emsp;我是一个热爱技术热爱编程的人，大学四年自学编程，做过很多小项目（黄金矿工、坦克大战、超级玛丽游戏等等），上架了3个网站，其中在线教学是开发给老师与学生使用，并获得了一些好评。同时我也是一个热爱分享技术的人，在CSDN也发布过很多文章，同时拥有自己的个人网站：https://alonscholar.github.io/，在我的个人网站中，我会分享很多自己学过的技术知识等等。 &emsp;&emsp;我希望在以后的工作中，深度上能学习掌握更多关于JAVA开发的高级知识及数据结构算法；广度上能扩宽自己的技术栈，如前端、后端、混合开发以及其他比较新潮有趣的技术等；高度上希望经过未来几年的职业生涯发展，能成为架构师级的技术专家。"},{"title":"推荐书籍","date":"2021-08-21T15:38:24.017Z","updated":"2021-08-21T15:38:24.017Z","comments":false,"path":"books/index.html","permalink":"https://alonscholar.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-08-21T07:09:04.359Z","updated":"2021-08-21T07:03:58.225Z","comments":false,"path":"categories/index.html","permalink":"https://alonscholar.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-21T15:35:41.282Z","updated":"2021-08-21T15:35:41.282Z","comments":false,"path":"links/index.html","permalink":"https://alonscholar.github.io/links/index.html","excerpt":"","text":""},{"title":"GitHub仓库","date":"2021-08-21T15:45:56.821Z","updated":"2021-08-21T15:45:56.821Z","comments":false,"path":"repository/index.html","permalink":"https://alonscholar.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-21T07:09:12.025Z","updated":"2021-08-21T07:03:58.227Z","comments":false,"path":"tags/index.html","permalink":"https://alonscholar.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构(严蔚敏)-第3章 栈和队列","slug":"数据结构(严蔚敏)-第3章 栈和队列","date":"2021-08-24T05:43:35.000Z","updated":"2021-08-25T14:17:32.058Z","comments":true,"path":"2021/08/24/数据结构(严蔚敏)-第3章 栈和队列/","link":"","permalink":"https://alonscholar.github.io/2021/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC3%E7%AB%A0%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"栈和队列 栈和队列是两种重要的线性结构。从数据结构角度看， 栈和队列也是线性表， 其特殊性在于栈和队列的基本操作是线性表操作的子集， 它们是操作受限的线性表， 因此， 可称为限定性的数据结构。但从数据类型角度看，它们是和线性表不相同的两类重要的抽象数据类型。 栈和队列的定义和特点 栈的定义和特点 栈(Stack)是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作，如下图所示。 栈顶(Top)。 线性表允许进行插入删除的那一端。 表尾端。 栈底(Bottom)。固定的，不允许进行插入和删除的另一端。 表头端。 空栈。不含任何元素的空表。 假设某个栈S=(a1,a2,a3,a4,a5)S=(a_1,a_2, a_3,a_4,a_5)S=(a1​,a2​,a3​,a4​,a5​),如上图所示，则 a1a_1a1​为栈底元素，a5a_5a5​为栈顶元素。由于栈只能在栈顶进行插入和删除操作，进栈次序依次为a1,a2,a3,a4,a5a_1,a_2, a_3,a_4,a_5a1​,a2​,a3​,a4​,a5​,而出栈次序为a5,a4,a3,a2,a1a_5,a_4, a_3,a_2,a_1a5​,a4​,a3​,a2​,a1​。由此可见，栈的操作特性可以明显地概括为后进先出(Last In First Out，LIFO)。 栈的数学性质: n个不同元素进栈，出栈元素不同排列的个数为1n+1C2nn\\frac {1} {n+1}C{^n_{2n}}n+11​C2nn​。上述公式称为卡特兰(Catalan)数，可采用数学归纳法证明，有兴趣的读者可以参考组合数学教材。 队列的定义和特点 队列(Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队;删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（First In First Out，FIFO)，如下图所示。 队头 (Front)。允许删除的一端，又称队首。 队尾 (Rear)。允许插入的一端。 空队列。不含任何元素的空表。 假设队列为 q=(a1,a2,a3,a4,a5)q=(a_1,a_2,a_3,a_4,a_5)q=(a1​,a2​,a3​,a4​,a5​) 。那么，a1a_1a1​ 就是队头元素， a5a_5a5​则是队尾元素。队列中的元素是按照a1,a2,a3,a4,a5a_1,a_2,a_3,a_4,a_5a1​,a2​,a3​,a4​,a5​的顺序进入的，退出队列也只能按照这个次序依次退出。 栈的表示和操作的实现 栈的类型定义 栈的基本操作除了入栈和出栈外， 还有栈的初始化、 栈空的判定，以及取栈顶元素等。下面给出栈的抽象数据类型定义： 123456789101112131415ADT Stack&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 约定an端为栈顶，a1端为栈底。 基本操作： InitStack(&amp;S) //初始化一个空栈S。 DestroyStack(&amp;S) //销毁栈，并释放栈s占用的存储空间(”&amp;”表示引用调用)。 ClearStack(&amp;S) //将S清为空栈。 StackEmpty(S) //判断一个栈是否为空，若栈S为空则返回true,否则返回false。 StackLength(S) //返回S的元素个数，即栈的长度。 GetTop(S, &amp;x) //读栈顶元素，若栈s非空，则用x返回栈顶元素。 Push(&amp;S,x) //进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;S,&amp;x) //出栈，若栈S非空，则弹出栈顶元素，并用x返回。 StackTraverse(S) //从栈底到栈顶依次对S的每个数据元素进行访问。 &#125;ADT Stack 顺序栈的表示和实现 采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。 顺序栈的定义如下： 1234567// －－－－－ 顺序栈的存储结构－ －－－－#define MAXSIZE 100 //定义栈中元素的最大个数typedef struct &#123; Elemtype data[MAXSIZE]; //存放栈中元素 int top; //栈顶指针&#125;SqStack; 下图所示为顺序栈中数据元素和栈指针之间的对应关系。 栈顶指针: S.top，初始时设置S.top=-1; 栈顶元素:S.data[S.top] 进栈操作: 栈不满时，栈顶指针先加1，再送值到栈顶元素。 出栈操作: 栈非空时，先取栈顶元素值，再将栈顶指针减1。 栈空条件: S.top==-1; 栈满条件: S.top==MaxSize-1; 栈长:S.top+1。 下面是顺序栈常用的基本操作的实现。 一、顺序栈的初始化 为顺序栈分配一个最大容量为MaxSize的数组空间。 栈顶指针初始为-1，表示栈空。 123456789#define MaxSize 10typedef struct&#123; char data[MaxSize]; int top;&#125;SqStack;void InitStack(SqStack &amp;S)&#123; S.top = -1;&#125; 二、顺序栈判栈空、栈满 当top指针指向-1时，栈为空。 当top指针指向MaxSize-1时，栈为满。因为数组下标从0开始。 123456bool StackEmpty(SqStack S)&#123; return S.top == -1;&#125;bool StackFull(SqStack S)&#123; return S.top == MaxSize-1;&#125; 三、顺序栈的入栈 判断栈是否满， 若满则返回false。 栈顶指针加1，将新元素压入栈顶 。 123456789bool Push(SqStack &amp;S,char val)&#123; if(StackFull(S))&#123; cout&lt;&lt;&quot;stack is full!&quot;&lt;&lt;endl; return false; &#125;else&#123; S.data[++S.top] = val; return true; &#125;&#125; 四、顺序栈的出栈 判断栈是否空，若空则返回false。 栈顶元素出栈，栈顶指针减1。 123456789bool Pop(SqStack &amp;S,char &amp;val)&#123; if(StackEmpty(S))&#123; cout&lt;&lt;&quot;stack is empty!&quot;&lt;&lt;endl; return false; &#125;else&#123; val = S.data[S.top--]; return true; &#125;&#125; 五、取顺序栈的栈顶元素 判断栈是否空，若空则返回false。 因为栈顶指针指向的就是栈顶元素的位置，所以返回S.data[S.top]的元素即可。 123456789bool GetTop(SqStack &amp;S,char &amp;val)&#123; if(StackEmpty(S))&#123; cout&lt;&lt;&quot;stack is empty!&quot;&lt;&lt;endl; return false; &#125;else&#123; val = S.data[S.top]; return true; &#125;&#125; 链栈的表示和实现 采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead 指向栈顶元素，如下图所示。 链栈的定义如下： 123456// －－－－－ 链栈的存储结构－－－－－typedef struct LinkNode&#123; Elemtype data; //数据域 struct LinkNode *next; //指针域&#125;*LinkStack; 由于栈的主要操作是在栈顶插入和删除， 显然以链表的头部作为栈顶是最方便的， 而且没必要像单链表那样为了操作方便附加一个头结点。 下面给出链栈部分操作的实现。 一、链栈的初始化 链栈的初始化操作就是构造一个空栈， 因为没必要设头结点，所以直接将栈顶指针置空即可。 1234void InitStack(LinkStack &amp;S)&#123; S=NULL;&#125; 二、链栈的入栈 为入栈元素 e 分配空间， 用指针 p 指向。 将新结点数据域置为e。 将新结点插入栈顶。 修改栈顶指针为 p。 1234567void Push(LinkStack &amp;S,char e)&#123; p = new LinkNode; //p定义全局变量 ，LinkNode *p; p-&gt;data = e; p-&gt;next = S; S = p;&#125; 链栈入栈过程如下图所示： 三、链栈的出栈 判断栈是否为空 ，若空则返回false。 将栈顶元素赋给e。 临时保存栈顶元素的空间， 以备释放。 修改栈顶指针， 指向新的栈顶元素。 释放原栈顶元素的空间。 123456789bool Pop(LinkStack &amp;S,char &amp;e)&#123; if(S==NULL) return false; e = S-&gt;data; p = S; S = S-&gt;next; free(p); return true;&#125; 链栈的出栈过程如下图所示： 四、取链栈的栈顶元素 判断栈是否为空 ，若空则返回false。 返回栈顶指针S指向的值，用e进行保存。 123456789bool GetTop(LinkStack S,char &amp;e)&#123; if(S!=NULL) &#123; e = S-&gt;data; return true; &#125; return false;&#125; 共享栈 利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示。 两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空;仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满。当0号栈进栈时top0 先加1再赋值，1号栈进栈时top1先减1再赋值;出栈时则刚好相反。 共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时才发生上溢。其存取数据的时间复杂度均为O(1)，所以对存取效率没有什么影响。 队列的表示和操作的实现 队列的类型定义 队列的操作与栈的操作类似，不同的是，删除是在表的头部（即队头）进行。 下面给出队列的抽象数据类型定义： 123456789101112131415ADT Queue&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 约定a1端为队列头，an端为队列尾。 基本操作： InitQueue(&amp;Q) //初始化队列,构造一个空队列Q。 DestroyQueue(&amp;Q) //销毁队列。 ClearQueue(&amp;Q) //将Q清为空队列。 QueueEmpty(Q) //判队列空，若队列Q为空返回true，否则返回false。 QueueLength(Q) //返回Q的元素个数，即队列的长度。 GetHead(Q,&amp;x) //读队头元素，若队列Q非空，则将队头元素赋值给x。 EnQueue(&amp;Q,x) //入队，若队列Q未满，将x加入，使之成为新的队尾。 DeQueue(&amp;Q,&amp;x) //出队，若队列Q非空，删除队头元素，并用x返回。 QueueTraverse(Q) //从队头到队尾，依次对Q的每个数据元素访问。 &#125;ADT Queue 循环队列—队列的顺序表示和实现 和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变量 front 和 rear 分别指示队列头元素及队列尾元素的位置（后面分别称为头指针和尾指针）。 队列的顺序存储结构表示如下： 1234567// －－－－－ 队列的顺序存储结构－ －－－－#define MAXSIZE 100 //队列可能达到的最大长度typedef struct &#123; Elemtype data[MAXSIZE]; //存放队列元素 int front,rear; //队头指针和队尾指针&#125;SqQueue; 在此约定：初始化创建空队列时，令 front = rear = 0 , 每当插入新的队列尾元素时，尾指针 rear 增1; 每当删除队列头元素时，头指针 front 增1。因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置，如下图所示。 初始状态（队空条件): Q.front == Q.rear == 0。 进队操作: 队不满时，先送值到队尾元素，再将队尾指针加1。 出队操作: 队不空时，先取队头元素值，再将队头指针加1。 思考： 能否用Q.rear==MaxSize作为队列满的条件呢? 答：显然不能，如上图(d)所示，队列中仅有两个元素，但仍满足该条件。这时候入队出现“上溢出” ，但这种溢出并不是真正的溢出，在data数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。 怎么解决这种 “假溢出” 问题呢？一个巧妙的办法就是将顺序队列变为一个环状的空间，如下图所示，称之为循环队列。 初始时: Q.front = Q.rear = 0。 队首指针进1: Q.front = (Q.front+1)%MaxSize。 队尾指针进1: Q.rear = (Q.rear+1 )%MaxSize。 队列长度: (Q.rear+MaxSize-Q.front ) %MaxSize。 新问题： 循环队列队空和队满的判断条件是什么呢？因为队空条件是 Q.front == Q.rear 。而且当入队时有可能出现上图(d)的情况，此时也有Q.front == Q.rear。 那么如何区别队满还是队空呢？ 为了区分队空还是队满的情况，给出三种处理方式进行参考： 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队头指针在队尾指针的下一位置作为队满的标志”，如上图(d2)所示。 此时队满条件为： (Q.rear+1) %MaxSize == Q.front。队空条件仍为： Q.front == Q.rear。 类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size == 0;队满的条件为Q.size == Maxsize。这两种情况都有 Q.front == Q.rear。 类型中增设tag 数据成员，以区分是队满还是队空。tag 等于0时，若因删除导致Q.front == Q.rear，则为队空; tag等于1时，若因插入导致Q.front == Q.rear，则为队满。 下面给出用第一种方法实现循环队列的操作。 一、循环队列的初始化 为队列分配一个最大容量为MaxSize的数组空间。 头指针和尾指针置为零， 表示队列为空。 1234567891011#define MaxSize 10typedef struct&#123; char data[MaxSize]; //存放队列元素 int front, rear; //队头指针和队尾指针&#125; SqQueue;void InitQueue(SqQueue &amp;Q)&#123; Q.front = Q.rear = 0;&#125; 二、求循环队列的长度 对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列，差值可能为负数，所以需要将差值加上MaxSize, 然后与MaxSize求余。 123int QueueLength(SqQueue Q)&#123; return (Q.rear - Q.front + MaxSize)%MaxSize;&#125; 三、循环队列的入队 判断队列是否满，若满则返回false。 将新元素插入队尾。 队尾指针加1。 1234567891011bool enQueue(SqQueue &amp;Q, char val)&#123; if (isFull(Q)) // 队满 (Q.rear + 1) % MaxSize == Q.front; &#123; cout &lt;&lt; &quot;queue is full!&quot; &lt;&lt; endl; return false; &#125; Q.data[Q.rear] = val; Q.rear = (Q.rear+1) % MaxSize; return true;&#125; 四、循环队列的出队 判断队列是否为空， 若空则返回false。 保存队头元素。 队头指针加1。 1234567891011bool deQueue(SqQueue &amp;Q, char &amp;val)&#123; if (isEmpty(Q)) //队空 Q.front == Q.rear; &#123; cout &lt;&lt; &quot;queue is empty!&quot; &lt;&lt; endl; return false; &#125; val = Q.data[Q.front]; Q.front = (Q.front+1) % MaxSize; return true;&#125; 五、取循环队列的队头元素 判断队列是否为空， 若空则返回false。 返回队头元素。 1234567bool GetHead(SqQueue Q,char &amp;val)&#123; if(isEmpty(Q))&#123; return false; &#125; val = Q.data[Q.front]; return true;&#125; 链队—队列的链式表示和实现 队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同)。队列的链式存储如下图所示。 这里和线性表的单链表一样， 为了操作方便起见，给链队添加一个头结点， 并令头指针始终指向头结点。队列的链式存储结构表示如下： 12345678// －－－－－ 队列的链式存储结构－－－－－typedef struct LinkNode&#123; //链式队列结点 ElemType data; struct LinkNode *next;&#125;LinkNode;typedef struct&#123; //链式队列 LinkNode *front,*rear; //队列的队头和队尾指针&#125;LinkQueue; 链队的操作即为单链表插入和删除操作的特殊情况， 只是需进一步修改尾指针或头指针。下面给出链队初始化、 入队、 出队等操作的实现。 链队的基本操作实现如下。 一、链队的初始化 生成新结点作为头结点， 队头和队尾指针指向此结点。 头结点的指针域置空。 1234void InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode)); Q.front-&gt;next = NULL;&#125; 二、链队的入队 为入队元素分配结点空间，用指针s指向。 将新结点数据域置为val。 将新结点插入到队尾 。 修改队尾指针为s。 1234567void enQueue(LinkQueue &amp;Q,char val)&#123; LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode)); s-&gt;data = val; s-&gt;next = NULL; Q.rear-&gt;next = s; Q.rear = s;&#125; 链队的入队即为普通单链表的尾插法，可理解为向尾部插入一个元素，这里不再画图阐述，请读者自行脑补。 三、链队的出队 判断队列是否为空，若空则返回false。 临时保存队头元素的空间，以备释放。 修改队头指针，指向下一个结点。 判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值， 指向头结点。 释放原队头元素的空间。 1234567891011121314bool deQueue(LinkQueue &amp;Q,char &amp;val)&#123; if(isEmpty(Q))&#123; cout&lt;&lt;&quot;Queue is Empty!&quot;&lt;&lt;endl; return false; &#125; LinkNode *p = Q.front-&gt;next; val = p-&gt;data; Q.front-&gt;next = p-&gt;next; if(Q.rear == p) //判断出队元素是否为最后一个元素，细心点，不要遗漏。 Q.rear = Q.front; free(p); return true;&#125; 链队的出队可理解为从单链表中将第一个元素(首元结点)删除的过程，值得注意的是，链队出队操作时还要考虑当队列中最后一个元素被删后，队列尾指针也丢失了，因此需对队尾指针重新赋值（指向头结点）。 四、取链队的队头元素 判断队列是否为空，若空则返回false。 返回队头元素。 12345bool GetHead(LinkQueue Q)&#123; if(isEmpty(Q)) return false; return Q.front-&gt;next-&gt;data;&#125; 双端队列 双端队列是指允许两端都可以进行入队和出队操作的队列，如下图所示。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。 在双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。 输出受限的双端队列 ： 允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列，如下图所示。 输入受限的双端队列 ： 允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列,如下图所示。 若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。 栈和队列的实际应用 栈在进制转换中的应用 想一下，我们在十进制转为其他进制的时候的做法，除取余数法，大致过程如下图所示： 每次除以进制d，然后取余，最后将余数从下至上排列即为d进制数。这刚好符合了栈的特性，每次将取余的数入栈，最后依次出栈，这样刚好将取余的数反过来输出了，这样就实现了十进制转换为d进制数。在这里我们简单实现一个十进制转八进制的函数： 123456789101112131415void conversion(int N)&#123; //对于任意一个非负十进制数，打印输出与其等值的八进制数 stack&lt;int&gt; stack; //这里采用c++内置的栈。 while (N) &#123; stack.push(N%8); N/=8; &#125; while (!stack.empty()) &#123; cout&lt;&lt;stack.top()&lt;&lt;&quot; &quot;; stack.pop(); &#125;&#125; 显然， 该算法的时间和空间复杂度均为 O(log8n)O(log_8n)O(log8​n)。 栈在括号匹配中的应用 假设表达式中允许包含两种括号:圆括号和方括号，其嵌套的顺序任意即 ([]())( []( ) )([]()) 或 [([][])][([][])][([][])] 等均为正确的格式，[)])[)])[)])或 ([())([())([()) 或 (()](()](()] 均为不正确的格式。 考虑下列括号序列： 分析： 计算机接收第1个括号 “[” 后，期待与之匹配的第8个括号 “]” 出现。 获得了第2个括号 “(”，此时第1个括号 “[” 暂时放在一边，而急迫期待与之匹配的第7个括号 “)” 出现。 获得了第3个括号 “[”，此时第2个括号 “(” 暂时放在一边，而急迫期待与之匹配的第4个括号 “]” 出现。第3个括号的期待得到满足，消解之后，第2个括号的期待匹配又成为当前最急迫的任务。 以此类推，可见该处理过程与栈的思想吻合。 实现括号匹配的算法的思想如下： 初始设置一个空栈，顺序读入括号。 若是左括号直接入栈。 如果是右括号，则分为如下几种情况： 栈空，表明没有可以和这个右括号匹配的元素，返回false。 栈不空，从栈中弹出元素，查看弹出括号是否与该右括号匹配。若不匹配，则返回false。 最后，判断栈是否为空，若栈不空表明栈中还有左括号未得到匹配，返回false，若栈空，表明所有括号都得到了匹配，返回true。 12345678910111213141516171819202122232425262728293031323334// 匹配括号bool Matching(char s[])&#123; LiStack S = (LiStack)malloc(sizeof(LiStack)); //初始化栈 S-&gt;next = NULL; char val; //用于记录栈中弹出的元素。 for (int i = 0; i &lt; strlen(s); i++) //遍历字符串 &#123; //cout&lt;&lt;s[i]&lt;&lt;endl; if (s[i] == &#x27;(&#x27; || s[i] == &#x27;[&#x27; || s[i] == &#x27;&#123;&#x27;) //遇到左括号直接入栈 &#123; PushStack(S, s[i]); &#125; else &#123; if (isEmpty(S)) &#123; // 如果不是左括号，并且此时栈中没有可以和右括号匹配的元素，则匹配失败 return false; &#125; PopStack(S, val); if ((s[i] == &#x27;)&#x27; &amp;&amp; val == &#x27;(&#x27;) || (s[i] == &#x27;]&#x27; &amp;&amp; val == &#x27;[&#x27;) || (s[i] == &#x27;&#125;&#x27; &amp;&amp; val == &#x27;&#123;&#x27;)) &#123; // 此情况说明匹配成功，进入判断下一个括号 &#125; else &#123; return false; &#125; &#125; &#125; //最后，倘若循环走完了，栈中还有左括号没有匹配成功，则说明不符合 return isEmpty(S);&#125; 此算法的时间复杂度与空间复杂度均取决于字符串的长度，所以都为O(n)。 栈在表达式求值中的应用 栈在递归中的应用 队列在层次遍历中的应用 队列在计算机系统中的应用 栈和队列的比较","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构(严蔚敏)-第2章 线性表","slug":"数据结构(严蔚敏)-第2章 线性表","date":"2021-08-23T02:43:35.000Z","updated":"2021-08-25T06:28:17.316Z","comments":true,"path":"2021/08/23/数据结构(严蔚敏)-第2章 线性表/","link":"","permalink":"https://alonscholar.github.io/2021/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC2%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表 线性表、栈、队列、串和数组都属于线性结构。 线性结构的基本特点是除第一个元素无直接前驱，最后一个元素无直接后继之外，其他每个数据元素都有一个前驱和后继。线性表是最基本且最常用的一种线性结构， 同时也是其他数据结构的基础， 尤其单链表，是贯穿整个数据结构课程的基本技术。 线性表的定义和特点 线性表：由n(n≥0)n(n≥0)n(n≥0)个数据特性相同的元素构成的有限序列。 空表：线性表中元素个数为0时，称为空表。 对于非空的线性表或线性结构， 其特点是： 存在唯一的一个被称作 ＂第一个＂ 的数据元素； 存在唯一的一个被称作＂ 最后一个＂ 的数据元素； 除第一个之外， 结构中的每个数据元素均只有一个前驱； 除最后一个之外，结构中的每个数据元素均只有一个后继。 线性表的类型定义 线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，而且可以进行插入和删除等操作。下面给出线性表的抽象数据类型定义： 123456789101112131415ADT List&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n&gt;=0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 基本操作： InitList(&amp;L); //初始化表。构造一个空的线性表L，分配内存空间。 DestroyList(&amp;L); //销毁操作。销毁线性表，并释放线性表L所占用的内存空间。 ClearList(&amp;L); //清空操作。将L重置为空表。 ListInsert(&amp;L,i,e); //插入操作。在表L中的第i个位置上插入指定元素e。 ListDelete(&amp;L,i,&amp;e); //删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。 LocateElem(L,e); //按值查找操作。在表L中查找具有给定关键字值的元素。 GetE1em(L,i); //按位查找操作。获取表L中第i个位置的元素的值。 Length(L); //求表长。返回线性表L的长度，即L中数据元素的个数。 PrintList(L); //输出操作。按前后顺序输出线性表L的所有元素值。 Empty(L); //判空操作。若L为空表，则返回true，否则返回false。&#125;ADT List 注： 抽象数据类型仅是一个模型的定义，并不涉及模型的具体实现，因此这里描述中所涉及的参数不必考虑具体数据类型。在实际应用中，数据元素可能有多种类型，到时可根据具体需要选择使用不同的数据类型。 上述抽象数据类型中给出的操作只是基本操作，由这些基本操作可以构成其他较复杂的操作。 对于不同的应用， 基本操作的接口可能不同。 由抽象数据类型定义的线性表， 可以根据实际所采用的存储结构形式， 进行具体的表示和实现。 线性表的顺序表示和实现 线性表的顺序存储表示 线性表的顺序存储又称顺序表。 顺序存储表示 ： 用一组地址连续的存储单元依次存储线性表中的数据元素（这种表示也称作线性表的顺序存储结构或顺序映像），从而使得逻辑上相邻的两个元素在物理位置上也相邻。 假设线性表L存储的起始位置为LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如下图所示： 注意：线性表中的元素的位序是从1开始的，而数组中元素的下标是从0开始的。 线性表的顺序存储结构是一种随机存取的存储结构，即通过首地址和元素序号可以在O(1) 时间内找到指定的元素 由于线性表的长度可变，且所需最大存储空间随问题的不同而不同，在C语言中通常使用动态分配的一维数组表示线性表 : 123456// －－－－－ 顺序表的存储结构－－－－－#define MAXSIZE 100 //顺序表可能达到的最大长度typedef struct &#123; ElemType *elem; //存储空间的基地址，类型可以是int、float、char... int length; //当前长度&#125; SqList; //顺序表的结构类型为SqList 顺序表中基本操作的实现 一、顺序表初始化 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。 将表的当前长度设为0。 12345void InitList(SeqList &amp;L)&#123; //用malloc函数申请一片连续的存储空间,malloc返回连续空间的首地址 L.data = (int *)malloc(InitSize * sizeof(int)); L.length=0;&#125; 二、顺序表取值 判断指定的位置序号 i 值是否合理 (1≤i≤L.length1≤i≤L.length1≤i≤L.length), 若不合理，则返回ERROR。 若 i 值合理，则将第 i 个数据元素 L.elem[i-1] 赋给参数 e, 通过 e 返回第 i 个数据元素的传值。 12345bool GetElem(SqList L,int i,int &amp;e)&#123; // 时间复杂度 O(1) if(i&lt;1 || i&gt;L.length) return false; //如果越界，则返回false e = L.data[i-1]; // i是位序，elem[i-1] 单元存储第 i 个数据元素 return true;&#125; 三、顺序表的按值查找 从第一个元素起，依次和 e 相比较，若找到与 e相等的元素 L.elem[i], 则查找成功，返回该元素的序号 i+1 (数组下标从 0 开始)。 若查遍整个顺序表都没有找到，则查找失败， 返回0。 1234567int locateElem(SqList L,int e)&#123; int i; for(i=0;i&lt;L.length;i++) if(L.data[i]==e) return i+1; return 0;&#125; 最好时间复杂度：O(1)。查找元素在第一个，仅需比较一次。 最坏时间复杂度：O(n)。查找元素在最后一个，需比较n次。 平均时间复杂度：由平均查找长度公式： ASL=∑i=1npiCiASL=\\sum\\limits_{i=1}^np_iC_iASL=i=1∑n​pi​Ci​，以及在这里每个元素的查找概率相等pi=1/np_i=1/npi​=1/n。得 ASL=1n∑i=1ni=n+12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^ni = \\frac{n+1}{2}ASL=n1​i=1∑n​i=2n+1​。由此可见，顺序表按值查找的平均时间复杂度为O(n)。 四、顺序表插入元素 判断插入位置序号 x 值是否合理 (1≤x≤L.length+11≤x≤L.length+11≤x≤L.length+1), 若不合理，则返回ERROR。 判断顺序表的存储空间是否已满，若满则返回 ERROR。 将第L.length个至第 x 个位置的元素依次向后移动一个位置，空出第 x 个位置(x=L.length+1 时无需移动）。 将要插入的新元素e放入第x个位置。 表长加1。 12345678910111213141516/* 在x位置插入元素data x ---&gt; 位序 从顺序表最后一个到x之后都往后移动一位*/bool insertList(SqList &amp;L,int x,int data)&#123; if(x&lt;1 || x&gt;L.length+1) //x值不合法 return false; if(L.length&gt;=MaxSize) //当前存储空间已满 return false; for(int i=L.length;i&gt;=x;i--) L.data[i]=L.data[i-1]; L.data[x-1]=data; L.length++; return true;&#125; 最好时间复杂度： 在表尾插入（即x=L.length+1），元素后移语句将不执行，时间复杂度为O(1)； 最坏时间复杂度： 在表头插入（即x=1），元素后移语句将执行n次，时间复杂度为O(n)； 平均时间复杂度： 假设 pi(pi=1/(n+1))p_i(p_i=1/(n+1))pi​(pi​=1/(n+1)),是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为：∑i=1n+1pi(n−i+1)=∑i=1n+11n+1(n−i+1)=1n+1∑i=1n+1(n−i+1)=1n+1n(n+1)2=n2\\sum\\limits_{i=1}^{n+1}p_i(n-i+1)=\\sum\\limits_{i=1}^{n+1}\\frac {1} {n+1}(n-i+1)=\\frac {1} {n+1}\\sum\\limits_{i=1}^{n+1}(n-i+1)=\\frac {1} {n+1}\\frac {n(n+1)} {2}=\\frac {n} {2}i=1∑n+1​pi​(n−i+1)=i=1∑n+1​n+11​(n−i+1)=n+11​i=1∑n+1​(n−i+1)=n+11​2n(n+1)​=2n​ 因此，线性表插入算法的平均时间复杂度为O(n) 。 五、顺序表删除元素 判断删除位置 x 值是否合理 (1≤x≤L.length1≤x≤L.length1≤x≤L.length), 若不合理，则返回ERROR。 将第x+1个至第L.length个的元素依次向前移动一个位置(x = L.length时无需移动）。 表长减1。 1234567891011bool deleteList(SqList &amp;L,int x)&#123; if(x&lt;1||x&gt;L.length) //判断i的范围是否有效 return false; int e = L.data[x-1]; for(int i=x;i&lt;L.length;i++)&#123;//将第x个位置后的元素前移 L.data[i-1] = L.data[i]; &#125; L.length--; printf(&quot;删除了%d位置的元素：%d\\n&quot;,x,e); return true;&#125; 最好时间复杂度： 删除表尾元素（即x=L.length），无须移动元素，时间复杂度为O(1)； 最坏时间复杂度： 删除表头元素(即 x= 1)，需移动除第一个元素外的所有元素，时间复杂度为O(n)。 平均时间复杂度： 假设pi(pi=1/n)p_i (p_i= 1/n)pi​(pi​=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为: ∑i=1npi(n−i)=∑i=1n1n(n−i)=1n∑i=1n(n−i)=1nn(n−1)2=n−12\\sum\\limits_{i=1}^{n}p_i(n-i)=\\sum\\limits_{i=1}^{n}\\frac {1} {n}(n-i)=\\frac{1}{n}\\sum\\limits_{i=1}^{n}(n-i)=\\frac {1} {n}\\frac {n(n-1)} {2}=\\frac {n-1} {2}i=1∑n​pi​(n−i)=i=1∑n​n1​(n−i)=n1​i=1∑n​(n−i)=n1​2n(n−1)​=2n−1​ 因此,线性表删除算法的平均时间复杂度为O(n)。 线性表的链式表示和实现 链式存储结构的特点：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的），存放数据元素的结点至少包括两个域（数据域、指针域），指针域中存储的信息称作指针或链。n个结点链接成一个链表，即为线性表的链式存储结构。 单链表的定义和表示 当链表的每个结点中只包含一个指针域，又称线性链表或单链表。 首元结点：即链表中存储第一个数据元素的结点。 最后一个结点的指针为NULL 头结点：是在首元素结点之前附设的一个结点，其指针指向首元结点。其数据域可以不存储任何信息。 头指针：指向链表中的第一个结点的存储位置。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。 是否带头结点 链表为空时的情况（L为头指针） 单链表的逻辑状态表示 不带头结点 L == NULL 带头结点 L -&gt; next == NULL 由上述可见，单链表可由头指针唯一确定，在C语言中可用 “结构指针&quot; 来描述： 123456//－－－－－ 单链表的存储结构－－－－－typedef struct LNode&#123; ElemType data; //结点的数据域 struct LNode *next; //结点的指针域&#125;LNode,*LinkList; //LinkList 为指向结构体 LNode 的指针类型 注： 为了提高程序的可读性，在此对同一结构体指针类型起了两个名称，LinkList与 LNode* , 两者本质上是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针；用LNode* 定义指向单链表中任意结点的指针变量。 利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。 单链表的基本操作的实现 一、 单链表的初始化 生成新结点作为头结点，用头指针L 指向头结点。 头结点的指针域置空。 12345bool InitList(LinkList &amp;L)&#123; L = new LNode; //生成新结点作为头结点， 用头指针L指向头结点 L-&gt;next = NULL; //头结点的指针域置空 return true;&#125; 二、单链表的取值 用指针p指向首元结点，用 j 做计数器初值赋为1。 从首元结点开始依次顺着链域 next 向下访问，只要指向当前结点的指针 p 不为空(NULL), 并且没有到达序号为 i 的结点，则循环执行以下操作： p指向下一个结点； 计数器 j 相应加1。 退出循环时， 如果指针p为空， 或者计数器 j 大于 i, 说明指定的序号 i 值不合法（i 大于表长n或 i 小于等于0), 取值失败返回NULL; 否则取值成功， 此时 j=i 时，p所指的结点就是要找的第 i 个结点，返回该结点。 1234567891011121314151617LNode *GetElem(LinkList L, int i)&#123; int j = 1; LNode *p = L-&gt;next; if (i == 0) // 如果i=0，则返回头结点 &#123; return L; &#125; if (i &lt; 0) return NULL; while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; j++; &#125; return p; //返回第i个结点的指针，若i大于表长则返回NULL&#125; 最好时间复杂度：O(1)。i=0或i=1，查找元素为头结点或者是首元结点，仅需比较一次。 最坏时间复杂度：O(n)。查找元素不存在，需比较n次。 平均时间复杂度：假设每个元素的查找概率相等pi=1/np_i=1/npi​=1/n。得 ASL=1n∑i=1n(i−1)=n−12ASL=\\frac{1}{n}\\sum\\limits_{i=1}^n(i-1) = \\frac{n-1}{2}ASL=n1​i=1∑n​(i−1)=2n−1​。由此可见，顺序表按值查找的平均时间复杂度为O(n)。 三、单链表的按值查找 用指针p指向首元结点 。 从首元结点开始依次顺着链域next向下查找， 只要指向当前结点的指针p不为空， 并且p所指结点的数据域不等于给定值e, 则循环执行以下操作： p指向下一个结点 。 返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL 。 123456789LNode *LocateElem(LinkList L, int e)&#123; LNode *p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != e) &#123; p = p-&gt;next; &#125; return p;&#125; 平均时间复杂度：该算法与按序号查找类似，与待查找的值 e 相关，复杂度为 O(n)。 四、单链表的插入 在单链表中要插入元素，只需更改各结点的指针域即可，需要进行如下图的操作： 将值为e的新结点插入到表的第 i 个结点的位置上，即插入到结点 ai−1a_{i-1}ai−1​与aia_iai​之间。 查找结点 ai−1a_{i-1}ai−1​ 并由指针p指向该结点 。 生成一个新结点*s 。 将新结点*s 的数据域置为 e 。 将新结点*s 的指针域指向结点aia_iai​。 将结点 *p 的指针域指向新结点 *s 。 123456789101112131415LinkList insertNode(LinkList &amp;L, int i, int e)&#123; //获取i-1位置的元素 LNode *p = GetElem(L, i - 1); if(p==NULL)&#123;//说明输入的位置不合法 cout&lt;&lt;&quot;请输入正确的位置&quot;&lt;&lt;endl; return L; &#125; //此时p直线第i-1位置的元素 LNode *s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return L;&#125; 平均时间复杂度：与顺序表的插入操作相比，复杂度仍为 O(n)，但是省略了顺序表移动元素的步骤，只需要从头到尾比较一遍链表即可。注意，头插法可以到达O(1)的时间复杂度。 五、单链表的删除 在单链表中要删除元素，只需更改各结点的指针域即可，需要进行如下图的操作： 删除单链表的第 i 个结点aia_iai​。 查找结点 ai−1a_{i-1}ai−1​ 并由指针p指向该结点 。 临时保存待删除结点 aia_iai​ 的地址在 q 中 ，以备释放。 将结点 *p 的指针域指向 aia_iai​ 的直接后继结点 。 释放结点aia_iai​的空间 。 12345678LinkList deleteNode(LinkList &amp;L, int i)&#123; LNode *p = GetElem(L, i - 1); LNode *q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); return L;&#125; 平均时间复杂度：类似于插入算法，删除算法时间复杂度亦为 O(n)； 六、创建单链表 (1) 前插法 创建一个只有头结点的空链表。 根据待创建链表包括的元素个数n, 循环n次执行以下操作： 生成一个新结点 *s; 输入元素值赋给新结点*s 的数据域； 将新结点 *s 插入到头结点之后。 1234567891011121314151617LinkList List_HeadInsert(LinkList &amp;L)&#123; L = new LNode; L-&gt;next = NULL; LNode *s; int x; scanf(&quot;%d&quot;, &amp;x); while (x != 0) //当输入0时表示不再添加元素 &#123; s = (LNode *)malloc(sizeof(LNode)); //开辟一块新的LNode区域。 s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s; scanf(&quot;%d&quot;, &amp;x); &#125; return L;&#125; (2) 后插法 创建一个只有头结点的空链表。 尾指针 r 初始化， 指向头结点。 根据创建链表包括的元素个数n, 循环n次执行以下操作： 生成一个新结点*s; 输入元素值赋给新结点*s 的数据域； 将新结点 *s 插入到尾结点 *r 之后； 尾指针 r 指向新的尾结点 *s。 1234567891011121314151617LinkList List_TailInsert(LinkList &amp;L)&#123; int x; L = (LinkList)malloc(sizeof(LNode)); LNode *s, *r = L; //r用于记录表尾结点 scanf(&quot;%d&quot;, &amp;x); while (x != 0) &#123; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s; scanf(&quot;%d&quot;, &amp;x); &#125; r-&gt;next = NULL; //表尾结点置空 return L;&#125; 循环链表 循环链表(CircularLinked List)：是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他结点，下图所示为单链的循环链表。类似地，还可以有多重链的循环链表。 循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL或p-&gt;next!=NULL,而循环单链表的判别条件为p!=L或p-&gt;next!=L 若在循环链表中设立尾指针而不设立头指针，可使一些操作简化。如将两个线性表进行合并，仅需将第一个表的尾指针指向第二个表的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点。 循环双链表： 由循环单链表的定义不难推出循环双链表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点，如下图所示。 在循环双链表L中，某结点*p为尾结点时，p-&gt;next==L; 当循环双链表为空表时，其头结点的prior域和next域都等于L。 双向链表 单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。 为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next,分别指向其前驱结点和后继结点，如下图所示。 在C语言中可描述如下： 1234567// - - - - -双向链表的存储结构－－－－－typedef struct DuLNode&#123; ElemType data; //数据域 struct DuLNode *prior; //直接前驱 struct DuLNode *next; //直接后继&#125;DuLNode,*DuLinkList; 在双向链表中， 有些操作（如 ListLength、GetElem 和 LocateElem 等）仅需涉及一个方向的指针，则它们的算法描述和线性链表的操作相同，但在插入、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针，下图分别显示了插入和删除结点时指针修改的情况。 在插入结点时需要修改四个指针，在删除结点时需要修改两个指针。两者的时间复杂度均为 O(n)。 一、双向链表的插入 1234567891011121314151617DLinkList insertNode(DLinkList &amp;L,int i,int val)&#123; DNode *p = getElem(L,i-1); if(p==NULL)&#123; cout&lt;&lt;&quot;插入位置不合法&quot;&lt;&lt;endl; return L; &#125; DNode *s = (DNode*)malloc(sizeof(DNode)); //开辟一个空间 s-&gt;data = val; //执行插入操作 s-&gt;next = p-&gt;next; if(p-&gt;next!=NULL) //倘若不是最后一个结点 p-&gt;next-&gt;prior = s; s-&gt;prior = p; p-&gt;next = s; return L;&#125; 二、双向链表的删除 12345678910111213DLinkList deleteNode(DLinkList &amp;L,int i)&#123; DNode *p = getElem(L,i-1); if(p==NULL)&#123; cout&lt;&lt;&quot;输入位置不合法&quot;&lt;&lt;endl; return L; &#125; DNode *q = p-&gt;next; if(q-&gt;next!=NULL) q-&gt;next-&gt;prior = p; p-&gt;next = q-&gt;next; free(q); return L;&#125; 单链表、循环链表和双向链表的比较 顺序表和链表的比较","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构(严蔚敏)-第1章 绪论","slug":"数据结构(严蔚敏)-第1章 绪论","date":"2021-08-22T14:43:35.000Z","updated":"2021-08-24T06:59:38.674Z","comments":true,"path":"2021/08/22/数据结构(严蔚敏)-第1章 绪论/","link":"","permalink":"https://alonscholar.github.io/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%A5%E8%94%9A%E6%95%8F)-%E7%AC%AC1%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/","excerpt":"","text":"绪论 早期的计算机主要用于数值计算，现在，计算机主要用于非数值计算，包括处理字符、表格和图像等具有一定结构的数据。这些数据内容存在着某种联系，只有分清楚数据的内在联系，合理地组织数据，才能对它们进行有效的处理，设计出高效的算法。如何合理地组织数据、高效地处理数据，这就是 “数据结构” 主要研究的问题。本章简要介绍有关数据结构的基本概念和算法分析方法。 数据结构的研究内容 数据的各种逻辑结构和物理结构，以及他们之间的相应关系 对每种结构定义相适应的各种运算 设计出相应的算法 分析算法的效率 基本概念和术语 数据、数据对象、数据元素和数据项 名词 解释 数据 (Data) 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。（整数、实数、字符串、图形、图像、声音及动画…） 数据对象 (Data Object) 是性质相同的数据元素的集合，是数据的一个子集。 数据元素(Data Element) 是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。 在有些情况下，数据元素也称为元素、记录等。数据元素用于完整地描述一个对象，如一名学生记录，图中的一个顶点等。 数据项 (Data Item) 是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。 数据结构 数据结构 (Data Structure) 是相互之间存在一种或多种特定关系的数据元素的集合。 数据结构包括逻辑结构和存储结构两个层次。 逻辑结构 数据的逻辑结构有两个要素：一是数据元素；二是关系。 逻辑结构分为四种类型：集合结构，线性结构，树形结构，图形结构。 类型 简述 图片 集合结构 数据元素同属一个集合，单个数据元素之间没有任何关系。 线性结构 类似于线性关系，线性结构中的数据元素之间是一对一的关系。 树结构 树形结构中的数据元素之间存在一对多的关系。（各元素及元素关系所组成图形类似于树状图）。 图结构 数据元素之间是多对多的关系。 存储结构 物理结构又叫存储结构，分为两种，一种是顺序存储结构一种是链式存储结构。 类型 简述 图片 顺序存储结构 顺序存储结构是把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的。之前学习的数组就是一种顺序存储结构 链式存储结构 链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。根据指针找出相邻元素的位置 数据类型和抽象数据类型 类型 描述 数据类型 一般包括整型、实型、字符型等原子类型外，还有数组、结构体和指针等结构类型。 抽象数据类型 抽象数据类型 (Abstract Data Type, ADT) 一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合。如C语言中的结构体以及 C++、Java中的类。 算法和算法分析 算法的定义及特性 算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。 一个算法必须满足以下五个重要特性。 特性 描述 有穷性 一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。 确定性 对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性， 使算法的执行者或阅读者都能明确其含义及如何执行。 可行性 算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。 输入 一个算法有零个或多个输入。 输出 一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有意义。 评价算法优劣的基本标准 名称 描述 正确性 在合理的数据输入下，能够在有限的运行时间内得到正确的结果。 可读性 一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。 健壮性 当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。 高效性 高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。 算法的时间复杂度 衡量算法效率的方法主要有两类：事后统计法和事前分析估算法。 因为事后统计法的缺点很明显，需要将算法实现等等，所以我们通常采用事前分析估算法。 问题规模和语句频度 问题规模 是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。 语句频度(FrequencyCount)是一条语句的重复执行的次数。 一个算法的执行时间大致上等于其所有语句执行时间的总和， 而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。 12345678// 例：求两个n阶矩阵的乘积算法。i记录行号，j记录列号for(i=1;i&lt;=n;i++) //频度为 n+1 for(j=1;j&lt;=n;j++) //频度为 n*(n+1) &#123; c[i][j] = 0; //频度为 n*n for(k=1;k&lt;=n;k++) //频度为 n*n*(n+1) c[i][j] = c[i][j]+a[i][k]*b[k][j]; //频度为 n*n*n &#125; 该算法中所有语句频度之和， 是矩阵阶数n的函数， 用 f(n)表示之。换句话说， 上例算法的执行时间与f(n）成正比。 f(n)=2n3+3n2+2n+1f(n)=2n^3+3n^2+2n+1f(n)=2n3+3n2+2n+1 算法的时间复杂度定义 ​ 当算法比较复杂时，我们往往不能通过所有语句频度之和来测量算法的时间复杂度。所以我们这里提出了基本语句的概念，所谓 “基本语句” 指的是算法中重复执行次数 和算法的执行时间成正比的语句， 它对算法运行时间的贡献最大。 ​ 如上述代码中，因为 lim⁡n→∞f(n)/n3=lim⁡n→∞(2n3+3n2+2n+1)/n3=2\\lim\\limits_{n\\to\\infty}f(n)/n^3 = \\lim\\limits_{n\\to\\infty}(2n^3+3n^2+2n+1)/n^3=2n→∞lim​f(n)/n3=n→∞lim​(2n3+3n2+2n+1)/n3=2，所以我们称 f(n) 和 n3n^3n3是同阶的，我们用“O”来表示数量级，记作 T(n)=O(f(n))=O(n3)T(n)=O(f(n))=O(n^3)T(n)=O(f(n))=O(n3)。 ​ 随问题规模n的增大，算法执行时间的增长率和 f(n)的增长率相同，称做算法的渐近时间复杂度， 简称时间复杂度(TimeComplexity)。 算法的时间复杂度分析举例 ​ 分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语 句， 计算基本语句的频度得到问题规模n的某个函数 f(n), 取其数量级用符号&quot;O&quot;表示即可。具体计算数量级时， 可以遵循以下定理。 定理1.1 若 f(n)=amnm+am−1nm−1+…+a1n+a0f(n)=a_mn^m+a_{m-1}n^{m-1}+…+a_1n+a_0f(n)=am​nm+am−1​nm−1+…+a1​n+a0​。 是一个m次多项式， 则T(n)=O(nm)T(n)=O(n^m)T(n)=O(nm)。 123456789101112131415161718192021// 举例说明如何求非递归算法的时间复杂度// --------- O(1) --------------&#123;x++;s=0;&#125; for(i=0;i&lt;10000;i++)&#123;x++;s=0;&#125; //时间复杂度均为O(1)// --------- O(n) --------------for(i=0;i&lt;n;i++)&#123;x++;s=0;&#125; //问题规模随着n的增加而增加,T(n)=O(n)// --------- O(n*n) -------------x=0;y=0; // O(1)for(k=1;k&lt;=n;k++) // O(n+1) x++; // O(n)for(i=1;i&lt;=n;i++) // O(n+1) for(j=1;j&lt;=n;j++) // O(n*(n+1)) y++; // O(n*n)// --------- O(n*n*n) -------------x=1;for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 常见的时间复杂度：O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n)O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(2^n)O(1)&lt;O(log2​n)&lt;O(n)&lt;O(nlog2​n)&lt;O(n2)&lt;O(n3)&lt;O(nk)&lt;O(2n) 最好、最坏和平均时间复杂度 最好时间复杂度是指在最好情况下，算法的时间复杂度。 最坏时间复杂度 是指在最坏情况下，算法的时间复杂度。 平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法计算量的加权平均值。 通常情况下，只讨论算法的最坏时间复杂度。 算法的空间复杂度 关千算法的存储空间需求，类似于算法的时间复杂度，我们采用渐近空间复杂度(SpaceComplexity)作为算法所需存储空间的扯度，简称空间复杂度，它也是问题规模n的函数，记作：S(n)=O(f(n)) 空间复杂度只需要分析辅助变量所占的额外空间。 12345678910111213// 数组逆序，将一维数组a中的n个数逆序存放到原数组中。// 算法 1 ，仅需要另外借助一个变量t， 与问题规模n大小无关，所以其空间复杂度为0(1)。for(i=0;i&lt;n/2;i++)&#123; t=a[i]; a[i]=a[n-i-1]; a[n-i-1]=t;&#125;// 算法 2 ，需要另外借助一个大小为n的辅助数组b, 所以其空间复杂度为O(n)。for(i=0;i&lt;n;i++) b[i] = a[n-i-1];for(i=0;i&lt;n;i++) a[i] = b[i];","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://alonscholar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://alonscholar.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://alonscholar.github.io/tags/%E7%AE%97%E6%B3%95/"}]}